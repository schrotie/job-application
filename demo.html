<!DOCTYPE html><html lang="en"><head><!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
    <meta charset="utf-8">
    <meta name="generator" content="Polymer Starter Kit">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>Thorsten Roggendorf</title>
    <meta name="description" content="Thorsten Roggendorf's Application">

    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4QQDDS0TWrXjywAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAACTSURBVDjLY2RgYPjPQBgw4pJgYqAy+E+ki6jnApob8B8N/2VgYHjMwMAwm4GBQZiYMPiPB68ixQCYayUZGBgaoWLvSTUABgSgYk9JDUQOBgYGLQYGhplQ/jpKwmAHAwMDHykJCxl/ZWBgkCMnZXIyMDBchPIPMzAwMJOTtFUZGBg+QsWayc0bIUiJyoHczDURFpUAwvtCJPMwWpUAAAAASUVORK5CYII=">

    <meta name="theme-color" content="#3f51b5">

	 <script>/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.24
!function(){window.WebComponents=window.WebComponents||{flags:{}};var e="webcomponents-lite.js",t=document.querySelector('script[src*="'+e+'"]'),n={};if(!n.noOpts){if(location.search.slice(1).split("&").forEach(function(e){var t,o=e.split("=");o[0]&&(t=o[0].match(/wc-(.+)/))&&(n[t[1]]=o[1]||!0)}),t)for(var o,r=0;o=t.attributes[r];r++)"src"!==o.name&&(n[o.name]=o.value||!0);if(n.log&&n.log.split){var i=n.log.split(",");n.log={},i.forEach(function(e){n.log[e]=!0})}else n.log={}}n.register&&(window.CustomElements=window.CustomElements||{flags:{}},window.CustomElements.flags.register=n.register),WebComponents.flags=n}(),function(e){"use strict";function t(e){return void 0!==h[e]}function n(){s.call(this),this._isInvalid=!0}function o(e){return""==e&&n.call(this),e.toLowerCase()}function r(e){var t=e.charCodeAt(0);return t>32&&t<127&&[34,35,60,62,63,96].indexOf(t)==-1?e:encodeURIComponent(e)}function i(e){var t=e.charCodeAt(0);return t>32&&t<127&&[34,35,60,62,96].indexOf(t)==-1?e:encodeURIComponent(e)}function a(e,a,s){function c(e){g.push(e)}var d=a||"scheme start",l=0,u="",w=!1,_=!1,g=[];e:for(;(e[l-1]!=p||0==l)&&!this._isInvalid;){var b=e[l];switch(d){case"scheme start":if(!b||!m.test(b)){if(a){c("Invalid scheme.");break e}u="",d="no scheme";continue}u+=b.toLowerCase(),d="scheme";break;case"scheme":if(b&&v.test(b))u+=b.toLowerCase();else{if(":"!=b){if(a){if(p==b)break e;c("Code point not allowed in scheme: "+b);break e}u="",l=0,d="no scheme";continue}if(this._scheme=u,u="",a)break e;t(this._scheme)&&(this._isRelative=!0),d="file"==this._scheme?"relative":this._isRelative&&s&&s._scheme==this._scheme?"relative or authority":this._isRelative?"authority first slash":"scheme data"}break;case"scheme data":"?"==b?(this._query="?",d="query"):"#"==b?(this._fragment="#",d="fragment"):p!=b&&"\t"!=b&&"\n"!=b&&"\r"!=b&&(this._schemeData+=r(b));break;case"no scheme":if(s&&t(s._scheme)){d="relative";continue}c("Missing scheme."),n.call(this);break;case"relative or authority":if("/"!=b||"/"!=e[l+1]){c("Expected /, got: "+b),d="relative";continue}d="authority ignore slashes";break;case"relative":if(this._isRelative=!0,"file"!=this._scheme&&(this._scheme=s._scheme),p==b){this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query=s._query,this._username=s._username,this._password=s._password;break e}if("/"==b||"\\"==b)"\\"==b&&c("\\ is an invalid code point."),d="relative slash";else if("?"==b)this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query="?",this._username=s._username,this._password=s._password,d="query";else{if("#"!=b){var y=e[l+1],E=e[l+2];("file"!=this._scheme||!m.test(b)||":"!=y&&"|"!=y||p!=E&&"/"!=E&&"\\"!=E&&"?"!=E&&"#"!=E)&&(this._host=s._host,this._port=s._port,this._username=s._username,this._password=s._password,this._path=s._path.slice(),this._path.pop()),d="relative path";continue}this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query=s._query,this._fragment="#",this._username=s._username,this._password=s._password,d="fragment"}break;case"relative slash":if("/"!=b&&"\\"!=b){"file"!=this._scheme&&(this._host=s._host,this._port=s._port,this._username=s._username,this._password=s._password),d="relative path";continue}"\\"==b&&c("\\ is an invalid code point."),d="file"==this._scheme?"file host":"authority ignore slashes";break;case"authority first slash":if("/"!=b){c("Expected '/', got: "+b),d="authority ignore slashes";continue}d="authority second slash";break;case"authority second slash":if(d="authority ignore slashes","/"!=b){c("Expected '/', got: "+b);continue}break;case"authority ignore slashes":if("/"!=b&&"\\"!=b){d="authority";continue}c("Expected authority, got: "+b);break;case"authority":if("@"==b){w&&(c("@ already seen."),u+="%40"),w=!0;for(var L=0;L<u.length;L++){var N=u[L];if("\t"!=N&&"\n"!=N&&"\r"!=N)if(":"!=N||null!==this._password){var M=r(N);null!==this._password?this._password+=M:this._username+=M}else this._password="";else c("Invalid whitespace in authority.")}u=""}else{if(p==b||"/"==b||"\\"==b||"?"==b||"#"==b){l-=u.length,u="",d="host";continue}u+=b}break;case"file host":if(p==b||"/"==b||"\\"==b||"?"==b||"#"==b){2!=u.length||!m.test(u[0])||":"!=u[1]&&"|"!=u[1]?0==u.length?d="relative path start":(this._host=o.call(this,u),u="",d="relative path start"):d="relative path";continue}"\t"==b||"\n"==b||"\r"==b?c("Invalid whitespace in file host."):u+=b;break;case"host":case"hostname":if(":"!=b||_){if(p==b||"/"==b||"\\"==b||"?"==b||"#"==b){if(this._host=o.call(this,u),u="",d="relative path start",a)break e;continue}"\t"!=b&&"\n"!=b&&"\r"!=b?("["==b?_=!0:"]"==b&&(_=!1),u+=b):c("Invalid code point in host/hostname: "+b)}else if(this._host=o.call(this,u),u="",d="port","hostname"==a)break e;break;case"port":if(/[0-9]/.test(b))u+=b;else{if(p==b||"/"==b||"\\"==b||"?"==b||"#"==b||a){if(""!=u){var T=parseInt(u,10);T!=h[this._scheme]&&(this._port=T+""),u=""}if(a)break e;d="relative path start";continue}"\t"==b||"\n"==b||"\r"==b?c("Invalid code point in port: "+b):n.call(this)}break;case"relative path start":if("\\"==b&&c("'\\' not allowed in path."),d="relative path","/"!=b&&"\\"!=b)continue;break;case"relative path":if(p!=b&&"/"!=b&&"\\"!=b&&(a||"?"!=b&&"#"!=b))"\t"!=b&&"\n"!=b&&"\r"!=b&&(u+=r(b));else{"\\"==b&&c("\\ not allowed in relative path.");var O;(O=f[u.toLowerCase()])&&(u=O),".."==u?(this._path.pop(),"/"!=b&&"\\"!=b&&this._path.push("")):"."==u&&"/"!=b&&"\\"!=b?this._path.push(""):"."!=u&&("file"==this._scheme&&0==this._path.length&&2==u.length&&m.test(u[0])&&"|"==u[1]&&(u=u[0]+":"),this._path.push(u)),u="","?"==b?(this._query="?",d="query"):"#"==b&&(this._fragment="#",d="fragment")}break;case"query":a||"#"!=b?p!=b&&"\t"!=b&&"\n"!=b&&"\r"!=b&&(this._query+=i(b)):(this._fragment="#",d="fragment");break;case"fragment":p!=b&&"\t"!=b&&"\n"!=b&&"\r"!=b&&(this._fragment+=b)}l++}}function s(){this._scheme="",this._schemeData="",this._username="",this._password=null,this._host="",this._port="",this._path=[],this._query="",this._fragment="",this._isInvalid=!1,this._isRelative=!1}function c(e,t){void 0===t||t instanceof c||(t=new c(String(t))),this._url=e,s.call(this);var n=e.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g,"");a.call(this,n,null,t)}var d=!1;if(!e.forceJURL)try{var l=new URL("b","http://a");l.pathname="c%20d",d="http://a/c%20d"===l.href}catch(u){}if(!d){var h=Object.create(null);h.ftp=21,h.file=0,h.gopher=70,h.http=80,h.https=443,h.ws=80,h.wss=443;var f=Object.create(null);f["%2e"]=".",f[".%2e"]="..",f["%2e."]="..",f["%2e%2e"]="..";var p=void 0,m=/[a-zA-Z]/,v=/[a-zA-Z0-9\+\-\.]/;c.prototype={toString:function(){return this.href},get href(){if(this._isInvalid)return this._url;var e="";return""==this._username&&null==this._password||(e=this._username+(null!=this._password?":"+this._password:"")+"@"),this.protocol+(this._isRelative?"//"+e+this.host:"")+this.pathname+this._query+this._fragment},set href(e){s.call(this),a.call(this,e)},get protocol(){return this._scheme+":"},set protocol(e){this._isInvalid||a.call(this,e+":","scheme start")},get host(){return this._isInvalid?"":this._port?this._host+":"+this._port:this._host},set host(e){!this._isInvalid&&this._isRelative&&a.call(this,e,"host")},get hostname(){return this._host},set hostname(e){!this._isInvalid&&this._isRelative&&a.call(this,e,"hostname")},get port(){return this._port},set port(e){!this._isInvalid&&this._isRelative&&a.call(this,e,"port")},get pathname(){return this._isInvalid?"":this._isRelative?"/"+this._path.join("/"):this._schemeData},set pathname(e){!this._isInvalid&&this._isRelative&&(this._path=[],a.call(this,e,"relative path start"))},get search(){return this._isInvalid||!this._query||"?"==this._query?"":this._query},set search(e){!this._isInvalid&&this._isRelative&&(this._query="?","?"==e[0]&&(e=e.slice(1)),a.call(this,e,"query"))},get hash(){return this._isInvalid||!this._fragment||"#"==this._fragment?"":this._fragment},set hash(e){this._isInvalid||(this._fragment="#","#"==e[0]&&(e=e.slice(1)),a.call(this,e,"fragment"))},get origin(){var e;if(this._isInvalid||!this._scheme)return"";switch(this._scheme){case"data":case"file":case"javascript":case"mailto":return"null"}return e=this.host,e?this._scheme+"://"+e:""}};var w=e.URL;w&&(c.createObjectURL=function(e){return w.createObjectURL.apply(w,arguments)},c.revokeObjectURL=function(e){w.revokeObjectURL(e)}),e.URL=c}}(self),"undefined"==typeof WeakMap&&!function(){var e=Object.defineProperty,t=Date.now()%1e9,n=function(){this.name="__st"+(1e9*Math.random()>>>0)+(t++ +"__")};n.prototype={set:function(t,n){var o=t[this.name];return o&&o[0]===t?o[1]=n:e(t,this.name,{value:[t,n],writable:!0}),this},get:function(e){var t;return(t=e[this.name])&&t[0]===e?t[1]:void 0},"delete":function(e){var t=e[this.name];return!(!t||t[0]!==e)&&(t[0]=t[1]=void 0,!0)},has:function(e){var t=e[this.name];return!!t&&t[0]===e}},window.WeakMap=n}(),function(e){function t(e){b.push(e),g||(g=!0,m(o))}function n(e){return window.ShadowDOMPolyfill&&window.ShadowDOMPolyfill.wrapIfNeeded(e)||e}function o(){g=!1;var e=b;b=[],e.sort(function(e,t){return e.uid_-t.uid_});var t=!1;e.forEach(function(e){var n=e.takeRecords();r(e),n.length&&(e.callback_(n,e),t=!0)}),t&&o()}function r(e){e.nodes_.forEach(function(t){var n=v.get(t);n&&n.forEach(function(t){t.observer===e&&t.removeTransientObservers()})})}function i(e,t){for(var n=e;n;n=n.parentNode){var o=v.get(n);if(o)for(var r=0;r<o.length;r++){var i=o[r],a=i.options;if(n===e||a.subtree){var s=t(a);s&&i.enqueue(s)}}}}function a(e){this.callback_=e,this.nodes_=[],this.records_=[],this.uid_=++y}function s(e,t){this.type=e,this.target=t,this.addedNodes=[],this.removedNodes=[],this.previousSibling=null,this.nextSibling=null,this.attributeName=null,this.attributeNamespace=null,this.oldValue=null}function c(e){var t=new s(e.type,e.target);return t.addedNodes=e.addedNodes.slice(),t.removedNodes=e.removedNodes.slice(),t.previousSibling=e.previousSibling,t.nextSibling=e.nextSibling,t.attributeName=e.attributeName,t.attributeNamespace=e.attributeNamespace,t.oldValue=e.oldValue,t}function d(e,t){return E=new s(e,t)}function l(e){return L?L:(L=c(E),L.oldValue=e,L)}function u(){E=L=void 0}function h(e){return e===L||e===E}function f(e,t){return e===t?e:L&&h(e)?L:null}function p(e,t,n){this.observer=e,this.target=t,this.options=n,this.transientObservedNodes=[]}if(!e.JsMutationObserver){var m,v=new WeakMap;if(/Trident|Edge/.test(navigator.userAgent))m=setTimeout;else if(window.setImmediate)m=window.setImmediate;else{var w=[],_=String(Math.random());window.addEventListener("message",function(e){if(e.data===_){var t=w;w=[],t.forEach(function(e){e()})}}),m=function(e){w.push(e),window.postMessage(_,"*")}}var g=!1,b=[],y=0;a.prototype={observe:function(e,t){if(e=n(e),!t.childList&&!t.attributes&&!t.characterData||t.attributeOldValue&&!t.attributes||t.attributeFilter&&t.attributeFilter.length&&!t.attributes||t.characterDataOldValue&&!t.characterData)throw new SyntaxError;var o=v.get(e);o||v.set(e,o=[]);for(var r,i=0;i<o.length;i++)if(o[i].observer===this){r=o[i],r.removeListeners(),r.options=t;break}r||(r=new p(this,e,t),o.push(r),this.nodes_.push(e)),r.addListeners()},disconnect:function(){this.nodes_.forEach(function(e){for(var t=v.get(e),n=0;n<t.length;n++){var o=t[n];if(o.observer===this){o.removeListeners(),t.splice(n,1);break}}},this),this.records_=[]},takeRecords:function(){var e=this.records_;return this.records_=[],e}};var E,L;p.prototype={enqueue:function(e){var n=this.observer.records_,o=n.length;if(n.length>0){var r=n[o-1],i=f(r,e);if(i)return void(n[o-1]=i)}else t(this.observer);n[o]=e},addListeners:function(){this.addListeners_(this.target)},addListeners_:function(e){var t=this.options;t.attributes&&e.addEventListener("DOMAttrModified",this,!0),t.characterData&&e.addEventListener("DOMCharacterDataModified",this,!0),t.childList&&e.addEventListener("DOMNodeInserted",this,!0),(t.childList||t.subtree)&&e.addEventListener("DOMNodeRemoved",this,!0)},removeListeners:function(){this.removeListeners_(this.target)},removeListeners_:function(e){var t=this.options;t.attributes&&e.removeEventListener("DOMAttrModified",this,!0),t.characterData&&e.removeEventListener("DOMCharacterDataModified",this,!0),t.childList&&e.removeEventListener("DOMNodeInserted",this,!0),(t.childList||t.subtree)&&e.removeEventListener("DOMNodeRemoved",this,!0)},addTransientObserver:function(e){if(e!==this.target){this.addListeners_(e),this.transientObservedNodes.push(e);var t=v.get(e);t||v.set(e,t=[]),t.push(this)}},removeTransientObservers:function(){var e=this.transientObservedNodes;this.transientObservedNodes=[],e.forEach(function(e){this.removeListeners_(e);for(var t=v.get(e),n=0;n<t.length;n++)if(t[n]===this){t.splice(n,1);break}},this)},handleEvent:function(e){switch(e.stopImmediatePropagation(),e.type){case"DOMAttrModified":var t=e.attrName,n=e.relatedNode.namespaceURI,o=e.target,r=new d("attributes",o);r.attributeName=t,r.attributeNamespace=n;var a=e.attrChange===MutationEvent.ADDITION?null:e.prevValue;i(o,function(e){if(e.attributes&&(!e.attributeFilter||!e.attributeFilter.length||e.attributeFilter.indexOf(t)!==-1||e.attributeFilter.indexOf(n)!==-1))return e.attributeOldValue?l(a):r});break;case"DOMCharacterDataModified":var o=e.target,r=d("characterData",o),a=e.prevValue;i(o,function(e){if(e.characterData)return e.characterDataOldValue?l(a):r});break;case"DOMNodeRemoved":this.addTransientObserver(e.target);case"DOMNodeInserted":var s,c,h=e.target;"DOMNodeInserted"===e.type?(s=[h],c=[]):(s=[],c=[h]);var f=h.previousSibling,p=h.nextSibling,r=d("childList",e.target.parentNode);r.addedNodes=s,r.removedNodes=c,r.previousSibling=f,r.nextSibling=p,i(e.relatedNode,function(e){if(e.childList)return r})}u()}},e.JsMutationObserver=a,e.MutationObserver||(e.MutationObserver=a,a._isPolyfilled=!0)}}(self),function(){function e(e){switch(e){case"&":return"&amp;";case"<":return"&lt;";case">":return"&gt;";case"Â ":return"&nbsp;"}}function t(t){return t.replace(u,e)}var n="undefined"==typeof HTMLTemplateElement;/Trident/.test(navigator.userAgent)&&!function(){var e=document.importNode;document.importNode=function(){var t=e.apply(document,arguments);if(t.nodeType===Node.DOCUMENT_FRAGMENT_NODE){var n=document.createDocumentFragment();return n.appendChild(t),n}return t}}();var o=function(){if(!n){var e=document.createElement("template"),t=document.createElement("template");t.content.appendChild(document.createElement("div")),e.content.appendChild(t);var o=e.cloneNode(!0);return 0===o.content.childNodes.length||0===o.content.firstChild.content.childNodes.length}}(),r="template",i=function(){};if(n){var a=document.implementation.createHTMLDocument("template"),s=!0,c=document.createElement("style");c.textContent=r+"{display:none;}";var d=document.head;d.insertBefore(c,d.firstElementChild),i.prototype=Object.create(HTMLElement.prototype),i.decorate=function(e){if(!e.content){e.content=a.createDocumentFragment();for(var n;n=e.firstChild;)e.content.appendChild(n);if(e.cloneNode=function(e){return i.cloneNode(this,e)},s)try{Object.defineProperty(e,"innerHTML",{get:function(){for(var e="",n=this.content.firstChild;n;n=n.nextSibling)e+=n.outerHTML||t(n.data);return e},set:function(e){for(a.body.innerHTML=e,i.bootstrap(a);this.content.firstChild;)this.content.removeChild(this.content.firstChild);for(;a.body.firstChild;)this.content.appendChild(a.body.firstChild)},configurable:!0})}catch(o){s=!1}i.bootstrap(e.content)}},i.bootstrap=function(e){for(var t,n=e.querySelectorAll(r),o=0,a=n.length;o<a&&(t=n[o]);o++)i.decorate(t)},document.addEventListener("DOMContentLoaded",function(){i.bootstrap(document)});var l=document.createElement;document.createElement=function(){"use strict";var e=l.apply(document,arguments);return"template"===e.localName&&i.decorate(e),e};var u=/[&\u00A0<>]/g}if(n||o){var h=Node.prototype.cloneNode;i.cloneNode=function(e,t){var n=h.call(e,!1);return this.decorate&&this.decorate(n),t&&(n.content.appendChild(h.call(e.content,!0)),this.fixClonedDom(n.content,e.content)),n},i.fixClonedDom=function(e,t){if(t.querySelectorAll)for(var n,o,i=t.querySelectorAll(r),a=e.querySelectorAll(r),s=0,c=a.length;s<c;s++)o=i[s],n=a[s],this.decorate&&this.decorate(o),n.parentNode.replaceChild(o.cloneNode(!0),n)};var f=document.importNode;Node.prototype.cloneNode=function(e){var t=h.call(this,e);return e&&i.fixClonedDom(t,this),t},document.importNode=function(e,t){if(e.localName===r)return i.cloneNode(e,t);var n=f.call(document,e,t);return t&&i.fixClonedDom(n,e),n},o&&(HTMLTemplateElement.prototype.cloneNode=function(e){return i.cloneNode(this,e)})}n&&(window.HTMLTemplateElement=i)}(),function(e){"use strict";if(!window.performance||!window.performance.now){var t=Date.now();window.performance={now:function(){return Date.now()-t}}}window.requestAnimationFrame||(window.requestAnimationFrame=function(){var e=window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame;return e?function(t){return e(function(){t(performance.now())})}:function(e){return window.setTimeout(e,1e3/60)}}()),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(){return window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||function(e){clearTimeout(e)}}());var n=function(){var e=document.createEvent("Event");return e.initEvent("foo",!0,!0),e.preventDefault(),e.defaultPrevented}();if(!n){var o=Event.prototype.preventDefault;Event.prototype.preventDefault=function(){this.cancelable&&(o.call(this),Object.defineProperty(this,"defaultPrevented",{get:function(){return!0},configurable:!0}))}}var r=/Trident/.test(navigator.userAgent);if((!window.CustomEvent||r&&"function"!=typeof window.CustomEvent)&&(window.CustomEvent=function(e,t){t=t||{};var n=document.createEvent("CustomEvent");return n.initCustomEvent(e,Boolean(t.bubbles),Boolean(t.cancelable),t.detail),n},window.CustomEvent.prototype=window.Event.prototype),!window.Event||r&&"function"!=typeof window.Event){var i=window.Event;window.Event=function(e,t){t=t||{};var n=document.createEvent("Event");return n.initEvent(e,Boolean(t.bubbles),Boolean(t.cancelable)),n},window.Event.prototype=i.prototype}}(window.WebComponents),window.HTMLImports=window.HTMLImports||{flags:{}},function(e){function t(e,t){t=t||p,o(function(){i(e,t)},t)}function n(e){return"complete"===e.readyState||e.readyState===w}function o(e,t){if(n(t))e&&e();else{var r=function(){"complete"!==t.readyState&&t.readyState!==w||(t.removeEventListener(_,r),o(e,t))};t.addEventListener(_,r)}}function r(e){e.target.__loaded=!0}function i(e,t){function n(){c==d&&e&&e({allImports:s,loadedImports:l,errorImports:u})}function o(e){r(e),l.push(this),c++,n()}function i(e){u.push(this),c++,n()}var s=t.querySelectorAll("link[rel=import]"),c=0,d=s.length,l=[],u=[];if(d)for(var h,f=0;f<d&&(h=s[f]);f++)a(h)?(l.push(this),c++,n()):(h.addEventListener("load",o),h.addEventListener("error",i));else n()}function a(e){return u?e.__loaded||e["import"]&&"loading"!==e["import"].readyState:e.__importParsed}function s(e){for(var t,n=0,o=e.length;n<o&&(t=e[n]);n++)c(t)&&d(t)}function c(e){return"link"===e.localName&&"import"===e.rel}function d(e){var t=e["import"];t?r({target:e}):(e.addEventListener("load",r),e.addEventListener("error",r))}var l="import",u=Boolean(l in document.createElement("link")),h=Boolean(window.ShadowDOMPolyfill),f=function(e){return h?window.ShadowDOMPolyfill.wrapIfNeeded(e):e},p=f(document),m={get:function(){var e=window.HTMLImports.currentScript||document.currentScript||("complete"!==document.readyState?document.scripts[document.scripts.length-1]:null);return f(e)},configurable:!0};Object.defineProperty(document,"_currentScript",m),Object.defineProperty(p,"_currentScript",m);var v=/Trident/.test(navigator.userAgent),w=v?"complete":"interactive",_="readystatechange";u&&(new MutationObserver(function(e){for(var t,n=0,o=e.length;n<o&&(t=e[n]);n++)t.addedNodes&&s(t.addedNodes)}).observe(document.head,{childList:!0}),function(){if("loading"===document.readyState)for(var e,t=document.querySelectorAll("link[rel=import]"),n=0,o=t.length;n<o&&(e=t[n]);n++)d(e)}()),t(function(e){window.HTMLImports.ready=!0,window.HTMLImports.readyTime=(new Date).getTime();var t=p.createEvent("CustomEvent");t.initCustomEvent("HTMLImportsLoaded",!0,!0,e),p.dispatchEvent(t)}),e.IMPORT_LINK_TYPE=l,e.useNative=u,e.rootDocument=p,e.whenReady=t,e.isIE=v}(window.HTMLImports),function(e){var t=[],n=function(e){t.push(e)},o=function(){t.forEach(function(t){t(e)})};e.addModule=n,e.initializeModules=o}(window.HTMLImports),window.HTMLImports.addModule(function(e){var t=/(url\()([^)]*)(\))/g,n=/(@import[\s]+(?!url\())([^;]*)(;)/g,o={resolveUrlsInStyle:function(e,t){var n=e.ownerDocument,o=n.createElement("a");return e.textContent=this.resolveUrlsInCssText(e.textContent,t,o),e},resolveUrlsInCssText:function(e,o,r){var i=this.replaceUrls(e,r,o,t);return i=this.replaceUrls(i,r,o,n)},replaceUrls:function(e,t,n,o){return e.replace(o,function(e,o,r,i){var a=r.replace(/["']/g,"");return n&&(a=new URL(a,n).href),t.href=a,a=t.href,o+"'"+a+"'"+i})}};e.path=o}),window.HTMLImports.addModule(function(e){var t={async:!0,ok:function(e){return e.status>=200&&e.status<300||304===e.status||0===e.status},load:function(n,o,r){var i=new XMLHttpRequest;return(e.flags.debug||e.flags.bust)&&(n+="?"+Math.random()),i.open("GET",n,t.async),i.addEventListener("readystatechange",function(e){if(4===i.readyState){var n=null;try{var a=i.getResponseHeader("Location");a&&(n="/"===a.substr(0,1)?location.origin+a:a)}catch(e){console.error(e.message)}o.call(r,!t.ok(i)&&i,i.response||i.responseText,n)}}),i.send(),i},loadDocument:function(e,t,n){this.load(e,t,n).responseType="document"}};e.xhr=t}),window.HTMLImports.addModule(function(e){var t=e.xhr,n=e.flags,o=function(e,t){this.cache={},this.onload=e,this.oncomplete=t,this.inflight=0,this.pending={}};o.prototype={addNodes:function(e){this.inflight+=e.length;for(var t,n=0,o=e.length;n<o&&(t=e[n]);n++)this.require(t);this.checkDone()},addNode:function(e){this.inflight++,this.require(e),this.checkDone()},require:function(e){var t=e.src||e.href;e.__nodeUrl=t,this.dedupe(t,e)||this.fetch(t,e)},dedupe:function(e,t){if(this.pending[e])return this.pending[e].push(t),!0;return this.cache[e]?(this.onload(e,t,this.cache[e]),this.tail(),!0):(this.pending[e]=[t],!1)},fetch:function(e,o){if(n.load&&console.log("fetch",e,o),e)if(e.match(/^data:/)){var r=e.split(","),i=r[0],a=r[1];a=i.indexOf(";base64")>-1?atob(a):decodeURIComponent(a),setTimeout(function(){this.receive(e,o,null,a)}.bind(this),0)}else{var s=function(t,n,r){this.receive(e,o,t,n,r)}.bind(this);t.load(e,s)}else setTimeout(function(){this.receive(e,o,{error:"href must be specified"},null)}.bind(this),0)},receive:function(e,t,n,o,r){this.cache[e]=o;for(var i,a=this.pending[e],s=0,c=a.length;s<c&&(i=a[s]);s++)this.onload(e,i,o,n,r),this.tail();this.pending[e]=null},tail:function(){--this.inflight,this.checkDone()},checkDone:function(){this.inflight||this.oncomplete()}},e.Loader=o}),window.HTMLImports.addModule(function(e){var t=function(e){this.addCallback=e,this.mo=new MutationObserver(this.handler.bind(this))};t.prototype={handler:function(e){for(var t,n=0,o=e.length;n<o&&(t=e[n]);n++)"childList"===t.type&&t.addedNodes.length&&this.addedNodes(t.addedNodes)},addedNodes:function(e){this.addCallback&&this.addCallback(e);for(var t,n=0,o=e.length;n<o&&(t=e[n]);n++)t.children&&t.children.length&&this.addedNodes(t.children)},observe:function(e){this.mo.observe(e,{childList:!0,subtree:!0})}},e.Observer=t}),window.HTMLImports.addModule(function(e){function t(e){return"link"===e.localName&&e.rel===l}function n(e){var t=o(e);return"data:text/javascript;charset=utf-8,"+encodeURIComponent(t)}function o(e){return e.textContent+r(e)}function r(e){var t=e.ownerDocument;t.__importedScripts=t.__importedScripts||0;var n=e.ownerDocument.baseURI,o=t.__importedScripts?"-"+t.__importedScripts:"";return t.__importedScripts++,"\n//# sourceURL="+n+o+".js\n"}function i(e){var t=e.ownerDocument.createElement("style");return t.textContent=e.textContent,a.resolveUrlsInStyle(t),t}var a=e.path,s=e.rootDocument,c=e.flags,d=e.isIE,l=e.IMPORT_LINK_TYPE,u="link[rel="+l+"]",h={documentSelectors:u,importsSelectors:[u,"link[rel=stylesheet]:not([type])","style:not([type])","script:not([type])",'script[type="application/javascript"]','script[type="text/javascript"]'].join(","),map:{link:"parseLink",script:"parseScript",style:"parseStyle"},dynamicElements:[],parseNext:function(){var e=this.nextToParse();e&&this.parse(e)},parse:function(e){if(this.isParsed(e))return void(c.parse&&console.log("[%s] is already parsed",e.localName));var t=this[this.map[e.localName]];t&&(this.markParsing(e),t.call(this,e))},parseDynamic:function(e,t){this.dynamicElements.push(e),t||this.parseNext()},markParsing:function(e){c.parse&&console.log("parsing",e),this.parsingElement=e},markParsingComplete:function(e){e.__importParsed=!0,this.markDynamicParsingComplete(e),e.__importElement&&(e.__importElement.__importParsed=!0,this.markDynamicParsingComplete(e.__importElement)),this.parsingElement=null,c.parse&&console.log("completed",e)},markDynamicParsingComplete:function(e){var t=this.dynamicElements.indexOf(e);t>=0&&this.dynamicElements.splice(t,1)},parseImport:function(e){if(e["import"]=e.__doc,window.HTMLImports.__importsParsingHook&&window.HTMLImports.__importsParsingHook(e),e["import"]&&(e["import"].__importParsed=!0),this.markParsingComplete(e),e.__resource&&!e.__error?e.dispatchEvent(new CustomEvent("load",{bubbles:!1})):e.dispatchEvent(new CustomEvent("error",{bubbles:!1})),e.__pending)for(var t;e.__pending.length;)t=e.__pending.shift(),t&&t({target:e});this.parseNext()},parseLink:function(e){t(e)?this.parseImport(e):(e.href=e.href,this.parseGeneric(e))},parseStyle:function(e){var t=e;e=i(e),t.__appliedElement=e,e.__importElement=t,this.parseGeneric(e)},parseGeneric:function(e){this.trackElement(e),this.addElementToDocument(e)},rootImportForElement:function(e){for(var t=e;t.ownerDocument.__importLink;)t=t.ownerDocument.__importLink;return t},addElementToDocument:function(e){var t=this.rootImportForElement(e.__importElement||e);t.parentNode.insertBefore(e,t)},trackElement:function(e,t){var n=this,o=function(r){e.removeEventListener("load",o),e.removeEventListener("error",o),t&&t(r),n.markParsingComplete(e),n.parseNext()};if(e.addEventListener("load",o),e.addEventListener("error",o),d&&"style"===e.localName){var r=!1;if(e.textContent.indexOf("@import")==-1)r=!0;else if(e.sheet){r=!0;for(var i,a=e.sheet.cssRules,s=a?a.length:0,c=0;c<s&&(i=a[c]);c++)i.type===CSSRule.IMPORT_RULE&&(r=r&&Boolean(i.styleSheet))}r&&setTimeout(function(){e.dispatchEvent(new CustomEvent("load",{bubbles:!1}))})}},parseScript:function(t){var o=document.createElement("script");o.__importElement=t,o.src=t.src?t.src:n(t),e.currentScript=t,this.trackElement(o,function(t){o.parentNode&&o.parentNode.removeChild(o),e.currentScript=null}),this.addElementToDocument(o)},nextToParse:function(){return this._mayParse=[],!this.parsingElement&&(this.nextToParseInDoc(s)||this.nextToParseDynamic())},nextToParseInDoc:function(e,n){if(e&&this._mayParse.indexOf(e)<0){this._mayParse.push(e);for(var o,r=e.querySelectorAll(this.parseSelectorsForNode(e)),i=0,a=r.length;i<a&&(o=r[i]);i++)if(!this.isParsed(o))return this.hasResource(o)?t(o)?this.nextToParseInDoc(o.__doc,o):o:void 0}return n},nextToParseDynamic:function(){return this.dynamicElements[0]},parseSelectorsForNode:function(e){var t=e.ownerDocument||e;return t===s?this.documentSelectors:this.importsSelectors},isParsed:function(e){return e.__importParsed},needsDynamicParsing:function(e){return this.dynamicElements.indexOf(e)>=0},hasResource:function(e){return!t(e)||void 0!==e.__doc}};e.parser=h,e.IMPORT_SELECTOR=u}),window.HTMLImports.addModule(function(e){function t(e){return n(e,a)}function n(e,t){return"link"===e.localName&&e.getAttribute("rel")===t}function o(e){return!!Object.getOwnPropertyDescriptor(e,"baseURI")}function r(e,t){var n=document.implementation.createHTMLDocument(a);n._URL=t;var r=n.createElement("base");r.setAttribute("href",t),n.baseURI||o(n)||Object.defineProperty(n,"baseURI",{value:t});var i=n.createElement("meta");return i.setAttribute("charset","utf-8"),n.head.appendChild(i),n.head.appendChild(r),n.body.innerHTML=e,window.HTMLTemplateElement&&HTMLTemplateElement.bootstrap&&HTMLTemplateElement.bootstrap(n),n}var i=e.flags,a=e.IMPORT_LINK_TYPE,s=e.IMPORT_SELECTOR,c=e.rootDocument,d=e.Loader,l=e.Observer,u=e.parser,h={documents:{},documentPreloadSelectors:s,importsPreloadSelectors:[s].join(","),loadNode:function(e){f.addNode(e)},loadSubtree:function(e){var t=this.marshalNodes(e);f.addNodes(t)},marshalNodes:function(e){return e.querySelectorAll(this.loadSelectorsForNode(e))},loadSelectorsForNode:function(e){var t=e.ownerDocument||e;return t===c?this.documentPreloadSelectors:this.importsPreloadSelectors},loaded:function(e,n,o,a,s){if(i.load&&console.log("loaded",e,n),n.__resource=o,n.__error=a,t(n)){var c=this.documents[e];void 0===c&&(c=a?null:r(o,s||e),c&&(c.__importLink=n,this.bootDocument(c)),this.documents[e]=c),n.__doc=c}u.parseNext()},bootDocument:function(e){this.loadSubtree(e),this.observer.observe(e),u.parseNext()},loadedAll:function(){u.parseNext()}},f=new d(h.loaded.bind(h),h.loadedAll.bind(h));if(h.observer=new l,!document.baseURI){var p={get:function(){var e=document.querySelector("base");return e?e.href:window.location.href},configurable:!0};Object.defineProperty(document,"baseURI",p),Object.defineProperty(c,"baseURI",p)}e.importer=h,e.importLoader=f}),window.HTMLImports.addModule(function(e){var t=e.parser,n=e.importer,o={added:function(e){for(var o,r,i,a,s=0,c=e.length;s<c&&(a=e[s]);s++)o||(o=a.ownerDocument,r=t.isParsed(o)),i=this.shouldLoadNode(a),i&&n.loadNode(a),this.shouldParseNode(a)&&r&&t.parseDynamic(a,i)},shouldLoadNode:function(e){return 1===e.nodeType&&r.call(e,n.loadSelectorsForNode(e))},shouldParseNode:function(e){return 1===e.nodeType&&r.call(e,t.parseSelectorsForNode(e))}};n.observer.addCallback=o.added.bind(o);var r=HTMLElement.prototype.matches||HTMLElement.prototype.matchesSelector||HTMLElement.prototype.webkitMatchesSelector||HTMLElement.prototype.mozMatchesSelector||HTMLElement.prototype.msMatchesSelector}),function(e){function t(){window.HTMLImports.importer.bootDocument(o)}var n=e.initializeModules;e.isIE;if(!e.useNative){n();var o=e.rootDocument;"complete"===document.readyState||"interactive"===document.readyState&&!window.attachEvent?t():document.addEventListener("DOMContentLoaded",t)}}(window.HTMLImports),window.CustomElements=window.CustomElements||{flags:{}},function(e){var t=e.flags,n=[],o=function(e){n.push(e)},r=function(){n.forEach(function(t){t(e)})};e.addModule=o,e.initializeModules=r,e.hasNative=Boolean(document.registerElement),e.isIE=/Trident/.test(navigator.userAgent),e.useNative=!t.register&&e.hasNative&&!window.ShadowDOMPolyfill&&(!window.HTMLImports||window.HTMLImports.useNative)}(window.CustomElements),window.CustomElements.addModule(function(e){function t(e,t){n(e,function(e){return!!t(e)||void o(e,t)}),o(e,t)}function n(e,t,o){var r=e.firstElementChild;if(!r)for(r=e.firstChild;r&&r.nodeType!==Node.ELEMENT_NODE;)r=r.nextSibling;for(;r;)t(r,o)!==!0&&n(r,t,o),r=r.nextElementSibling;return null}function o(e,n){for(var o=e.shadowRoot;o;)t(o,n),o=o.olderShadowRoot}function r(e,t){i(e,t,[])}function i(e,t,n){if(e=window.wrap(e),!(n.indexOf(e)>=0)){n.push(e);for(var o,r=e.querySelectorAll("link[rel="+a+"]"),s=0,c=r.length;s<c&&(o=r[s]);s++)o["import"]&&i(o["import"],t,n);t(e)}}var a=window.HTMLImports?window.HTMLImports.IMPORT_LINK_TYPE:"none";e.forDocumentTree=r,e.forSubtree=t}),window.CustomElements.addModule(function(e){function t(e,t){return n(e,t)||o(e,t)}function n(t,n){return!!e.upgrade(t,n)||void(n&&a(t))}function o(e,t){g(e,function(e){if(n(e,t))return!0})}function r(e){L.push(e),E||(E=!0,setTimeout(i))}function i(){E=!1;for(var e,t=L,n=0,o=t.length;n<o&&(e=t[n]);n++)e();L=[]}function a(e){y?r(function(){s(e);
}):s(e)}function s(e){e.__upgraded__&&!e.__attached&&(e.__attached=!0,e.attachedCallback&&e.attachedCallback())}function c(e){d(e),g(e,function(e){d(e)})}function d(e){y?r(function(){l(e)}):l(e)}function l(e){e.__upgraded__&&e.__attached&&(e.__attached=!1,e.detachedCallback&&e.detachedCallback())}function u(e){for(var t=e,n=window.wrap(document);t;){if(t==n)return!0;t=t.parentNode||t.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&t.host}}function h(e){if(e.shadowRoot&&!e.shadowRoot.__watched){_.dom&&console.log("watching shadow-root for: ",e.localName);for(var t=e.shadowRoot;t;)m(t),t=t.olderShadowRoot}}function f(e,n){if(_.dom){var o=n[0];if(o&&"childList"===o.type&&o.addedNodes&&o.addedNodes){for(var r=o.addedNodes[0];r&&r!==document&&!r.host;)r=r.parentNode;var i=r&&(r.URL||r._URL||r.host&&r.host.localName)||"";i=i.split("/?").shift().split("/").pop()}console.group("mutations (%d) [%s]",n.length,i||"")}var a=u(e);n.forEach(function(e){"childList"===e.type&&(N(e.addedNodes,function(e){e.localName&&t(e,a)}),N(e.removedNodes,function(e){e.localName&&c(e)}))}),_.dom&&console.groupEnd()}function p(e){for(e=window.wrap(e),e||(e=window.wrap(document));e.parentNode;)e=e.parentNode;var t=e.__observer;t&&(f(e,t.takeRecords()),i())}function m(e){if(!e.__observer){var t=new MutationObserver(f.bind(this,e));t.observe(e,{childList:!0,subtree:!0}),e.__observer=t}}function v(e){e=window.wrap(e),_.dom&&console.group("upgradeDocument: ",e.baseURI.split("/").pop());var n=e===window.wrap(document);t(e,n),m(e),_.dom&&console.groupEnd()}function w(e){b(e,v)}var _=e.flags,g=e.forSubtree,b=e.forDocumentTree,y=window.MutationObserver._isPolyfilled&&_["throttle-attached"];e.hasPolyfillMutations=y,e.hasThrottledAttached=y;var E=!1,L=[],N=Array.prototype.forEach.call.bind(Array.prototype.forEach),M=Element.prototype.createShadowRoot;M&&(Element.prototype.createShadowRoot=function(){var e=M.call(this);return window.CustomElements.watchShadow(this),e}),e.watchShadow=h,e.upgradeDocumentTree=w,e.upgradeDocument=v,e.upgradeSubtree=o,e.upgradeAll=t,e.attached=a,e.takeRecords=p}),window.CustomElements.addModule(function(e){function t(t,o){if("template"===t.localName&&window.HTMLTemplateElement&&HTMLTemplateElement.decorate&&HTMLTemplateElement.decorate(t),!t.__upgraded__&&t.nodeType===Node.ELEMENT_NODE){var r=t.getAttribute("is"),i=e.getRegisteredDefinition(t.localName)||e.getRegisteredDefinition(r);if(i&&(r&&i.tag==t.localName||!r&&!i["extends"]))return n(t,i,o)}}function n(t,n,r){return a.upgrade&&console.group("upgrade:",t.localName),n.is&&t.setAttribute("is",n.is),o(t,n),t.__upgraded__=!0,i(t),r&&e.attached(t),e.upgradeSubtree(t,r),a.upgrade&&console.groupEnd(),t}function o(e,t){Object.__proto__?e.__proto__=t.prototype:(r(e,t.prototype,t["native"]),e.__proto__=t.prototype)}function r(e,t,n){for(var o={},r=t;r!==n&&r!==HTMLElement.prototype;){for(var i,a=Object.getOwnPropertyNames(r),s=0;i=a[s];s++)o[i]||(Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(r,i)),o[i]=1);r=Object.getPrototypeOf(r)}}function i(e){e.createdCallback&&e.createdCallback()}var a=e.flags;e.upgrade=t,e.upgradeWithDefinition=n,e.implementPrototype=o}),window.CustomElements.addModule(function(e){function t(t,o){var c=o||{};if(!t)throw new Error("document.registerElement: first argument `name` must not be empty");if(t.indexOf("-")<0)throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '"+String(t)+"'.");if(r(t))throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '"+String(t)+"'. The type name is invalid.");if(d(t))throw new Error("DuplicateDefinitionError: a type with name '"+String(t)+"' is already registered");return c.prototype||(c.prototype=Object.create(HTMLElement.prototype)),c.__name=t.toLowerCase(),c["extends"]&&(c["extends"]=c["extends"].toLowerCase()),c.lifecycle=c.lifecycle||{},c.ancestry=i(c["extends"]),a(c),s(c),n(c.prototype),l(c.__name,c),c.ctor=u(c),c.ctor.prototype=c.prototype,c.prototype.constructor=c.ctor,e.ready&&v(document),c.ctor}function n(e){if(!e.setAttribute._polyfilled){var t=e.setAttribute;e.setAttribute=function(e,n){o.call(this,e,n,t)};var n=e.removeAttribute;e.removeAttribute=function(e){o.call(this,e,null,n)},e.setAttribute._polyfilled=!0}}function o(e,t,n){e=e.toLowerCase();var o=this.getAttribute(e);n.apply(this,arguments);var r=this.getAttribute(e);this.attributeChangedCallback&&r!==o&&this.attributeChangedCallback(e,o,r)}function r(e){for(var t=0;t<y.length;t++)if(e===y[t])return!0}function i(e){var t=d(e);return t?i(t["extends"]).concat([t]):[]}function a(e){for(var t,n=e["extends"],o=0;t=e.ancestry[o];o++)n=t.is&&t.tag;e.tag=n||e.__name,n&&(e.is=e.__name)}function s(e){if(!Object.__proto__){var t=HTMLElement.prototype;if(e.is){var n=document.createElement(e.tag);t=Object.getPrototypeOf(n)}for(var o,r=e.prototype,i=!1;r;)r==t&&(i=!0),o=Object.getPrototypeOf(r),o&&(r.__proto__=o),r=o;i||console.warn(e.tag+" prototype not found in prototype chain for "+e.is),e["native"]=t}}function c(e){return _(N(e.tag),e)}function d(e){if(e)return E[e.toLowerCase()]}function l(e,t){E[e]=t}function u(e){return function(){return c(e)}}function h(e,t,n){return e===L?f(t,n):M(e,t)}function f(e,t){e&&(e=e.toLowerCase()),t&&(t=t.toLowerCase());var n=d(t||e);if(n){if(e==n.tag&&t==n.is)return new n.ctor;if(!t&&!n.is)return new n.ctor}var o;return t?(o=f(e),o.setAttribute("is",t),o):(o=N(e),e.indexOf("-")>=0&&g(o,HTMLElement),o)}function p(e,t){var n=e[t];e[t]=function(){var e=n.apply(this,arguments);return w(e),e}}var m,v=(e.isIE,e.upgradeDocumentTree),w=e.upgradeAll,_=e.upgradeWithDefinition,g=e.implementPrototype,b=e.useNative,y=["annotation-xml","color-profile","font-face","font-face-src","font-face-uri","font-face-format","font-face-name","missing-glyph"],E={},L="http://www.w3.org/1999/xhtml",N=document.createElement.bind(document),M=document.createElementNS.bind(document);m=Object.__proto__||b?function(e,t){return e instanceof t}:function(e,t){if(e instanceof t)return!0;for(var n=e;n;){if(n===t.prototype)return!0;n=n.__proto__}return!1},p(Node.prototype,"cloneNode"),p(document,"importNode"),document.registerElement=t,document.createElement=f,document.createElementNS=h,e.registry=E,e["instanceof"]=m,e.reservedTagList=y,e.getRegisteredDefinition=d,document.register=document.registerElement}),function(e){function t(){i(window.wrap(document)),window.CustomElements.ready=!0;var e=window.requestAnimationFrame||function(e){setTimeout(e,16)};e(function(){setTimeout(function(){window.CustomElements.readyTime=Date.now(),window.HTMLImports&&(window.CustomElements.elapsed=window.CustomElements.readyTime-window.HTMLImports.readyTime),document.dispatchEvent(new CustomEvent("WebComponentsReady",{bubbles:!0}))})})}var n=e.useNative,o=e.initializeModules;e.isIE;if(n){var r=function(){};e.watchShadow=r,e.upgrade=r,e.upgradeAll=r,e.upgradeDocumentTree=r,e.upgradeSubtree=r,e.takeRecords=r,e["instanceof"]=function(e,t){return e instanceof t}}else o();var i=e.upgradeDocumentTree,a=e.upgradeDocument;if(window.wrap||(window.ShadowDOMPolyfill?(window.wrap=window.ShadowDOMPolyfill.wrapIfNeeded,window.unwrap=window.ShadowDOMPolyfill.unwrapIfNeeded):window.wrap=window.unwrap=function(e){return e}),window.HTMLImports&&(window.HTMLImports.__importsParsingHook=function(e){e["import"]&&a(wrap(e["import"]))}),"complete"===document.readyState||e.flags.eager)t();else if("interactive"!==document.readyState||window.attachEvent||window.HTMLImports&&!window.HTMLImports.ready){var s=window.HTMLImports&&!window.HTMLImports.ready?"HTMLImportsLoaded":"DOMContentLoaded";window.addEventListener(s,t)}else t()}(window.CustomElements),function(e){var t=document.createElement("style");t.textContent="body {transition: opacity ease-in 0.2s; } \nbody[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } \n";var n=document.querySelector("head");n.insertBefore(t,n.firstChild)}(window.WebComponents);</script>
    <script>
      // Setup Polymer options
      window.Polymer = {
        dom: 'shadow',
        lazyRegister: true,
      };

		// classList.toggle not available on IE
		function applToggleClass(element, className, bool) {
			if(!element) return;
			var clas = element.className.split(" ");
			var idx = clas.indexOf(className);
			if(arguments.length == 2) bool = idx === -1;
			if((idx !== -1) && bool) return;
			if(bool) clas.push(className);
			else clas.splice(idx, 1);
			element.className = clas.join(" ");
		}

    </script>

    </head>
  <body><div hidden="" by-polymer-bundler=""><script>(function () {
function resolve() {
document.body.removeAttribute('unresolved');
}
if (window.WebComponents) {
addEventListener('WebComponentsReady', resolve);
} else {
if (document.readyState === 'interactive' || document.readyState === 'complete') {
resolve();
} else {
addEventListener('DOMContentLoaded', resolve);
}
}
}());window.Polymer = {
Settings: function () {
var settings = window.Polymer || {};
if (!settings.noUrlSettings) {
var parts = location.search.slice(1).split('&');
for (var i = 0, o; i < parts.length && (o = parts[i]); i++) {
o = o.split('=');
o[0] && (settings[o[0]] = o[1] || true);
}
}
settings.wantShadow = settings.dom === 'shadow';
settings.hasShadow = Boolean(Element.prototype.createShadowRoot);
settings.nativeShadow = settings.hasShadow && !window.ShadowDOMPolyfill;
settings.useShadow = settings.wantShadow && settings.hasShadow;
settings.hasNativeImports = Boolean('import' in document.createElement('link'));
settings.useNativeImports = settings.hasNativeImports;
settings.useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
settings.useNativeShadow = settings.useShadow && settings.nativeShadow;
settings.usePolyfillProto = !settings.useNativeCustomElements && !Object.__proto__;
settings.hasNativeCSSProperties = !navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');
settings.useNativeCSSProperties = settings.hasNativeCSSProperties && settings.lazyRegister && settings.useNativeCSSProperties;
settings.isIE = navigator.userAgent.match('Trident');
settings.passiveTouchGestures = settings.passiveTouchGestures || false;
return settings;
}()
};(function () {
var userPolymer = window.Polymer;
window.Polymer = function (prototype) {
if (typeof prototype === 'function') {
prototype = prototype.prototype;
}
if (!prototype) {
prototype = {};
}
prototype = desugar(prototype);
var customCtor = prototype === prototype.constructor.prototype ? prototype.constructor : null;
var options = { prototype: prototype };
if (prototype.extends) {
options.extends = prototype.extends;
}
Polymer.telemetry._registrate(prototype);
var ctor = document.registerElement(prototype.is, options);
return customCtor || ctor;
};
var desugar = function (prototype) {
var base = Polymer.Base;
if (prototype.extends) {
base = Polymer.Base._getExtendedPrototype(prototype.extends);
}
prototype = Polymer.Base.chainObject(prototype, base);
prototype.registerCallback();
return prototype;
};
if (userPolymer) {
for (var i in userPolymer) {
Polymer[i] = userPolymer[i];
}
}
Polymer.Class = function (prototype) {
if (!prototype.factoryImpl) {
prototype.factoryImpl = function () {
};
}
return desugar(prototype).constructor;
};
}());
Polymer.telemetry = {
registrations: [],
_regLog: function (prototype) {
console.log('[' + prototype.is + ']: registered');
},
_registrate: function (prototype) {
this.registrations.push(prototype);
Polymer.log && this._regLog(prototype);
},
dumpRegistrations: function () {
this.registrations.forEach(this._regLog);
}
};Object.defineProperty(window, 'currentImport', {
enumerable: true,
configurable: true,
get: function () {
return (document._currentScript || document.currentScript || {}).ownerDocument;
}
});Polymer.RenderStatus = {
_ready: false,
_callbacks: [],
whenReady: function (cb) {
if (this._ready) {
cb();
} else {
this._callbacks.push(cb);
}
},
_makeReady: function () {
this._ready = true;
for (var i = 0; i < this._callbacks.length; i++) {
this._callbacks[i]();
}
this._callbacks = [];
},
_catchFirstRender: function () {
requestAnimationFrame(function () {
Polymer.RenderStatus._makeReady();
});
},
_afterNextRenderQueue: [],
_waitingNextRender: false,
afterNextRender: function (element, fn, args) {
this._watchNextRender();
this._afterNextRenderQueue.push([
element,
fn,
args
]);
},
hasRendered: function () {
return this._ready;
},
_watchNextRender: function () {
if (!this._waitingNextRender) {
this._waitingNextRender = true;
var fn = function () {
Polymer.RenderStatus._flushNextRender();
};
if (!this._ready) {
this.whenReady(fn);
} else {
requestAnimationFrame(fn);
}
}
},
_flushNextRender: function () {
var self = this;
setTimeout(function () {
self._flushRenderCallbacks(self._afterNextRenderQueue);
self._afterNextRenderQueue = [];
self._waitingNextRender = false;
});
},
_flushRenderCallbacks: function (callbacks) {
for (var i = 0, h; i < callbacks.length; i++) {
h = callbacks[i];
h[1].apply(h[0], h[2] || Polymer.nar);
}
}
};
if (window.HTMLImports) {
HTMLImports.whenReady(function () {
Polymer.RenderStatus._catchFirstRender();
});
} else {
Polymer.RenderStatus._catchFirstRender();
}
Polymer.ImportStatus = Polymer.RenderStatus;
Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;(function () {
'use strict';
var settings = Polymer.Settings;
Polymer.Base = {
__isPolymerInstance__: true,
_addFeature: function (feature) {
this.mixin(this, feature);
},
registerCallback: function () {
if (settings.lazyRegister === 'max') {
if (this.beforeRegister) {
this.beforeRegister();
}
} else {
this._desugarBehaviors();
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.beforeRegister) {
b.beforeRegister.call(this);
}
}
if (this.beforeRegister) {
this.beforeRegister();
}
}
this._registerFeatures();
if (!settings.lazyRegister) {
this.ensureRegisterFinished();
}
},
createdCallback: function () {
if (settings.disableUpgradeEnabled) {
if (this.hasAttribute('disable-upgrade')) {
this._propertySetter = disableUpgradePropertySetter;
this._configValue = null;
this.__data__ = {};
return;
} else {
this.__hasInitialized = true;
}
}
this.__initialize();
},
__initialize: function () {
if (!this.__hasRegisterFinished) {
this._ensureRegisterFinished(this.__proto__);
}
Polymer.telemetry.instanceCount++;
this.root = this;
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.created) {
b.created.call(this);
}
}
if (this.created) {
this.created();
}
this._initFeatures();
},
ensureRegisterFinished: function () {
this._ensureRegisterFinished(this);
},
_ensureRegisterFinished: function (proto) {
if (proto.__hasRegisterFinished !== proto.is || !proto.is) {
if (settings.lazyRegister === 'max') {
proto._desugarBehaviors();
for (var i = 0, b; i < proto.behaviors.length; i++) {
b = proto.behaviors[i];
if (b.beforeRegister) {
b.beforeRegister.call(proto);
}
}
}
proto.__hasRegisterFinished = proto.is;
if (proto._finishRegisterFeatures) {
proto._finishRegisterFeatures();
}
for (var j = 0, pb; j < proto.behaviors.length; j++) {
pb = proto.behaviors[j];
if (pb.registered) {
pb.registered.call(proto);
}
}
if (proto.registered) {
proto.registered();
}
if (settings.usePolyfillProto && proto !== this) {
proto.extend(this, proto);
}
}
},
attachedCallback: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
self.isAttached = true;
for (var i = 0, b; i < self.behaviors.length; i++) {
b = self.behaviors[i];
if (b.attached) {
b.attached.call(self);
}
}
if (self.attached) {
self.attached();
}
});
},
detachedCallback: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
self.isAttached = false;
for (var i = 0, b; i < self.behaviors.length; i++) {
b = self.behaviors[i];
if (b.detached) {
b.detached.call(self);
}
}
if (self.detached) {
self.detached();
}
});
},
attributeChangedCallback: function (name, oldValue, newValue) {
this._attributeChangedImpl(name);
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.attributeChanged) {
b.attributeChanged.call(this, name, oldValue, newValue);
}
}
if (this.attributeChanged) {
this.attributeChanged(name, oldValue, newValue);
}
},
_attributeChangedImpl: function (name) {
this._setAttributeToProperty(this, name);
},
extend: function (target, source) {
if (target && source) {
var n$ = Object.getOwnPropertyNames(source);
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
this.copyOwnProperty(n, source, target);
}
}
return target || source;
},
mixin: function (target, source) {
for (var i in source) {
target[i] = source[i];
}
return target;
},
copyOwnProperty: function (name, source, target) {
var pd = Object.getOwnPropertyDescriptor(source, name);
if (pd) {
Object.defineProperty(target, name, pd);
}
},
_logger: function (level, args) {
if (args.length === 1 && Array.isArray(args[0])) {
args = args[0];
}
switch (level) {
case 'log':
case 'warn':
case 'error':
console[level].apply(console, args);
break;
}
},
_log: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('log', args);
},
_warn: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('warn', args);
},
_error: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('error', args);
},
_logf: function () {
return this._logPrefix.concat(this.is).concat(Array.prototype.slice.call(arguments, 0));
}
};
Polymer.Base._logPrefix = function () {
var color = window.chrome && !/edge/i.test(navigator.userAgent) || /firefox/i.test(navigator.userAgent);
return color ? [
'%c[%s::%s]:',
'font-weight: bold; background-color:#EEEE00;'
] : ['[%s::%s]:'];
}();
Polymer.Base.chainObject = function (object, inherited) {
if (object && inherited && object !== inherited) {
if (!Object.__proto__) {
object = Polymer.Base.extend(Object.create(inherited), object);
}
object.__proto__ = inherited;
}
return object;
};
Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
Polymer.BaseDescriptors = {};
var disableUpgradePropertySetter;
if (settings.disableUpgradeEnabled) {
disableUpgradePropertySetter = function (property, value) {
this.__data__[property] = value;
};
var origAttributeChangedCallback = Polymer.Base.attributeChangedCallback;
Polymer.Base.attributeChangedCallback = function (name, oldValue, newValue) {
if (!this.__hasInitialized && name === 'disable-upgrade') {
this.__hasInitialized = true;
this._propertySetter = Polymer.Bind._modelApi._propertySetter;
this._configValue = Polymer.Base._configValue;
this.__initialize();
}
origAttributeChangedCallback.call(this, name, oldValue, newValue);
};
}
if (window.CustomElements) {
Polymer.instanceof = CustomElements.instanceof;
} else {
Polymer.instanceof = function (obj, ctor) {
return obj instanceof ctor;
};
}
Polymer.isInstance = function (obj) {
return Boolean(obj && obj.__isPolymerInstance__);
};
Polymer.telemetry.instanceCount = 0;
}());(function () {
var modules = {};
var lcModules = {};
var findModule = function (id) {
return modules[id] || lcModules[id.toLowerCase()];
};
var DomModule = function () {
return document.createElement('dom-module');
};
DomModule.prototype = Object.create(HTMLElement.prototype);
Polymer.Base.mixin(DomModule.prototype, {
createdCallback: function () {
this.register();
},
register: function (id) {
id = id || this.id || this.getAttribute('name') || this.getAttribute('is');
if (id) {
this.id = id;
modules[id] = this;
lcModules[id.toLowerCase()] = this;
}
},
import: function (id, selector) {
if (id) {
var m = findModule(id);
if (!m) {
forceDomModulesUpgrade();
m = findModule(id);
}
if (m && selector) {
m = m.querySelector(selector);
}
return m;
}
}
});
Object.defineProperty(DomModule.prototype, 'constructor', {
value: DomModule,
configurable: true,
writable: true
});
var cePolyfill = window.CustomElements && !CustomElements.useNative;
document.registerElement('dom-module', DomModule);
function forceDomModulesUpgrade() {
if (cePolyfill) {
var script = document._currentScript || document.currentScript;
var doc = script && script.ownerDocument || document;
var modules = doc.querySelectorAll('dom-module');
for (var i = modules.length - 1, m; i >= 0 && (m = modules[i]); i--) {
if (m.__upgraded__) {
return;
} else {
CustomElements.upgrade(m);
}
}
}
}
}());Polymer.Base._addFeature({
_prepIs: function () {
if (!this.is) {
var module = (document._currentScript || document.currentScript).parentNode;
if (module.localName === 'dom-module') {
var id = module.id || module.getAttribute('name') || module.getAttribute('is');
this.is = id;
}
}
if (this.is) {
this.is = this.is.toLowerCase();
}
}
});Polymer.Base._addFeature({
behaviors: [],
_desugarBehaviors: function () {
if (this.behaviors.length) {
this.behaviors = this._desugarSomeBehaviors(this.behaviors);
}
},
_desugarSomeBehaviors: function (behaviors) {
var behaviorSet = [];
behaviors = this._flattenBehaviorsList(behaviors);
for (var i = behaviors.length - 1; i >= 0; i--) {
var b = behaviors[i];
if (behaviorSet.indexOf(b) === -1) {
this._mixinBehavior(b);
behaviorSet.unshift(b);
}
}
return behaviorSet;
},
_flattenBehaviorsList: function (behaviors) {
var flat = [];
for (var i = 0; i < behaviors.length; i++) {
var b = behaviors[i];
if (b instanceof Array) {
flat = flat.concat(this._flattenBehaviorsList(b));
} else if (b) {
flat.push(b);
} else {
this._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));
}
}
return flat;
},
_mixinBehavior: function (b) {
var n$ = Object.getOwnPropertyNames(b);
var useAssignment = b._noAccessors;
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
if (!Polymer.Base._behaviorProperties[n] && !this.hasOwnProperty(n)) {
if (useAssignment) {
this[n] = b[n];
} else {
this.copyOwnProperty(n, b, this);
}
}
}
},
_prepBehaviors: function () {
this._prepFlattenedBehaviors(this.behaviors);
},
_prepFlattenedBehaviors: function (behaviors) {
for (var i = 0, l = behaviors.length; i < l; i++) {
this._prepBehavior(behaviors[i]);
}
this._prepBehavior(this);
},
_marshalBehaviors: function () {
for (var i = 0; i < this.behaviors.length; i++) {
this._marshalBehavior(this.behaviors[i]);
}
this._marshalBehavior(this);
}
});
Polymer.Base._behaviorProperties = {
hostAttributes: true,
beforeRegister: true,
registered: true,
properties: true,
observers: true,
listeners: true,
created: true,
attached: true,
detached: true,
attributeChanged: true,
ready: true,
_noAccessors: true
};Polymer.Base._addFeature({
_getExtendedPrototype: function (tag) {
return this._getExtendedNativePrototype(tag);
},
_nativePrototypes: {},
_getExtendedNativePrototype: function (tag) {
var p = this._nativePrototypes[tag];
if (!p) {
p = Object.create(this.getNativePrototype(tag));
var p$ = Object.getOwnPropertyNames(Polymer.Base);
for (var i = 0, n; i < p$.length && (n = p$[i]); i++) {
if (!Polymer.BaseDescriptors[n]) {
p[n] = Polymer.Base[n];
}
}
Object.defineProperties(p, Polymer.BaseDescriptors);
this._nativePrototypes[tag] = p;
}
return p;
},
getNativePrototype: function (tag) {
return Object.getPrototypeOf(document.createElement(tag));
}
});Polymer.Base._addFeature({
_prepConstructor: function () {
this._factoryArgs = this.extends ? [
this.extends,
this.is
] : [this.is];
var ctor = function () {
return this._factory(arguments);
};
if (this.hasOwnProperty('extends')) {
ctor.extends = this.extends;
}
Object.defineProperty(this, 'constructor', {
value: ctor,
writable: true,
configurable: true
});
ctor.prototype = this;
},
_factory: function (args) {
var elt = document.createElement.apply(document, this._factoryArgs);
if (this.factoryImpl) {
this.factoryImpl.apply(elt, args);
}
return elt;
}
});Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
getPropertyInfo: function (property) {
var info = this._getPropertyInfo(property, this.properties);
if (!info) {
for (var i = 0; i < this.behaviors.length; i++) {
info = this._getPropertyInfo(property, this.behaviors[i].properties);
if (info) {
return info;
}
}
}
return info || Polymer.nob;
},
_getPropertyInfo: function (property, properties) {
var p = properties && properties[property];
if (typeof p === 'function') {
p = properties[property] = { type: p };
}
if (p) {
p.defined = true;
}
return p;
},
_prepPropertyInfo: function () {
this._propertyInfo = {};
for (var i = 0; i < this.behaviors.length; i++) {
this._addPropertyInfo(this._propertyInfo, this.behaviors[i].properties);
}
this._addPropertyInfo(this._propertyInfo, this.properties);
this._addPropertyInfo(this._propertyInfo, this._propertyEffects);
},
_addPropertyInfo: function (target, source) {
if (source) {
var t, s;
for (var i in source) {
t = target[i];
s = source[i];
if (i[0] === '_' && !s.readOnly) {
continue;
}
if (!target[i]) {
target[i] = {
type: typeof s === 'function' ? s : s.type,
readOnly: s.readOnly,
attribute: Polymer.CaseMap.camelToDashCase(i)
};
} else {
if (!t.type) {
t.type = s.type;
}
if (!t.readOnly) {
t.readOnly = s.readOnly;
}
}
}
}
}
});
(function () {
var propertiesDesc = {
configurable: true,
writable: true,
enumerable: true,
value: {}
};
Polymer.BaseDescriptors.properties = propertiesDesc;
Object.defineProperty(Polymer.Base, 'properties', propertiesDesc);
}());Polymer.CaseMap = {
_caseMap: {},
_rx: {
dashToCamel: /-[a-z]/g,
camelToDash: /([A-Z])/g
},
dashToCamelCase: function (dash) {
return this._caseMap[dash] || (this._caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(this._rx.dashToCamel, function (m) {
return m[1].toUpperCase();
}));
},
camelToDashCase: function (camel) {
return this._caseMap[camel] || (this._caseMap[camel] = camel.replace(this._rx.camelToDash, '-$1').toLowerCase());
}
};Polymer.Base._addFeature({
_addHostAttributes: function (attributes) {
if (!this._aggregatedAttributes) {
this._aggregatedAttributes = {};
}
if (attributes) {
this.mixin(this._aggregatedAttributes, attributes);
}
},
_marshalHostAttributes: function () {
if (this._aggregatedAttributes) {
this._applyAttributes(this, this._aggregatedAttributes);
}
},
_applyAttributes: function (node, attr$) {
for (var n in attr$) {
if (!this.hasAttribute(n) && n !== 'class') {
var v = attr$[n];
this.serializeValueToAttribute(v, n, this);
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this);
},
_takeAttributesToModel: function (model) {
if (this.hasAttributes()) {
for (var i in this._propertyInfo) {
var info = this._propertyInfo[i];
if (this.hasAttribute(info.attribute)) {
this._setAttributeToProperty(model, info.attribute, i, info);
}
}
}
},
_setAttributeToProperty: function (model, attribute, property, info) {
if (!this._serializing) {
property = property || Polymer.CaseMap.dashToCamelCase(attribute);
info = info || this._propertyInfo && this._propertyInfo[property];
if (info && !info.readOnly) {
var v = this.getAttribute(attribute);
model[property] = this.deserialize(v, info.type);
}
}
},
_serializing: false,
reflectPropertyToAttribute: function (property, attribute, value) {
this._serializing = true;
value = value === undefined ? this[property] : value;
this.serializeValueToAttribute(value, attribute || Polymer.CaseMap.camelToDashCase(property));
this._serializing = false;
},
serializeValueToAttribute: function (value, attribute, node) {
var str = this.serialize(value);
node = node || this;
if (str === undefined) {
node.removeAttribute(attribute);
} else {
node.setAttribute(attribute, str);
}
},
deserialize: function (value, type) {
switch (type) {
case Number:
value = Number(value);
break;
case Boolean:
value = value != null;
break;
case Object:
try {
value = JSON.parse(value);
} catch (x) {
}
break;
case Array:
try {
value = JSON.parse(value);
} catch (x) {
value = null;
console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
}
break;
case Date:
value = new Date(value);
break;
case String:
default:
break;
}
return value;
},
serialize: function (value) {
switch (typeof value) {
case 'boolean':
return value ? '' : undefined;
case 'object':
if (value instanceof Date) {
return value.toString();
} else if (value) {
try {
return JSON.stringify(value);
} catch (x) {
return '';
}
}
default:
return value != null ? value : undefined;
}
}
});Polymer.version = "1.11.3";Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepBehaviors();
this._prepConstructor();
this._prepPropertyInfo();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_marshalBehavior: function (b) {
},
_initFeatures: function () {
this._marshalHostAttributes();
this._marshalBehaviors();
}
});</script>











<script>(function () {
function resolveCss(cssText, ownerDocument) {
return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
return pre + '\'' + resolve(url.replace(/["']/g, ''), ownerDocument) + '\'' + post;
});
}
function resolveAttrs(element, ownerDocument) {
for (var name in URL_ATTRS) {
var a$ = URL_ATTRS[name];
for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
if (name === '*' || element.localName === name) {
at = element.attributes[a];
v = at && at.value;
if (v && v.search(BINDING_RX) < 0) {
at.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
}
}
}
}
}
function resolve(url, ownerDocument) {
if (url && ABS_URL.test(url)) {
return url;
}
var resolver = getUrlResolver(ownerDocument);
resolver.href = url;
return resolver.href || url;
}
var tempDoc;
var tempDocBase;
function resolveUrl(url, baseUri) {
if (!tempDoc) {
tempDoc = document.implementation.createHTMLDocument('temp');
tempDocBase = tempDoc.createElement('base');
tempDoc.head.appendChild(tempDocBase);
}
tempDocBase.href = baseUri;
return resolve(url, tempDoc);
}
function getUrlResolver(ownerDocument) {
return ownerDocument.body.__urlResolver || (ownerDocument.body.__urlResolver = ownerDocument.createElement('a'));
}
function pathFromUrl(url) {
return url.substring(0, url.lastIndexOf('/') + 1);
}
var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var URL_ATTRS = {
'*': [
'href',
'src',
'style',
'url'
],
form: ['action']
};
var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
var BINDING_RX = /\{\{|\[\[/;
Polymer.ResolveUrl = {
resolveCss: resolveCss,
resolveAttrs: resolveAttrs,
resolveUrl: resolveUrl,
pathFromUrl: pathFromUrl
};
Polymer.rootPath = Polymer.Settings.rootPath || pathFromUrl(document.baseURI || window.location.href);
}());Polymer.Base._addFeature({
_prepTemplate: function () {
var module;
if (this._template === undefined) {
module = Polymer.DomModule.import(this.is);
this._template = module && module.querySelector('template');
}
if (module) {
var assetPath = module.getAttribute('assetpath') || '';
var importURL = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
this._importPath = Polymer.ResolveUrl.pathFromUrl(importURL);
} else {
this._importPath = '';
}
if (this._template && this._template.hasAttribute('is')) {
this._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));
}
if (this._template && !this._template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
HTMLTemplateElement.decorate(this._template);
}
},
_stampTemplate: function () {
if (this._template) {
this.root = this.instanceTemplate(this._template);
}
},
instanceTemplate: function (template) {
var dom = document.importNode(template._content || template.content, true);
return dom;
}
});(function () {
var baseAttachedCallback = Polymer.Base.attachedCallback;
var baseDetachedCallback = Polymer.Base.detachedCallback;
Polymer.Base._addFeature({
_hostStack: [],
ready: function () {
},
_registerHost: function (host) {
this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
if (host && host._clients) {
host._clients.push(this);
}
this._clients = null;
this._clientsReadied = false;
},
_beginHosting: function () {
Polymer.Base._hostStack.push(this);
if (!this._clients) {
this._clients = [];
}
},
_endHosting: function () {
Polymer.Base._hostStack.pop();
},
_tryReady: function () {
this._readied = false;
if (this._canReady()) {
this._ready();
}
},
_canReady: function () {
return !this.dataHost || this.dataHost._clientsReadied;
},
_ready: function () {
this._beforeClientsReady();
if (this._template) {
this._setupRoot();
this._readyClients();
}
this._clientsReadied = true;
this._clients = null;
this._afterClientsReady();
this._readySelf();
},
_readyClients: function () {
this._beginDistribute();
var c$ = this._clients;
if (c$) {
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._ready();
}
}
this._finishDistribute();
},
_readySelf: function () {
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.ready) {
b.ready.call(this);
}
}
if (this.ready) {
this.ready();
}
this._readied = true;
if (this._attachedPending) {
this._attachedPending = false;
this.attachedCallback();
}
},
_beforeClientsReady: function () {
},
_afterClientsReady: function () {
},
_beforeAttached: function () {
},
attachedCallback: function () {
if (this._readied) {
this._beforeAttached();
baseAttachedCallback.call(this);
} else {
this._attachedPending = true;
}
},
detachedCallback: function () {
if (this._readied) {
baseDetachedCallback.call(this);
} else {
this._attachedPending = false;
}
}
});
}());Polymer.ArraySplice = function () {
function newSplice(index, removed, addedCount) {
return {
index: index,
removed: removed,
addedCount: addedCount
};
}
var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;
function ArraySplice() {
}
ArraySplice.prototype = {
calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var rowCount = oldEnd - oldStart + 1;
var columnCount = currentEnd - currentStart + 1;
var distances = new Array(rowCount);
for (var i = 0; i < rowCount; i++) {
distances[i] = new Array(columnCount);
distances[i][0] = i;
}
for (var j = 0; j < columnCount; j++)
distances[0][j] = j;
for (i = 1; i < rowCount; i++) {
for (j = 1; j < columnCount; j++) {
if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
distances[i][j] = distances[i - 1][j - 1];
else {
var north = distances[i - 1][j] + 1;
var west = distances[i][j - 1] + 1;
distances[i][j] = north < west ? north : west;
}
}
}
return distances;
},
spliceOperationsFromEditDistances: function (distances) {
var i = distances.length - 1;
var j = distances[0].length - 1;
var current = distances[i][j];
var edits = [];
while (i > 0 || j > 0) {
if (i == 0) {
edits.push(EDIT_ADD);
j--;
continue;
}
if (j == 0) {
edits.push(EDIT_DELETE);
i--;
continue;
}
var northWest = distances[i - 1][j - 1];
var west = distances[i - 1][j];
var north = distances[i][j - 1];
var min;
if (west < north)
min = west < northWest ? west : northWest;
else
min = north < northWest ? north : northWest;
if (min == northWest) {
if (northWest == current) {
edits.push(EDIT_LEAVE);
} else {
edits.push(EDIT_UPDATE);
current = northWest;
}
i--;
j--;
} else if (min == west) {
edits.push(EDIT_DELETE);
i--;
current = west;
} else {
edits.push(EDIT_ADD);
j--;
current = north;
}
}
edits.reverse();
return edits;
},
calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var prefixCount = 0;
var suffixCount = 0;
var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
if (currentStart == 0 && oldStart == 0)
prefixCount = this.sharedPrefix(current, old, minLength);
if (currentEnd == current.length && oldEnd == old.length)
suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
currentStart += prefixCount;
oldStart += prefixCount;
currentEnd -= suffixCount;
oldEnd -= suffixCount;
if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
return [];
if (currentStart == currentEnd) {
var splice = newSplice(currentStart, [], 0);
while (oldStart < oldEnd)
splice.removed.push(old[oldStart++]);
return [splice];
} else if (oldStart == oldEnd)
return [newSplice(currentStart, [], currentEnd - currentStart)];
var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
splice = undefined;
var splices = [];
var index = currentStart;
var oldIndex = oldStart;
for (var i = 0; i < ops.length; i++) {
switch (ops[i]) {
case EDIT_LEAVE:
if (splice) {
splices.push(splice);
splice = undefined;
}
index++;
oldIndex++;
break;
case EDIT_UPDATE:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
case EDIT_ADD:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
break;
case EDIT_DELETE:
if (!splice)
splice = newSplice(index, [], 0);
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
}
}
if (splice) {
splices.push(splice);
}
return splices;
},
sharedPrefix: function (current, old, searchLength) {
for (var i = 0; i < searchLength; i++)
if (!this.equals(current[i], old[i]))
return i;
return searchLength;
},
sharedSuffix: function (current, old, searchLength) {
var index1 = current.length;
var index2 = old.length;
var count = 0;
while (count < searchLength && this.equals(current[--index1], old[--index2]))
count++;
return count;
},
calculateSplices: function (current, previous) {
return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
},
equals: function (currentValue, previousValue) {
return currentValue === previousValue;
}
};
return new ArraySplice();
}();Polymer.domInnerHTML = function () {
var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;
function escapeReplace(c) {
switch (c) {
case '&':
return '&amp;';
case '<':
return '&lt;';
case '>':
return '&gt;';
case '"':
return '&quot;';
case '\xA0':
return '&nbsp;';
}
}
function escapeAttr(s) {
return s.replace(escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
return s.replace(escapeDataRegExp, escapeReplace);
}
function makeSet(arr) {
var set = {};
for (var i = 0; i < arr.length; i++) {
set[arr[i]] = true;
}
return set;
}
var voidElements = makeSet([
'area',
'base',
'br',
'col',
'command',
'embed',
'hr',
'img',
'input',
'keygen',
'link',
'meta',
'param',
'source',
'track',
'wbr'
]);
var plaintextParents = makeSet([
'style',
'script',
'xmp',
'iframe',
'noembed',
'noframes',
'plaintext',
'noscript'
]);
function getOuterHTML(node, parentNode, composed) {
switch (node.nodeType) {
case Node.ELEMENT_NODE:
var tagName = node.localName;
var s = '<' + tagName;
var attrs = node.attributes;
for (var i = 0, attr; attr = attrs[i]; i++) {
s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
}
s += '>';
if (voidElements[tagName]) {
return s;
}
return s + getInnerHTML(node, composed) + '</' + tagName + '>';
case Node.TEXT_NODE:
var data = node.data;
if (parentNode && plaintextParents[parentNode.localName]) {
return data;
}
return escapeData(data);
case Node.COMMENT_NODE:
return '<!--' + node.data + '-->';
default:
console.error(node);
throw new Error('not implemented');
}
}
function getInnerHTML(node, composed) {
if (node instanceof HTMLTemplateElement)
node = node.content;
var s = '';
var c$ = Polymer.dom(node).childNodes;
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
s += getOuterHTML(child, node, composed);
}
return s;
}
return { getInnerHTML: getInnerHTML };
}();(function () {
'use strict';
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeAppendChild = Element.prototype.appendChild;
var nativeRemoveChild = Element.prototype.removeChild;
Polymer.TreeApi = {
arrayCopyChildNodes: function (parent) {
var copy = [], i = 0;
for (var n = parent.firstChild; n; n = n.nextSibling) {
copy[i++] = n;
}
return copy;
},
arrayCopyChildren: function (parent) {
var copy = [], i = 0;
for (var n = parent.firstElementChild; n; n = n.nextElementSibling) {
copy[i++] = n;
}
return copy;
},
arrayCopy: function (a$) {
var l = a$.length;
var copy = new Array(l);
for (var i = 0; i < l; i++) {
copy[i] = a$[i];
}
return copy;
}
};
Polymer.TreeApi.Logical = {
hasParentNode: function (node) {
return Boolean(node.__dom && node.__dom.parentNode);
},
hasChildNodes: function (node) {
return Boolean(node.__dom && node.__dom.childNodes !== undefined);
},
getChildNodes: function (node) {
return this.hasChildNodes(node) ? this._getChildNodes(node) : node.childNodes;
},
_getChildNodes: function (node) {
if (!node.__dom.childNodes) {
node.__dom.childNodes = [];
for (var n = node.__dom.firstChild; n; n = n.__dom.nextSibling) {
node.__dom.childNodes.push(n);
}
}
return node.__dom.childNodes;
},
getParentNode: function (node) {
return node.__dom && node.__dom.parentNode !== undefined ? node.__dom.parentNode : node.parentNode;
},
getFirstChild: function (node) {
return node.__dom && node.__dom.firstChild !== undefined ? node.__dom.firstChild : node.firstChild;
},
getLastChild: function (node) {
return node.__dom && node.__dom.lastChild !== undefined ? node.__dom.lastChild : node.lastChild;
},
getNextSibling: function (node) {
return node.__dom && node.__dom.nextSibling !== undefined ? node.__dom.nextSibling : node.nextSibling;
},
getPreviousSibling: function (node) {
return node.__dom && node.__dom.previousSibling !== undefined ? node.__dom.previousSibling : node.previousSibling;
},
getFirstElementChild: function (node) {
return node.__dom && node.__dom.firstChild !== undefined ? this._getFirstElementChild(node) : node.firstElementChild;
},
_getFirstElementChild: function (node) {
var n = node.__dom.firstChild;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.nextSibling;
}
return n;
},
getLastElementChild: function (node) {
return node.__dom && node.__dom.lastChild !== undefined ? this._getLastElementChild(node) : node.lastElementChild;
},
_getLastElementChild: function (node) {
var n = node.__dom.lastChild;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.previousSibling;
}
return n;
},
getNextElementSibling: function (node) {
return node.__dom && node.__dom.nextSibling !== undefined ? this._getNextElementSibling(node) : node.nextElementSibling;
},
_getNextElementSibling: function (node) {
var n = node.__dom.nextSibling;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.nextSibling;
}
return n;
},
getPreviousElementSibling: function (node) {
return node.__dom && node.__dom.previousSibling !== undefined ? this._getPreviousElementSibling(node) : node.previousElementSibling;
},
_getPreviousElementSibling: function (node) {
var n = node.__dom.previousSibling;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.previousSibling;
}
return n;
},
saveChildNodes: function (node) {
if (!this.hasChildNodes(node)) {
node.__dom = node.__dom || {};
node.__dom.firstChild = node.firstChild;
node.__dom.lastChild = node.lastChild;
node.__dom.childNodes = [];
for (var n = node.firstChild; n; n = n.nextSibling) {
n.__dom = n.__dom || {};
n.__dom.parentNode = node;
node.__dom.childNodes.push(n);
n.__dom.nextSibling = n.nextSibling;
n.__dom.previousSibling = n.previousSibling;
}
}
},
recordInsertBefore: function (node, container, ref_node) {
container.__dom.childNodes = null;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
for (var n = node.firstChild; n; n = n.nextSibling) {
this._linkNode(n, container, ref_node);
}
} else {
this._linkNode(node, container, ref_node);
}
},
_linkNode: function (node, container, ref_node) {
node.__dom = node.__dom || {};
container.__dom = container.__dom || {};
if (ref_node) {
ref_node.__dom = ref_node.__dom || {};
}
node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling : container.__dom.lastChild;
if (node.__dom.previousSibling) {
node.__dom.previousSibling.__dom.nextSibling = node;
}
node.__dom.nextSibling = ref_node || null;
if (node.__dom.nextSibling) {
node.__dom.nextSibling.__dom.previousSibling = node;
}
node.__dom.parentNode = container;
if (ref_node) {
if (ref_node === container.__dom.firstChild) {
container.__dom.firstChild = node;
}
} else {
container.__dom.lastChild = node;
if (!container.__dom.firstChild) {
container.__dom.firstChild = node;
}
}
container.__dom.childNodes = null;
},
recordRemoveChild: function (node, container) {
node.__dom = node.__dom || {};
container.__dom = container.__dom || {};
if (node === container.__dom.firstChild) {
container.__dom.firstChild = node.__dom.nextSibling;
}
if (node === container.__dom.lastChild) {
container.__dom.lastChild = node.__dom.previousSibling;
}
var p = node.__dom.previousSibling;
var n = node.__dom.nextSibling;
if (p) {
p.__dom.nextSibling = n;
}
if (n) {
n.__dom.previousSibling = p;
}
node.__dom.parentNode = node.__dom.previousSibling = node.__dom.nextSibling = undefined;
container.__dom.childNodes = null;
}
};
Polymer.TreeApi.Composed = {
getChildNodes: function (node) {
return Polymer.TreeApi.arrayCopyChildNodes(node);
},
getParentNode: function (node) {
return node.parentNode;
},
clearChildNodes: function (node) {
node.textContent = '';
},
insertBefore: function (parentNode, newChild, refChild) {
return nativeInsertBefore.call(parentNode, newChild, refChild || null);
},
appendChild: function (parentNode, newChild) {
return nativeAppendChild.call(parentNode, newChild);
},
removeChild: function (parentNode, node) {
return nativeRemoveChild.call(parentNode, node);
}
};
}());Polymer.DomApi = function () {
'use strict';
var Settings = Polymer.Settings;
var TreeApi = Polymer.TreeApi;
var DomApi = function (node) {
this.node = needsToWrap ? DomApi.wrap(node) : node;
};
var needsToWrap = Settings.hasShadow && !Settings.nativeShadow;
DomApi.wrap = window.wrap ? window.wrap : function (node) {
return node;
};
DomApi.prototype = {
flush: function () {
Polymer.dom.flush();
},
deepContains: function (node) {
if (this.node.contains(node)) {
return true;
}
var n = node;
var doc = node.ownerDocument;
while (n && n !== doc && n !== this.node) {
n = Polymer.dom(n).parentNode || n.host;
}
return n === this.node;
},
queryDistributedElements: function (selector) {
var c$ = this.getEffectiveChildNodes();
var list = [];
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE && DomApi.matchesSelector.call(c, selector)) {
list.push(c);
}
}
return list;
},
getEffectiveChildNodes: function () {
var list = [];
var c$ = this.childNodes;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.localName === CONTENT) {
var d$ = dom(c).getDistributedNodes();
for (var j = 0; j < d$.length; j++) {
list.push(d$[j]);
}
} else {
list.push(c);
}
}
return list;
},
observeNodes: function (callback) {
if (callback) {
if (!this.observer) {
this.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this);
}
return this.observer.addListener(callback);
}
},
unobserveNodes: function (handle) {
if (this.observer) {
this.observer.removeListener(handle);
}
},
notifyObserver: function () {
if (this.observer) {
this.observer.notify();
}
},
_query: function (matcher, node, halter) {
node = node || this.node;
var list = [];
this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
return list;
},
_queryElements: function (elements, matcher, halter, list) {
for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE) {
if (this._queryElement(c, matcher, halter, list)) {
return true;
}
}
}
},
_queryElement: function (node, matcher, halter, list) {
var result = matcher(node);
if (result) {
list.push(node);
}
if (halter && halter(result)) {
return result;
}
this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
}
};
var CONTENT = DomApi.CONTENT = 'content';
var dom = DomApi.factory = function (node) {
node = node || document;
if (!node.__domApi) {
node.__domApi = new DomApi.ctor(node);
}
return node.__domApi;
};
DomApi.hasApi = function (node) {
return Boolean(node.__domApi);
};
DomApi.ctor = DomApi;
Polymer.dom = function (obj, patch) {
if (obj instanceof Event) {
return Polymer.EventApi.factory(obj);
} else {
return DomApi.factory(obj, patch);
}
};
var p = Element.prototype;
DomApi.matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
return DomApi;
}();(function () {
'use strict';
var Settings = Polymer.Settings;
var DomApi = Polymer.DomApi;
var dom = DomApi.factory;
var TreeApi = Polymer.TreeApi;
var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
var CONTENT = DomApi.CONTENT;
if (Settings.useShadow) {
return;
}
var nativeCloneNode = Element.prototype.cloneNode;
var nativeImportNode = Document.prototype.importNode;
Polymer.Base.mixin(DomApi.prototype, {
_lazyDistribute: function (host) {
if (host.shadyRoot && host.shadyRoot._distributionClean) {
host.shadyRoot._distributionClean = false;
Polymer.dom.addDebouncer(host.debounce('_distribute', host._distributeContent));
}
},
appendChild: function (node) {
return this.insertBefore(node);
},
insertBefore: function (node, ref_node) {
if (ref_node && TreeApi.Logical.getParentNode(ref_node) !== this.node) {
throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
}
if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
var parent = TreeApi.Logical.getParentNode(node);
if (parent) {
if (DomApi.hasApi(parent)) {
dom(parent).notifyObserver();
}
this._removeNode(node);
} else {
this._removeOwnerShadyRoot(node);
}
}
if (!this._addNode(node, ref_node)) {
if (ref_node) {
ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
}
var container = this.node._isShadyRoot ? this.node.host : this.node;
if (ref_node) {
TreeApi.Composed.insertBefore(container, node, ref_node);
} else {
TreeApi.Composed.appendChild(container, node);
}
}
this.notifyObserver();
return node;
},
_addNode: function (node, ref_node) {
var root = this.getOwnerRoot();
if (root) {
var ipAdded = this._maybeAddInsertionPoint(node, this.node);
if (!root._invalidInsertionPoints) {
root._invalidInsertionPoints = ipAdded;
}
this._addNodeToHost(root.host, node);
}
if (TreeApi.Logical.hasChildNodes(this.node)) {
TreeApi.Logical.recordInsertBefore(node, this.node, ref_node);
}
var handled = this._maybeDistribute(node) || this.node.shadyRoot;
if (handled) {
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
while (node.firstChild) {
TreeApi.Composed.removeChild(node, node.firstChild);
}
} else {
var parent = TreeApi.Composed.getParentNode(node);
if (parent) {
TreeApi.Composed.removeChild(parent, node);
}
}
}
return handled;
},
removeChild: function (node) {
if (TreeApi.Logical.getParentNode(node) !== this.node) {
throw Error('The node to be removed is not a child of this node: ' + node);
}
if (!this._removeNode(node)) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
var parent = TreeApi.Composed.getParentNode(node);
if (container === parent) {
TreeApi.Composed.removeChild(container, node);
}
}
this.notifyObserver();
return node;
},
_removeNode: function (node) {
var logicalParent = TreeApi.Logical.hasParentNode(node) && TreeApi.Logical.getParentNode(node);
var distributed;
var root = this._ownerShadyRootForNode(node);
if (logicalParent) {
distributed = dom(node)._maybeDistributeParent();
TreeApi.Logical.recordRemoveChild(node, logicalParent);
if (root && this._removeDistributedChildren(root, node)) {
root._invalidInsertionPoints = true;
this._lazyDistribute(root.host);
}
}
this._removeOwnerShadyRoot(node);
if (root) {
this._removeNodeFromHost(root.host, node);
}
return distributed;
},
replaceChild: function (node, ref_node) {
this.insertBefore(node, ref_node);
this.removeChild(ref_node);
return node;
},
_hasCachedOwnerRoot: function (node) {
return Boolean(node._ownerShadyRoot !== undefined);
},
getOwnerRoot: function () {
return this._ownerShadyRootForNode(this.node);
},
_ownerShadyRootForNode: function (node) {
if (!node) {
return;
}
var root = node._ownerShadyRoot;
if (root === undefined) {
if (node._isShadyRoot) {
root = node;
} else {
var parent = TreeApi.Logical.getParentNode(node);
if (parent) {
root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
} else {
root = null;
}
}
if (root || document.documentElement.contains(node)) {
node._ownerShadyRoot = root;
}
}
return root;
},
_maybeDistribute: function (node) {
var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && dom(node).querySelector(CONTENT);
var wrappedContent = fragContent && TreeApi.Logical.getParentNode(fragContent).nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
var hasContent = fragContent || node.localName === CONTENT;
if (hasContent) {
var root = this.getOwnerRoot();
if (root) {
this._lazyDistribute(root.host);
}
}
var needsDist = this._nodeNeedsDistribution(this.node);
if (needsDist) {
this._lazyDistribute(this.node);
}
return needsDist || hasContent && !wrappedContent;
},
_maybeAddInsertionPoint: function (node, parent) {
var added;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
var c$ = dom(node).querySelectorAll(CONTENT);
for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
np = TreeApi.Logical.getParentNode(n);
if (np === node) {
np = parent;
}
na = this._maybeAddInsertionPoint(n, np);
added = added || na;
}
} else if (node.localName === CONTENT) {
TreeApi.Logical.saveChildNodes(parent);
TreeApi.Logical.saveChildNodes(node);
added = true;
}
return added;
},
_updateInsertionPoints: function (host) {
var i$ = host.shadyRoot._insertionPoints = dom(host.shadyRoot).querySelectorAll(CONTENT);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
TreeApi.Logical.saveChildNodes(c);
TreeApi.Logical.saveChildNodes(TreeApi.Logical.getParentNode(c));
}
},
_nodeNeedsDistribution: function (node) {
return node && node.shadyRoot && DomApi.hasInsertionPoint(node.shadyRoot);
},
_addNodeToHost: function (host, node) {
if (host._elementAdd) {
host._elementAdd(node);
}
},
_removeNodeFromHost: function (host, node) {
if (host._elementRemove) {
host._elementRemove(node);
}
},
_removeDistributedChildren: function (root, container) {
var hostNeedsDist;
var ip$ = root._insertionPoints;
for (var i = 0; i < ip$.length; i++) {
var content = ip$[i];
if (this._contains(container, content)) {
var dc$ = dom(content).getDistributedNodes();
for (var j = 0; j < dc$.length; j++) {
hostNeedsDist = true;
var node = dc$[j];
var parent = TreeApi.Composed.getParentNode(node);
if (parent) {
TreeApi.Composed.removeChild(parent, node);
}
}
}
}
return hostNeedsDist;
},
_contains: function (container, node) {
while (node) {
if (node == container) {
return true;
}
node = TreeApi.Logical.getParentNode(node);
}
},
_removeOwnerShadyRoot: function (node) {
if (this._hasCachedOwnerRoot(node)) {
var c$ = TreeApi.Logical.getChildNodes(node);
for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
this._removeOwnerShadyRoot(n);
}
}
node._ownerShadyRoot = undefined;
},
_firstComposedNode: function (content) {
var n$ = dom(content).getDistributedNodes();
for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
p$ = dom(n).getDestinationInsertionPoints();
if (p$[p$.length - 1] === content) {
return n;
}
}
},
querySelector: function (selector) {
var result = this._query(function (n) {
return DomApi.matchesSelector.call(n, selector);
}, this.node, function (n) {
return Boolean(n);
})[0];
return result || null;
},
querySelectorAll: function (selector) {
return this._query(function (n) {
return DomApi.matchesSelector.call(n, selector);
}, this.node);
},
getDestinationInsertionPoints: function () {
return this.node._destinationInsertionPoints || [];
},
getDistributedNodes: function () {
return this.node._distributedNodes || [];
},
_clear: function () {
while (this.childNodes.length) {
this.removeChild(this.childNodes[0]);
}
},
setAttribute: function (name, value) {
this.node.setAttribute(name, value);
this._maybeDistributeParent();
},
removeAttribute: function (name) {
this.node.removeAttribute(name);
this._maybeDistributeParent();
},
_maybeDistributeParent: function () {
if (this._nodeNeedsDistribution(this.parentNode)) {
this._lazyDistribute(this.parentNode);
return true;
}
},
cloneNode: function (deep) {
var n = nativeCloneNode.call(this.node, false);
if (deep) {
var c$ = this.childNodes;
var d = dom(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = dom(c$[i]).cloneNode(true);
d.appendChild(nc);
}
}
return n;
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
var n = nativeImportNode.call(doc, externalNode, false);
if (deep) {
var c$ = TreeApi.Logical.getChildNodes(externalNode);
var d = dom(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = dom(doc).importNode(c$[i], true);
d.appendChild(nc);
}
}
return n;
},
_getComposedInnerHTML: function () {
return getInnerHTML(this.node, true);
}
});
Object.defineProperties(DomApi.prototype, {
activeElement: {
get: function () {
var active = document.activeElement;
if (!active) {
return null;
}
var isShadyRoot = !!this.node._isShadyRoot;
if (this.node !== document) {
if (!isShadyRoot) {
return null;
}
if (this.node.host === active || !this.node.host.contains(active)) {
return null;
}
}
var activeRoot = dom(active).getOwnerRoot();
while (activeRoot && activeRoot !== this.node) {
active = activeRoot.host;
activeRoot = dom(active).getOwnerRoot();
}
if (this.node === document) {
return activeRoot ? null : active;
} else {
return activeRoot === this.node ? active : null;
}
},
configurable: true
},
childNodes: {
get: function () {
var c$ = TreeApi.Logical.getChildNodes(this.node);
return Array.isArray(c$) ? c$ : TreeApi.arrayCopyChildNodes(this.node);
},
configurable: true
},
children: {
get: function () {
if (TreeApi.Logical.hasChildNodes(this.node)) {
return Array.prototype.filter.call(this.childNodes, function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
} else {
return TreeApi.arrayCopyChildren(this.node);
}
},
configurable: true
},
parentNode: {
get: function () {
return TreeApi.Logical.getParentNode(this.node);
},
configurable: true
},
firstChild: {
get: function () {
return TreeApi.Logical.getFirstChild(this.node);
},
configurable: true
},
lastChild: {
get: function () {
return TreeApi.Logical.getLastChild(this.node);
},
configurable: true
},
nextSibling: {
get: function () {
return TreeApi.Logical.getNextSibling(this.node);
},
configurable: true
},
previousSibling: {
get: function () {
return TreeApi.Logical.getPreviousSibling(this.node);
},
configurable: true
},
firstElementChild: {
get: function () {
return TreeApi.Logical.getFirstElementChild(this.node);
},
configurable: true
},
lastElementChild: {
get: function () {
return TreeApi.Logical.getLastElementChild(this.node);
},
configurable: true
},
nextElementSibling: {
get: function () {
return TreeApi.Logical.getNextElementSibling(this.node);
},
configurable: true
},
previousElementSibling: {
get: function () {
return TreeApi.Logical.getPreviousElementSibling(this.node);
},
configurable: true
},
textContent: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return this.node.textContent;
} else {
var tc = [];
for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(c.textContent);
}
}
return tc.join('');
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
this.node.textContent = text;
} else {
this._clear();
if (text) {
this.appendChild(document.createTextNode(text));
}
}
},
configurable: true
},
innerHTML: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return null;
} else {
return getInnerHTML(this.node);
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
this._clear();
var d = document.createElement('div');
d.innerHTML = text;
var c$ = TreeApi.arrayCopyChildNodes(d);
for (var i = 0; i < c$.length; i++) {
this.appendChild(c$[i]);
}
}
},
configurable: true
}
});
DomApi.hasInsertionPoint = function (root) {
return Boolean(root && root._insertionPoints.length);
};
}());(function () {
'use strict';
var Settings = Polymer.Settings;
var TreeApi = Polymer.TreeApi;
var DomApi = Polymer.DomApi;
if (!Settings.useShadow) {
return;
}
Polymer.Base.mixin(DomApi.prototype, {
querySelectorAll: function (selector) {
return TreeApi.arrayCopy(this.node.querySelectorAll(selector));
},
getOwnerRoot: function () {
var n = this.node;
while (n) {
if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
return n;
}
n = n.parentNode;
}
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
return doc.importNode(externalNode, deep);
},
getDestinationInsertionPoints: function () {
var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
return n$ ? TreeApi.arrayCopy(n$) : [];
},
getDistributedNodes: function () {
var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
return n$ ? TreeApi.arrayCopy(n$) : [];
}
});
Object.defineProperties(DomApi.prototype, {
activeElement: {
get: function () {
var node = DomApi.wrap(this.node);
var activeElement = node.activeElement;
return node.contains(activeElement) ? activeElement : null;
},
configurable: true
},
childNodes: {
get: function () {
return TreeApi.arrayCopyChildNodes(this.node);
},
configurable: true
},
children: {
get: function () {
return TreeApi.arrayCopyChildren(this.node);
},
configurable: true
},
textContent: {
get: function () {
return this.node.textContent;
},
set: function (value) {
return this.node.textContent = value;
},
configurable: true
},
innerHTML: {
get: function () {
return this.node.innerHTML;
},
set: function (value) {
return this.node.innerHTML = value;
},
configurable: true
}
});
var forwardMethods = function (m$) {
for (var i = 0; i < m$.length; i++) {
forwardMethod(m$[i]);
}
};
var forwardMethod = function (method) {
DomApi.prototype[method] = function () {
return this.node[method].apply(this.node, arguments);
};
};
forwardMethods([
'cloneNode',
'appendChild',
'insertBefore',
'removeChild',
'replaceChild',
'setAttribute',
'removeAttribute',
'querySelector'
]);
var forwardProperties = function (f$) {
for (var i = 0; i < f$.length; i++) {
forwardProperty(f$[i]);
}
};
var forwardProperty = function (name) {
Object.defineProperty(DomApi.prototype, name, {
get: function () {
return this.node[name];
},
configurable: true
});
};
forwardProperties([
'parentNode',
'firstChild',
'lastChild',
'nextSibling',
'previousSibling',
'firstElementChild',
'lastElementChild',
'nextElementSibling',
'previousElementSibling'
]);
}());Polymer.Base.mixin(Polymer.dom, {
_flushGuard: 0,
_FLUSH_MAX: 100,
_needsTakeRecords: !Polymer.Settings.useNativeCustomElements,
_debouncers: [],
_staticFlushList: [],
_finishDebouncer: null,
flush: function () {
this._flushGuard = 0;
this._prepareFlush();
while (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
while (this._debouncers.length) {
this._debouncers.shift().complete();
}
if (this._finishDebouncer) {
this._finishDebouncer.complete();
}
this._prepareFlush();
this._flushGuard++;
}
if (this._flushGuard >= this._FLUSH_MAX) {
console.warn('Polymer.dom.flush aborted. Flush may not be complete.');
}
},
_prepareFlush: function () {
if (this._needsTakeRecords) {
CustomElements.takeRecords();
}
for (var i = 0; i < this._staticFlushList.length; i++) {
this._staticFlushList[i]();
}
},
addStaticFlush: function (fn) {
this._staticFlushList.push(fn);
},
removeStaticFlush: function (fn) {
var i = this._staticFlushList.indexOf(fn);
if (i >= 0) {
this._staticFlushList.splice(i, 1);
}
},
addDebouncer: function (debouncer) {
this._debouncers.push(debouncer);
this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);
},
_finishFlush: function () {
Polymer.dom._debouncers = [];
}
});Polymer.EventApi = function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.Event = function (event) {
this.event = event;
};
if (Settings.useShadow) {
DomApi.Event.prototype = {
get rootTarget() {
return this.event.path[0];
},
get localTarget() {
return this.event.target;
},
get path() {
var path = this.event.path;
if (!Array.isArray(path)) {
path = Array.prototype.slice.call(path);
}
return path;
}
};
} else {
DomApi.Event.prototype = {
get rootTarget() {
return this.event.target;
},
get localTarget() {
var current = this.event.currentTarget;
var currentRoot = current && Polymer.dom(current).getOwnerRoot();
var p$ = this.path;
for (var i = 0; i < p$.length; i++) {
if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
return p$[i];
}
}
},
get path() {
if (!this.event._path) {
var path = [];
var current = this.rootTarget;
while (current) {
path.push(current);
var insertionPoints = Polymer.dom(current).getDestinationInsertionPoints();
if (insertionPoints.length) {
for (var i = 0; i < insertionPoints.length - 1; i++) {
path.push(insertionPoints[i]);
}
current = insertionPoints[insertionPoints.length - 1];
} else {
current = Polymer.dom(current).parentNode || current.host;
}
}
path.push(window);
this.event._path = path;
}
return this.event._path;
}
};
}
var factory = function (event) {
if (!event.__eventApi) {
event.__eventApi = new DomApi.Event(event);
}
return event.__eventApi;
};
return { factory: factory };
}();(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var useShadow = Polymer.Settings.useShadow;
Object.defineProperty(DomApi.prototype, 'classList', {
get: function () {
if (!this._classList) {
this._classList = new DomApi.ClassList(this);
}
return this._classList;
},
configurable: true
});
DomApi.ClassList = function (host) {
this.domApi = host;
this.node = host.node;
};
DomApi.ClassList.prototype = {
add: function () {
this.node.classList.add.apply(this.node.classList, arguments);
this._distributeParent();
},
remove: function () {
this.node.classList.remove.apply(this.node.classList, arguments);
this._distributeParent();
},
toggle: function () {
this.node.classList.toggle.apply(this.node.classList, arguments);
this._distributeParent();
},
_distributeParent: function () {
if (!useShadow) {
this.domApi._maybeDistributeParent();
}
},
contains: function () {
return this.node.classList.contains.apply(this.node.classList, arguments);
}
};
}());(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.EffectiveNodesObserver = function (domApi) {
this.domApi = domApi;
this.node = this.domApi.node;
this._listeners = [];
};
DomApi.EffectiveNodesObserver.prototype = {
addListener: function (callback) {
if (!this._isSetup) {
this._setup();
this._isSetup = true;
}
var listener = {
fn: callback,
_nodes: []
};
this._listeners.push(listener);
this._scheduleNotify();
return listener;
},
removeListener: function (handle) {
var i = this._listeners.indexOf(handle);
if (i >= 0) {
this._listeners.splice(i, 1);
handle._nodes = [];
}
if (!this._hasListeners()) {
this._cleanup();
this._isSetup = false;
}
},
_setup: function () {
this._observeContentElements(this.domApi.childNodes);
},
_cleanup: function () {
this._unobserveContentElements(this.domApi.childNodes);
},
_hasListeners: function () {
return Boolean(this._listeners.length);
},
_scheduleNotify: function () {
if (this._debouncer) {
this._debouncer.stop();
}
this._debouncer = Polymer.Debounce(this._debouncer, this._notify);
this._debouncer.context = this;
Polymer.dom.addDebouncer(this._debouncer);
},
notify: function () {
if (this._hasListeners()) {
this._scheduleNotify();
}
},
_notify: function () {
this._beforeCallListeners();
this._callListeners();
},
_beforeCallListeners: function () {
this._updateContentElements();
},
_updateContentElements: function () {
this._observeContentElements(this.domApi.childNodes);
},
_observeContentElements: function (elements) {
for (var i = 0, n; i < elements.length && (n = elements[i]); i++) {
if (this._isContent(n)) {
n.__observeNodesMap = n.__observeNodesMap || new WeakMap();
if (!n.__observeNodesMap.has(this)) {
n.__observeNodesMap.set(this, this._observeContent(n));
}
}
}
},
_observeContent: function (content) {
var self = this;
var h = Polymer.dom(content).observeNodes(function () {
self._scheduleNotify();
});
h._avoidChangeCalculation = true;
return h;
},
_unobserveContentElements: function (elements) {
for (var i = 0, n, h; i < elements.length && (n = elements[i]); i++) {
if (this._isContent(n)) {
h = n.__observeNodesMap.get(this);
if (h) {
Polymer.dom(n).unobserveNodes(h);
n.__observeNodesMap.delete(this);
}
}
}
},
_isContent: function (node) {
return node.localName === 'content';
},
_callListeners: function () {
var o$ = this._listeners;
var nodes = this._getEffectiveNodes();
for (var i = 0, o; i < o$.length && (o = o$[i]); i++) {
var info = this._generateListenerInfo(o, nodes);
if (info || o._alwaysNotify) {
this._callListener(o, info);
}
}
},
_getEffectiveNodes: function () {
return this.domApi.getEffectiveChildNodes();
},
_generateListenerInfo: function (listener, newNodes) {
if (listener._avoidChangeCalculation) {
return true;
}
var oldNodes = listener._nodes;
var info = {
target: this.node,
addedNodes: [],
removedNodes: []
};
var splices = Polymer.ArraySplice.calculateSplices(newNodes, oldNodes);
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
info.removedNodes.push(n);
}
}
for (i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (j = s.index; j < s.index + s.addedCount; j++) {
info.addedNodes.push(newNodes[j]);
}
}
listener._nodes = newNodes;
if (info.addedNodes.length || info.removedNodes.length) {
return info;
}
},
_callListener: function (listener, info) {
return listener.fn.call(this.node, info);
},
enableShadowAttributeTracking: function () {
}
};
if (Settings.useShadow) {
var baseSetup = DomApi.EffectiveNodesObserver.prototype._setup;
var baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;
Polymer.Base.mixin(DomApi.EffectiveNodesObserver.prototype, {
_setup: function () {
if (!this._observer) {
var self = this;
this._mutationHandler = function (mxns) {
if (mxns && mxns.length) {
self._scheduleNotify();
}
};
this._observer = new MutationObserver(this._mutationHandler);
this._boundFlush = function () {
self._flush();
};
Polymer.dom.addStaticFlush(this._boundFlush);
this._observer.observe(this.node, { childList: true });
}
baseSetup.call(this);
},
_cleanup: function () {
this._observer.disconnect();
this._observer = null;
this._mutationHandler = null;
Polymer.dom.removeStaticFlush(this._boundFlush);
baseCleanup.call(this);
},
_flush: function () {
if (this._observer) {
this._mutationHandler(this._observer.takeRecords());
}
},
enableShadowAttributeTracking: function () {
if (this._observer) {
this._makeContentListenersAlwaysNotify();
this._observer.disconnect();
this._observer.observe(this.node, {
childList: true,
attributes: true,
subtree: true
});
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host && Polymer.dom(host).observer) {
Polymer.dom(host).observer.enableShadowAttributeTracking();
}
}
},
_makeContentListenersAlwaysNotify: function () {
for (var i = 0, h; i < this._listeners.length; i++) {
h = this._listeners[i];
h._alwaysNotify = h._isContentListener;
}
}
});
}
}());(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.DistributedNodesObserver = function (domApi) {
DomApi.EffectiveNodesObserver.call(this, domApi);
};
DomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);
Polymer.Base.mixin(DomApi.DistributedNodesObserver.prototype, {
_setup: function () {
},
_cleanup: function () {
},
_beforeCallListeners: function () {
},
_getEffectiveNodes: function () {
return this.domApi.getDistributedNodes();
}
});
if (Settings.useShadow) {
Polymer.Base.mixin(DomApi.DistributedNodesObserver.prototype, {
_setup: function () {
if (!this._observer) {
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host) {
var self = this;
this._observer = Polymer.dom(host).observeNodes(function () {
self._scheduleNotify();
});
this._observer._isContentListener = true;
if (this._hasAttrSelect()) {
Polymer.dom(host).observer.enableShadowAttributeTracking();
}
}
}
},
_hasAttrSelect: function () {
var select = this.node.getAttribute('select');
return select && select.match(/[[.]+/);
},
_cleanup: function () {
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host) {
Polymer.dom(host).unobserveNodes(this._observer);
}
this._observer = null;
}
});
}
}());(function () {
var DomApi = Polymer.DomApi;
var TreeApi = Polymer.TreeApi;
Polymer.Base._addFeature({
_prepShady: function () {
this._useContent = this._useContent || Boolean(this._template);
},
_setupShady: function () {
this.shadyRoot = null;
if (!this.__domApi) {
this.__domApi = null;
}
if (!this.__dom) {
this.__dom = null;
}
if (!this._ownerShadyRoot) {
this._ownerShadyRoot = undefined;
}
},
_poolContent: function () {
if (this._useContent) {
TreeApi.Logical.saveChildNodes(this);
}
},
_setupRoot: function () {
if (this._useContent) {
this._createLocalRoot();
if (!this.dataHost) {
upgradeLogicalChildren(TreeApi.Logical.getChildNodes(this));
}
}
},
_createLocalRoot: function () {
this.shadyRoot = this.root;
this.shadyRoot._distributionClean = false;
this.shadyRoot._hasDistributed = false;
this.shadyRoot._isShadyRoot = true;
this.shadyRoot._dirtyRoots = [];
var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];
TreeApi.Logical.saveChildNodes(this.shadyRoot);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
TreeApi.Logical.saveChildNodes(c);
TreeApi.Logical.saveChildNodes(c.parentNode);
}
this.shadyRoot.host = this;
},
distributeContent: function (updateInsertionPoints) {
if (this.shadyRoot) {
this.shadyRoot._invalidInsertionPoints = this.shadyRoot._invalidInsertionPoints || updateInsertionPoints;
var host = getTopDistributingHost(this);
Polymer.dom(this)._lazyDistribute(host);
}
},
_distributeContent: function () {
if (this._useContent && !this.shadyRoot._distributionClean) {
if (this.shadyRoot._invalidInsertionPoints) {
Polymer.dom(this)._updateInsertionPoints(this);
this.shadyRoot._invalidInsertionPoints = false;
}
this._beginDistribute();
this._distributeDirtyRoots();
this._finishDistribute();
}
},
_beginDistribute: function () {
if (this._useContent && DomApi.hasInsertionPoint(this.shadyRoot)) {
this._resetDistribution();
this._distributePool(this.shadyRoot, this._collectPool());
}
},
_distributeDirtyRoots: function () {
var c$ = this.shadyRoot._dirtyRoots;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._distributeContent();
}
this.shadyRoot._dirtyRoots = [];
},
_finishDistribute: function () {
if (this._useContent) {
this.shadyRoot._distributionClean = true;
if (DomApi.hasInsertionPoint(this.shadyRoot)) {
this._composeTree();
notifyContentObservers(this.shadyRoot);
} else {
if (!this.shadyRoot._hasDistributed) {
TreeApi.Composed.clearChildNodes(this);
this.appendChild(this.shadyRoot);
} else {
var children = this._composeNode(this);
this._updateChildNodes(this, children);
}
}
if (!this.shadyRoot._hasDistributed) {
notifyInitialDistribution(this);
}
this.shadyRoot._hasDistributed = true;
}
},
elementMatches: function (selector, node) {
node = node || this;
return DomApi.matchesSelector.call(node, selector);
},
_resetDistribution: function () {
var children = TreeApi.Logical.getChildNodes(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (child._destinationInsertionPoints) {
child._destinationInsertionPoints = undefined;
}
if (isInsertionPoint(child)) {
clearDistributedDestinationInsertionPoints(child);
}
}
var root = this.shadyRoot;
var p$ = root._insertionPoints;
for (var j = 0; j < p$.length; j++) {
p$[j]._distributedNodes = [];
}
},
_collectPool: function () {
var pool = [];
var children = TreeApi.Logical.getChildNodes(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (isInsertionPoint(child)) {
pool.push.apply(pool, child._distributedNodes);
} else {
pool.push(child);
}
}
return pool;
},
_distributePool: function (node, pool) {
var p$ = node._insertionPoints;
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
this._distributeInsertionPoint(p, pool);
maybeRedistributeParent(p, this);
}
},
_distributeInsertionPoint: function (content, pool) {
var anyDistributed = false;
for (var i = 0, l = pool.length, node; i < l; i++) {
node = pool[i];
if (!node) {
continue;
}
if (this._matchesContentSelect(node, content)) {
distributeNodeInto(node, content);
pool[i] = undefined;
anyDistributed = true;
}
}
if (!anyDistributed) {
var children = TreeApi.Logical.getChildNodes(content);
for (var j = 0; j < children.length; j++) {
distributeNodeInto(children[j], content);
}
}
},
_composeTree: function () {
this._updateChildNodes(this, this._composeNode(this));
var p$ = this.shadyRoot._insertionPoints;
for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
parent = TreeApi.Logical.getParentNode(p);
if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
this._updateChildNodes(parent, this._composeNode(parent));
}
}
},
_composeNode: function (node) {
var children = [];
var c$ = TreeApi.Logical.getChildNodes(node.shadyRoot || node);
for (var i = 0; i < c$.length; i++) {
var child = c$[i];
if (isInsertionPoint(child)) {
var distributedNodes = child._distributedNodes;
for (var j = 0; j < distributedNodes.length; j++) {
var distributedNode = distributedNodes[j];
if (isFinalDestination(child, distributedNode)) {
children.push(distributedNode);
}
}
} else {
children.push(child);
}
}
return children;
},
_updateChildNodes: function (container, children) {
var composed = TreeApi.Composed.getChildNodes(container);
var splices = Polymer.ArraySplice.calculateSplices(children, composed);
for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
if (TreeApi.Composed.getParentNode(n) === container) {
TreeApi.Composed.removeChild(container, n);
}
composed.splice(s.index + d, 1);
}
d -= s.addedCount;
}
for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
next = composed[s.index];
for (j = s.index, n; j < s.index + s.addedCount; j++) {
n = children[j];
TreeApi.Composed.insertBefore(container, n, next);
composed.splice(j, 0, n);
}
}
},
_matchesContentSelect: function (node, contentElement) {
var select = contentElement.getAttribute('select');
if (!select) {
return true;
}
select = select.trim();
if (!select) {
return true;
}
if (!(node instanceof Element)) {
return false;
}
var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
if (!validSelectors.test(select)) {
return false;
}
return this.elementMatches(select, node);
},
_elementAdd: function () {
},
_elementRemove: function () {
}
});
var domHostDesc = {
get: function () {
var root = Polymer.dom(this).getOwnerRoot();
return root && root.host;
},
configurable: true
};
Object.defineProperty(Polymer.Base, 'domHost', domHostDesc);
Polymer.BaseDescriptors.domHost = domHostDesc;
function distributeNodeInto(child, insertionPoint) {
insertionPoint._distributedNodes.push(child);
var points = child._destinationInsertionPoints;
if (!points) {
child._destinationInsertionPoints = [insertionPoint];
} else {
points.push(insertionPoint);
}
}
function clearDistributedDestinationInsertionPoints(content) {
var e$ = content._distributedNodes;
if (e$) {
for (var i = 0; i < e$.length; i++) {
var d = e$[i]._destinationInsertionPoints;
if (d) {
d.splice(d.indexOf(content) + 1, d.length);
}
}
}
}
function maybeRedistributeParent(content, host) {
var parent = TreeApi.Logical.getParentNode(content);
if (parent && parent.shadyRoot && DomApi.hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
parent.shadyRoot._distributionClean = false;
host.shadyRoot._dirtyRoots.push(parent);
}
}
function isFinalDestination(insertionPoint, node) {
var points = node._destinationInsertionPoints;
return points && points[points.length - 1] === insertionPoint;
}
function isInsertionPoint(node) {
return node.localName == 'content';
}
function getTopDistributingHost(host) {
while (host && hostNeedsRedistribution(host)) {
host = host.domHost;
}
return host;
}
function hostNeedsRedistribution(host) {
var c$ = TreeApi.Logical.getChildNodes(host);
for (var i = 0, c; i < c$.length; i++) {
c = c$[i];
if (c.localName && c.localName === 'content') {
return host.domHost;
}
}
}
function notifyContentObservers(root) {
for (var i = 0, c; i < root._insertionPoints.length; i++) {
c = root._insertionPoints[i];
if (DomApi.hasApi(c)) {
Polymer.dom(c).notifyObserver();
}
}
}
function notifyInitialDistribution(host) {
if (DomApi.hasApi(host)) {
Polymer.dom(host).notifyObserver();
}
}
var needsUpgrade = window.CustomElements && !CustomElements.useNative;
function upgradeLogicalChildren(children) {
if (needsUpgrade && children) {
for (var i = 0; i < children.length; i++) {
CustomElements.upgrade(children[i]);
}
}
}
}());if (Polymer.Settings.useShadow) {
Polymer.Base._addFeature({
_poolContent: function () {
},
_beginDistribute: function () {
},
distributeContent: function () {
},
_distributeContent: function () {
},
_finishDistribute: function () {
},
_createLocalRoot: function () {
this.createShadowRoot();
this.shadowRoot.appendChild(this.root);
this.root = this.shadowRoot;
}
});
}Polymer.Async = {
_currVal: 0,
_lastVal: 0,
_callbacks: [],
_twiddleContent: 0,
_twiddle: document.createTextNode(''),
run: function (callback, waitTime) {
if (waitTime > 0) {
return ~setTimeout(callback, waitTime);
} else {
this._twiddle.textContent = this._twiddleContent++;
this._callbacks.push(callback);
return this._currVal++;
}
},
cancel: function (handle) {
if (handle < 0) {
clearTimeout(~handle);
} else {
var idx = handle - this._lastVal;
if (idx >= 0) {
if (!this._callbacks[idx]) {
throw 'invalid async handle: ' + handle;
}
this._callbacks[idx] = null;
}
}
},
_atEndOfMicrotask: function () {
var len = this._callbacks.length;
for (var i = 0; i < len; i++) {
var cb = this._callbacks[i];
if (cb) {
try {
cb();
} catch (e) {
i++;
this._callbacks.splice(0, i);
this._lastVal += i;
this._twiddle.textContent = this._twiddleContent++;
throw e;
}
}
}
this._callbacks.splice(0, len);
this._lastVal += len;
}
};
new window.MutationObserver(function () {
Polymer.Async._atEndOfMicrotask();
}).observe(Polymer.Async._twiddle, { characterData: true });Polymer.Debounce = function () {
var Async = Polymer.Async;
var Debouncer = function (context) {
this.context = context;
var self = this;
this.boundComplete = function () {
self.complete();
};
};
Debouncer.prototype = {
go: function (callback, wait) {
var h;
this.finish = function () {
Async.cancel(h);
};
h = Async.run(this.boundComplete, wait);
this.callback = callback;
},
stop: function () {
if (this.finish) {
this.finish();
this.finish = null;
this.callback = null;
}
},
complete: function () {
if (this.finish) {
var callback = this.callback;
this.stop();
callback.call(this.context);
}
}
};
function debounce(debouncer, callback, wait) {
if (debouncer) {
debouncer.stop();
} else {
debouncer = new Debouncer(this);
}
debouncer.go(callback, wait);
return debouncer;
}
return debounce;
}();Polymer.Base._addFeature({
_setupDebouncers: function () {
this._debouncers = {};
},
debounce: function (jobName, callback, wait) {
return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
},
isDebouncerActive: function (jobName) {
var debouncer = this._debouncers[jobName];
return !!(debouncer && debouncer.finish);
},
flushDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.complete();
}
},
cancelDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.stop();
}
}
});Polymer.DomModule = document.createElement('dom-module');
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepBehaviors();
this._prepConstructor();
this._prepTemplate();
this._prepShady();
this._prepPropertyInfo();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._registerHost();
if (this._template) {
this._poolContent();
this._beginHosting();
this._stampTemplate();
this._endHosting();
}
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
this._tryReady();
},
_marshalBehavior: function (b) {
}
});</script>






<script>(function () {
Polymer.nar = [];
var disableUpgradeEnabled = Polymer.Settings.disableUpgradeEnabled;
Polymer.Annotations = {
parseAnnotations: function (template, stripWhiteSpace) {
var list = [];
var content = template._content || template.content;
this._parseNodeAnnotations(content, list, stripWhiteSpace || template.hasAttribute('strip-whitespace'));
return list;
},
_parseNodeAnnotations: function (node, list, stripWhiteSpace) {
return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list, stripWhiteSpace);
},
_bindingRegex: function () {
var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
var ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' + STRING + '\\s*' + ')';
var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')';
var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
var CLOSE_BRACKET = '(?:]]|}})';
var NEGATE = '(?:(!)\\s*)?';
var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
return new RegExp(EXPRESSION, 'g');
}(),
_parseBindings: function (text) {
var re = this._bindingRegex;
var parts = [];
var lastIndex = 0;
var m;
while ((m = re.exec(text)) !== null) {
if (m.index > lastIndex) {
parts.push({ literal: text.slice(lastIndex, m.index) });
}
var mode = m[1][0];
var negate = Boolean(m[2]);
var value = m[3].trim();
var customEvent, notifyEvent, colon;
if (mode == '{' && (colon = value.indexOf('::')) > 0) {
notifyEvent = value.substring(colon + 2);
value = value.substring(0, colon);
customEvent = true;
}
parts.push({
compoundIndex: parts.length,
value: value,
mode: mode,
negate: negate,
event: notifyEvent,
customEvent: customEvent
});
lastIndex = re.lastIndex;
}
if (lastIndex && lastIndex < text.length) {
var literal = text.substring(lastIndex);
if (literal) {
parts.push({ literal: literal });
}
}
if (parts.length) {
return parts;
}
},
_literalFromParts: function (parts) {
var s = '';
for (var i = 0; i < parts.length; i++) {
var literal = parts[i].literal;
s += literal || '';
}
return s;
},
_parseTextNodeAnnotation: function (node, list) {
var parts = this._parseBindings(node.textContent);
if (parts) {
node.textContent = this._literalFromParts(parts) || ' ';
var annote = {
bindings: [{
kind: 'text',
name: 'textContent',
parts: parts,
isCompound: parts.length !== 1
}]
};
list.push(annote);
return annote;
}
},
_parseElementAnnotations: function (element, list, stripWhiteSpace) {
var annote = {
bindings: [],
events: []
};
if (element.localName === 'content') {
list._hasContent = true;
}
this._parseChildNodesAnnotations(element, annote, list, stripWhiteSpace);
if (element.attributes) {
this._parseNodeAttributeAnnotations(element, annote, list);
if (this.prepElement) {
this.prepElement(element);
}
}
if (annote.bindings.length || annote.events.length || annote.id) {
list.push(annote);
}
return annote;
},
_parseChildNodesAnnotations: function (root, annote, list, stripWhiteSpace) {
if (root.firstChild) {
var node = root.firstChild;
var i = 0;
while (node) {
var next = node.nextSibling;
if (node.localName === 'template' && !node.hasAttribute('preserve-content')) {
this._parseTemplate(node, i, list, annote, stripWhiteSpace);
}
if (node.localName == 'slot') {
node = this._replaceSlotWithContent(node);
}
if (node.nodeType === Node.TEXT_NODE) {
var n = next;
while (n && n.nodeType === Node.TEXT_NODE) {
node.textContent += n.textContent;
next = n.nextSibling;
root.removeChild(n);
n = next;
}
if (stripWhiteSpace && !node.textContent.trim()) {
root.removeChild(node);
i--;
}
}
if (node.parentNode) {
var childAnnotation = this._parseNodeAnnotations(node, list, stripWhiteSpace);
if (childAnnotation) {
childAnnotation.parent = annote;
childAnnotation.index = i;
}
}
node = next;
i++;
}
}
},
_replaceSlotWithContent: function (slot) {
var content = slot.ownerDocument.createElement('content');
while (slot.firstChild) {
content.appendChild(slot.firstChild);
}
var attrs = slot.attributes;
for (var i = 0; i < attrs.length; i++) {
var attr = attrs[i];
content.setAttribute(attr.name, attr.value);
}
var name = slot.getAttribute('name');
if (name) {
content.setAttribute('select', '[slot=\'' + name + '\']');
}
slot.parentNode.replaceChild(content, slot);
return content;
},
_parseTemplate: function (node, index, list, parent, stripWhiteSpace) {
var content = document.createDocumentFragment();
content._notes = this.parseAnnotations(node, stripWhiteSpace);
content.appendChild(node.content);
list.push({
bindings: Polymer.nar,
events: Polymer.nar,
templateContent: content,
parent: parent,
index: index
});
},
_parseNodeAttributeAnnotations: function (node, annotation) {
var attrs = Array.prototype.slice.call(node.attributes);
for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
var n = a.name;
var v = a.value;
var b;
if (n.slice(0, 3) === 'on-') {
node.removeAttribute(n);
annotation.events.push({
name: n.slice(3),
value: v
});
} else if (b = this._parseNodeAttributeAnnotation(node, n, v)) {
annotation.bindings.push(b);
} else if (n === 'id') {
annotation.id = v;
}
}
},
_parseNodeAttributeAnnotation: function (node, name, value) {
var parts = this._parseBindings(value);
if (parts) {
var origName = name;
var kind = 'property';
if (name[name.length - 1] == '$') {
name = name.slice(0, -1);
kind = 'attribute';
}
var literal = this._literalFromParts(parts);
if (literal && kind == 'attribute') {
node.setAttribute(name, literal);
}
if (node.localName === 'input' && origName === 'value') {
node.setAttribute(origName, '');
}
if (disableUpgradeEnabled && origName === 'disable-upgrade$') {
node.setAttribute(name, '');
}
node.removeAttribute(origName);
var propertyName = Polymer.CaseMap.dashToCamelCase(name);
if (kind === 'property') {
name = propertyName;
}
return {
kind: kind,
name: name,
propertyName: propertyName,
parts: parts,
literal: literal,
isCompound: parts.length !== 1
};
}
},
findAnnotatedNode: function (root, annote) {
var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
if (parent) {
for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
if (annote.index === i++) {
return n;
}
}
} else {
return root;
}
}
};
}());Polymer.Path = {
root: function (path) {
var dotIndex = path.indexOf('.');
if (dotIndex === -1) {
return path;
}
return path.slice(0, dotIndex);
},
isDeep: function (path) {
return path.indexOf('.') !== -1;
},
isAncestor: function (base, path) {
return base.indexOf(path + '.') === 0;
},
isDescendant: function (base, path) {
return path.indexOf(base + '.') === 0;
},
translate: function (base, newBase, path) {
return newBase + path.slice(base.length);
},
matches: function (base, wildcard, path) {
return base === path || this.isAncestor(base, path) || Boolean(wildcard) && this.isDescendant(base, path);
}
};Polymer.Base._addFeature({
_prepAnnotations: function () {
if (!this._template) {
this._notes = [];
} else {
var self = this;
Polymer.Annotations.prepElement = function (element) {
self._prepElement(element);
};
if (this._template._content && this._template._content._notes) {
this._notes = this._template._content._notes;
} else {
this._notes = Polymer.Annotations.parseAnnotations(this._template);
this._processAnnotations(this._notes);
}
Polymer.Annotations.prepElement = null;
}
},
_processAnnotations: function (notes) {
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
for (var j = 0; j < note.bindings.length; j++) {
var b = note.bindings[j];
for (var k = 0; k < b.parts.length; k++) {
var p = b.parts[k];
if (!p.literal) {
var signature = this._parseMethod(p.value);
if (signature) {
p.signature = signature;
} else {
p.model = Polymer.Path.root(p.value);
}
}
}
}
if (note.templateContent) {
this._processAnnotations(note.templateContent._notes);
var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
var bindings = [];
for (var prop in pp) {
var name = '_parent_' + prop;
bindings.push({
index: note.index,
kind: 'property',
name: name,
propertyName: name,
parts: [{
mode: '{',
model: prop,
value: prop
}]
});
}
note.bindings = note.bindings.concat(bindings);
}
}
},
_discoverTemplateParentProps: function (notes) {
var pp = {};
for (var i = 0, n; i < notes.length && (n = notes[i]); i++) {
for (var j = 0, b$ = n.bindings, b; j < b$.length && (b = b$[j]); j++) {
for (var k = 0, p$ = b.parts, p; k < p$.length && (p = p$[k]); k++) {
if (p.signature) {
var args = p.signature.args;
for (var kk = 0; kk < args.length; kk++) {
var model = args[kk].model;
if (model) {
pp[model] = true;
}
}
if (p.signature.dynamicFn) {
pp[p.signature.method] = true;
}
} else {
if (p.model) {
pp[p.model] = true;
}
}
}
}
if (n.templateContent) {
var tpp = n.templateContent._parentProps;
Polymer.Base.mixin(pp, tpp);
}
}
return pp;
},
_prepElement: function (element) {
Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
},
_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
_marshalAnnotationReferences: function () {
if (this._template) {
this._marshalIdNodes();
this._marshalAnnotatedNodes();
this._marshalAnnotatedListeners();
}
},
_configureAnnotationReferences: function () {
var notes = this._notes;
var nodes = this._nodes;
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
var node = nodes[i];
this._configureTemplateContent(note, node);
this._configureCompoundBindings(note, node);
}
},
_configureTemplateContent: function (note, node) {
if (note.templateContent) {
node._content = note.templateContent;
}
},
_configureCompoundBindings: function (note, node) {
var bindings = note.bindings;
for (var i = 0; i < bindings.length; i++) {
var binding = bindings[i];
if (binding.isCompound) {
var storage = node.__compoundStorage__ || (node.__compoundStorage__ = {});
var parts = binding.parts;
var literals = new Array(parts.length);
for (var j = 0; j < parts.length; j++) {
literals[j] = parts[j].literal;
}
var name = binding.name;
storage[name] = literals;
if (binding.literal && binding.kind == 'property') {
if (node._configValue) {
node._configValue(name, binding.literal);
} else {
node[name] = binding.literal;
}
}
}
}
},
_marshalIdNodes: function () {
this.$ = {};
for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
if (a.id) {
this.$[a.id] = this._findAnnotatedNode(this.root, a);
}
}
},
_marshalAnnotatedNodes: function () {
if (this._notes && this._notes.length) {
var r = new Array(this._notes.length);
for (var i = 0; i < this._notes.length; i++) {
r[i] = this._findAnnotatedNode(this.root, this._notes[i]);
}
this._nodes = r;
}
},
_marshalAnnotatedListeners: function () {
for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
if (a.events && a.events.length) {
var node = this._findAnnotatedNode(this.root, a);
for (var j = 0, e$ = a.events, e; j < e$.length && (e = e$[j]); j++) {
this.listen(node, e.name, e.value);
}
}
}
}
});Polymer.Base._addFeature({
listeners: {},
_listenListeners: function (listeners) {
var node, name, eventName;
for (eventName in listeners) {
if (eventName.indexOf('.') < 0) {
node = this;
name = eventName;
} else {
name = eventName.split('.');
node = this.$[name[0]];
name = name[1];
}
this.listen(node, name, listeners[eventName]);
}
},
listen: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (!handler) {
handler = this._createEventHandler(node, eventName, methodName);
}
if (handler._listening) {
return;
}
this._listen(node, eventName, handler);
handler._listening = true;
},
_boundListenerKey: function (eventName, methodName) {
return eventName + ':' + methodName;
},
_recordEventHandler: function (host, eventName, target, methodName, handler) {
var hbl = host.__boundListeners;
if (!hbl) {
hbl = host.__boundListeners = new WeakMap();
}
var bl = hbl.get(target);
if (!bl) {
bl = {};
if (!Polymer.Settings.isIE || target != window) {
hbl.set(target, bl);
}
}
var key = this._boundListenerKey(eventName, methodName);
bl[key] = handler;
},
_recallEventHandler: function (host, eventName, target, methodName) {
var hbl = host.__boundListeners;
if (!hbl) {
return;
}
var bl = hbl.get(target);
if (!bl) {
return;
}
var key = this._boundListenerKey(eventName, methodName);
return bl[key];
},
_createEventHandler: function (node, eventName, methodName) {
var host = this;
var handler = function (e) {
if (host[methodName]) {
host[methodName](e, e.detail);
} else {
host._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));
}
};
handler._listening = false;
this._recordEventHandler(host, eventName, node, methodName, handler);
return handler;
},
unlisten: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (handler) {
this._unlisten(node, eventName, handler);
handler._listening = false;
}
},
_listen: function (node, eventName, handler) {
node.addEventListener(eventName, handler);
},
_unlisten: function (node, eventName, handler) {
node.removeEventListener(eventName, handler);
}
});(function () {
'use strict';
var wrap = Polymer.DomApi.wrap;
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
var TRACK_LENGTH = 2;
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = [
'mousedown',
'mousemove',
'mouseup',
'click'
];
var MOUSE_WHICH_TO_BUTTONS = [
0,
1,
4,
2
];
var MOUSE_HAS_BUTTONS = function () {
try {
return new MouseEvent('test', { buttons: 1 }).buttons === 1;
} catch (e) {
return false;
}
}();
function isMouseEvent(name) {
return MOUSE_EVENTS.indexOf(name) > -1;
}
var SUPPORTS_PASSIVE = false;
(function () {
try {
var opts = Object.defineProperty({}, 'passive', {
get: function () {
SUPPORTS_PASSIVE = true;
}
});
window.addEventListener('test', null, opts);
window.removeEventListener('test', null, opts);
} catch (e) {
}
}());
function PASSIVE_TOUCH(eventName) {
if (isMouseEvent(eventName) || eventName === 'touchend') {
return;
}
if (HAS_NATIVE_TA && SUPPORTS_PASSIVE && Polymer.Settings.passiveTouchGestures) {
return { passive: true };
}
}
var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
var mouseCanceller = function (mouseEvent) {
var sc = mouseEvent.sourceCapabilities;
if (sc && !sc.firesTouchEvents) {
return;
}
mouseEvent[HANDLED_OBJ] = { skip: true };
if (mouseEvent.type === 'click') {
var path = Polymer.dom(mouseEvent).path;
if (path) {
for (var i = 0; i < path.length; i++) {
if (path[i] === POINTERSTATE.mouse.target) {
return;
}
}
}
mouseEvent.preventDefault();
mouseEvent.stopPropagation();
}
};
function setupTeardownMouseCanceller(setup) {
var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
for (var i = 0, en; i < events.length; i++) {
en = events[i];
if (setup) {
document.addEventListener(en, mouseCanceller, true);
} else {
document.removeEventListener(en, mouseCanceller, true);
}
}
}
function ignoreMouse(ev) {
if (!POINTERSTATE.mouse.mouseIgnoreJob) {
setupTeardownMouseCanceller(true);
}
var unset = function () {
setupTeardownMouseCanceller();
POINTERSTATE.mouse.target = null;
POINTERSTATE.mouse.mouseIgnoreJob = null;
};
POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);
}
function hasLeftMouseButton(ev) {
var type = ev.type;
if (!isMouseEvent(type)) {
return false;
}
if (type === 'mousemove') {
var buttons = ev.buttons === undefined ? 1 : ev.buttons;
if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
}
return Boolean(buttons & 1);
} else {
var button = ev.button === undefined ? 0 : ev.button;
return button === 0;
}
}
function isSyntheticClick(ev) {
if (ev.type === 'click') {
if (ev.detail === 0) {
return true;
}
var t = Gestures.findOriginalTarget(ev);
var bcr = t.getBoundingClientRect();
var x = ev.pageX, y = ev.pageY;
return !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom));
}
return false;
}
var POINTERSTATE = {
mouse: {
target: null,
mouseIgnoreJob: null
},
touch: {
x: 0,
y: 0,
id: -1,
scrollDecided: false
}
};
function firstTouchAction(ev) {
var path = Polymer.dom(ev).path;
var ta = 'auto';
for (var i = 0, n; i < path.length; i++) {
n = path[i];
if (n[TOUCH_ACTION]) {
ta = n[TOUCH_ACTION];
break;
}
}
return ta;
}
function trackDocument(stateObj, movefn, upfn) {
stateObj.movefn = movefn;
stateObj.upfn = upfn;
document.addEventListener('mousemove', movefn);
document.addEventListener('mouseup', upfn);
}
function untrackDocument(stateObj) {
document.removeEventListener('mousemove', stateObj.movefn);
document.removeEventListener('mouseup', stateObj.upfn);
stateObj.movefn = null;
stateObj.upfn = null;
}
document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);
var Gestures = {
gestures: {},
recognizers: [],
deepTargetFind: function (x, y) {
var node = document.elementFromPoint(x, y);
var next = node;
while (next && next.shadowRoot) {
next = next.shadowRoot.elementFromPoint(x, y);
if (next) {
node = next;
}
}
return node;
},
findOriginalTarget: function (ev) {
if (ev.path) {
return ev.path[0];
}
return ev.target;
},
handleNative: function (ev) {
var handled;
var type = ev.type;
var node = wrap(ev.currentTarget);
var gobj = node[GESTURE_KEY];
if (!gobj) {
return;
}
var gs = gobj[type];
if (!gs) {
return;
}
if (!ev[HANDLED_OBJ]) {
ev[HANDLED_OBJ] = {};
if (type.slice(0, 5) === 'touch') {
var t = ev.changedTouches[0];
if (type === 'touchstart') {
if (ev.touches.length === 1) {
POINTERSTATE.touch.id = t.identifier;
}
}
if (POINTERSTATE.touch.id !== t.identifier) {
return;
}
if (!HAS_NATIVE_TA) {
if (type === 'touchstart' || type === 'touchmove') {
Gestures.handleTouchAction(ev);
}
}
}
}
handled = ev[HANDLED_OBJ];
if (handled.skip) {
return;
}
var recognizers = Gestures.recognizers;
for (var i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
r.reset();
}
}
}
for (i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
handled[r.name] = true;
r[type](ev);
}
}
},
handleTouchAction: function (ev) {
var t = ev.changedTouches[0];
var type = ev.type;
if (type === 'touchstart') {
POINTERSTATE.touch.x = t.clientX;
POINTERSTATE.touch.y = t.clientY;
POINTERSTATE.touch.scrollDecided = false;
} else if (type === 'touchmove') {
if (POINTERSTATE.touch.scrollDecided) {
return;
}
POINTERSTATE.touch.scrollDecided = true;
var ta = firstTouchAction(ev);
var prevent = false;
var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
if (!ev.cancelable) {
} else if (ta === 'none') {
prevent = true;
} else if (ta === 'pan-x') {
prevent = dy > dx;
} else if (ta === 'pan-y') {
prevent = dx > dy;
}
if (prevent) {
ev.preventDefault();
} else {
Gestures.prevent('track');
}
}
},
add: function (node, evType, handler) {
node = wrap(node);
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (!gobj) {
node[GESTURE_KEY] = gobj = {};
}
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {
continue;
}
gd = gobj[dep];
if (!gd) {
gobj[dep] = gd = { _count: 0 };
}
if (gd._count === 0) {
node.addEventListener(dep, this.handleNative, PASSIVE_TOUCH(dep));
}
gd[name] = (gd[name] || 0) + 1;
gd._count = (gd._count || 0) + 1;
}
node.addEventListener(evType, handler);
if (recognizer.touchAction) {
this.setTouchAction(node, recognizer.touchAction);
}
},
remove: function (node, evType, handler) {
node = wrap(node);
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (gobj) {
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
gd = gobj[dep];
if (gd && gd[name]) {
gd[name] = (gd[name] || 1) - 1;
gd._count = (gd._count || 1) - 1;
if (gd._count === 0) {
node.removeEventListener(dep, this.handleNative, PASSIVE_TOUCH(dep));
}
}
}
}
node.removeEventListener(evType, handler);
},
register: function (recog) {
this.recognizers.push(recog);
for (var i = 0; i < recog.emits.length; i++) {
this.gestures[recog.emits[i]] = recog;
}
},
findRecognizerByEvent: function (evName) {
for (var i = 0, r; i < this.recognizers.length; i++) {
r = this.recognizers[i];
for (var j = 0, n; j < r.emits.length; j++) {
n = r.emits[j];
if (n === evName) {
return r;
}
}
}
return null;
},
setTouchAction: function (node, value) {
if (HAS_NATIVE_TA) {
node.style.touchAction = value;
}
node[TOUCH_ACTION] = value;
},
fire: function (target, type, detail) {
var ev = Polymer.Base.fire(type, detail, {
node: target,
bubbles: true,
cancelable: true
});
if (ev.defaultPrevented) {
var preventer = detail.preventer || detail.sourceEvent;
if (preventer && preventer.preventDefault) {
preventer.preventDefault();
}
}
},
prevent: function (evName) {
var recognizer = this.findRecognizerByEvent(evName);
if (recognizer.info) {
recognizer.info.prevent = true;
}
},
resetMouseCanceller: function () {
if (POINTERSTATE.mouse.mouseIgnoreJob) {
POINTERSTATE.mouse.mouseIgnoreJob.complete();
}
}
};
Gestures.register({
name: 'downup',
deps: [
'mousedown',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: [
'down',
'up'
],
info: {
movefn: null,
upfn: null
},
reset: function () {
untrackDocument(this.info);
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
if (!hasLeftMouseButton(e)) {
self.fire('up', t, e);
untrackDocument(self.info);
}
};
var upfn = function upfn(e) {
if (hasLeftMouseButton(e)) {
self.fire('up', t, e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.fire('down', t, e);
},
touchstart: function (e) {
this.fire('down', Gestures.findOriginalTarget(e), e.changedTouches[0], e);
},
touchend: function (e) {
this.fire('up', Gestures.findOriginalTarget(e), e.changedTouches[0], e);
},
fire: function (type, target, event, preventer) {
Gestures.fire(target, type, {
x: event.clientX,
y: event.clientY,
sourceEvent: event,
preventer: preventer,
prevent: function (e) {
return Gestures.prevent(e);
}
});
}
});
Gestures.register({
name: 'track',
touchAction: 'none',
deps: [
'mousedown',
'touchstart',
'touchmove',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: ['track'],
info: {
x: 0,
y: 0,
state: 'start',
started: false,
moves: [],
addMove: function (move) {
if (this.moves.length > TRACK_LENGTH) {
this.moves.shift();
}
this.moves.push(move);
},
movefn: null,
upfn: null,
prevent: false
},
reset: function () {
this.info.state = 'start';
this.info.started = false;
this.info.moves = [];
this.info.x = 0;
this.info.y = 0;
this.info.prevent = false;
untrackDocument(this.info);
},
hasMovedEnough: function (x, y) {
if (this.info.prevent) {
return false;
}
if (this.info.started) {
return true;
}
var dx = Math.abs(this.info.x - x);
var dy = Math.abs(this.info.y - y);
return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
var x = e.clientX, y = e.clientY;
if (self.hasMovedEnough(x, y)) {
self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
if (self.info.state === 'start') {
Gestures.prevent('tap');
}
self.info.addMove({
x: x,
y: y
});
if (!hasLeftMouseButton(e)) {
self.info.state = 'end';
untrackDocument(self.info);
}
self.fire(t, e);
self.info.started = true;
}
};
var upfn = function upfn(e) {
if (self.info.started) {
movefn(e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.info.x = e.clientX;
this.info.y = e.clientY;
},
touchstart: function (e) {
var ct = e.changedTouches[0];
this.info.x = ct.clientX;
this.info.y = ct.clientY;
},
touchmove: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
var x = ct.clientX, y = ct.clientY;
if (this.hasMovedEnough(x, y)) {
if (this.info.state === 'start') {
Gestures.prevent('tap');
}
this.info.addMove({
x: x,
y: y
});
this.fire(t, ct);
this.info.state = 'track';
this.info.started = true;
}
},
touchend: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
if (this.info.started) {
this.info.state = 'end';
this.info.addMove({
x: ct.clientX,
y: ct.clientY
});
this.fire(t, ct, e);
}
},
fire: function (target, touch, preventer) {
var secondlast = this.info.moves[this.info.moves.length - 2];
var lastmove = this.info.moves[this.info.moves.length - 1];
var dx = lastmove.x - this.info.x;
var dy = lastmove.y - this.info.y;
var ddx, ddy = 0;
if (secondlast) {
ddx = lastmove.x - secondlast.x;
ddy = lastmove.y - secondlast.y;
}
return Gestures.fire(target, 'track', {
state: this.info.state,
x: touch.clientX,
y: touch.clientY,
dx: dx,
dy: dy,
ddx: ddx,
ddy: ddy,
sourceEvent: touch,
preventer: preventer,
hover: function () {
return Gestures.deepTargetFind(touch.clientX, touch.clientY);
}
});
}
});
Gestures.register({
name: 'tap',
deps: [
'mousedown',
'click',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'click',
'touchend'
]
},
emits: ['tap'],
info: {
x: NaN,
y: NaN,
prevent: false
},
reset: function () {
this.info.x = NaN;
this.info.y = NaN;
this.info.prevent = false;
},
save: function (e) {
this.info.x = e.clientX;
this.info.y = e.clientY;
},
mousedown: function (e) {
if (hasLeftMouseButton(e)) {
this.save(e);
}
},
click: function (e) {
if (hasLeftMouseButton(e)) {
this.forward(e);
}
},
touchstart: function (e) {
this.save(e.changedTouches[0], e);
},
touchend: function (e) {
this.forward(e.changedTouches[0], e);
},
forward: function (e, preventer) {
var dx = Math.abs(e.clientX - this.info.x);
var dy = Math.abs(e.clientY - this.info.y);
var t = Gestures.findOriginalTarget(e);
if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
if (!this.info.prevent) {
Gestures.fire(t, 'tap', {
x: e.clientX,
y: e.clientY,
sourceEvent: e,
preventer: preventer
});
}
}
}
});
var DIRECTION_MAP = {
x: 'pan-x',
y: 'pan-y',
none: 'none',
all: 'auto'
};
Polymer.Base._addFeature({
_setupGestures: function () {
this.__polymerGestures = null;
},
_listen: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.add(node, eventName, handler);
} else {
node.addEventListener(eventName, handler);
}
},
_unlisten: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.remove(node, eventName, handler);
} else {
node.removeEventListener(eventName, handler);
}
},
setScrollDirection: function (direction, node) {
node = node || this;
Gestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');
}
});
Polymer.Gestures = Gestures;
}());(function () {
'use strict';
Polymer.Base._addFeature({
$$: function (slctr) {
return Polymer.dom(this.root).querySelector(slctr);
},
toggleClass: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.classList.contains(name);
}
if (bool) {
Polymer.dom(node).classList.add(name);
} else {
Polymer.dom(node).classList.remove(name);
}
},
toggleAttribute: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.hasAttribute(name);
}
if (bool) {
Polymer.dom(node).setAttribute(name, '');
} else {
Polymer.dom(node).removeAttribute(name);
}
},
classFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).classList.remove(name);
}
if (toElement) {
Polymer.dom(toElement).classList.add(name);
}
},
attributeFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).removeAttribute(name);
}
if (toElement) {
Polymer.dom(toElement).setAttribute(name, '');
}
},
getEffectiveChildNodes: function () {
return Polymer.dom(this).getEffectiveChildNodes();
},
getEffectiveChildren: function () {
var list = Polymer.dom(this).getEffectiveChildNodes();
return list.filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
getEffectiveTextContent: function () {
var cn = this.getEffectiveChildNodes();
var tc = [];
for (var i = 0, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(Polymer.dom(c).textContent);
}
}
return tc.join('');
},
queryEffectiveChildren: function (slctr) {
var e$ = Polymer.dom(this).queryDistributedElements(slctr);
return e$ && e$[0];
},
queryAllEffectiveChildren: function (slctr) {
return Polymer.dom(this).queryDistributedElements(slctr);
},
getContentChildNodes: function (slctr) {
var content = Polymer.dom(this.root).querySelector(slctr || 'content');
return content ? Polymer.dom(content).getDistributedNodes() : [];
},
getContentChildren: function (slctr) {
return this.getContentChildNodes(slctr).filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
fire: function (type, detail, options) {
options = options || Polymer.nob;
var node = options.node || this;
detail = detail === null || detail === undefined ? {} : detail;
var bubbles = options.bubbles === undefined ? true : options.bubbles;
var cancelable = Boolean(options.cancelable);
var useCache = options._useCache;
var event = this._getEvent(type, bubbles, cancelable, useCache);
event.detail = detail;
if (useCache) {
this.__eventCache[type] = null;
}
node.dispatchEvent(event);
if (useCache) {
this.__eventCache[type] = event;
}
return event;
},
__eventCache: {},
_getEvent: function (type, bubbles, cancelable, useCache) {
var event = useCache && this.__eventCache[type];
if (!event || (event.bubbles != bubbles || event.cancelable != cancelable)) {
event = new Event(type, {
bubbles: Boolean(bubbles),
cancelable: cancelable
});
}
return event;
},
async: function (callback, waitTime) {
var self = this;
return Polymer.Async.run(function () {
callback.call(self);
}, waitTime);
},
cancelAsync: function (handle) {
Polymer.Async.cancel(handle);
},
arrayDelete: function (path, item) {
var index;
if (Array.isArray(path)) {
index = path.indexOf(item);
if (index >= 0) {
return path.splice(index, 1);
}
} else {
var arr = this._get(path);
index = arr.indexOf(item);
if (index >= 0) {
return this.splice(path, index, 1);
}
}
},
transform: function (transform, node) {
node = node || this;
node.style.webkitTransform = transform;
node.style.transform = transform;
},
translate3d: function (x, y, z, node) {
node = node || this;
this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
},
importHref: function (href, onload, onerror, optAsync) {
var link = document.createElement('link');
link.rel = 'import';
link.href = href;
var list = Polymer.Base.importHref.imported = Polymer.Base.importHref.imported || {};
var cached = list[link.href];
var imprt = cached || link;
var self = this;
var loadListener = function (e) {
e.target.__firedLoad = true;
e.target.removeEventListener('load', loadListener);
e.target.removeEventListener('error', errorListener);
return onload.call(self, e);
};
var errorListener = function (e) {
e.target.__firedError = true;
e.target.removeEventListener('load', loadListener);
e.target.removeEventListener('error', errorListener);
return onerror.call(self, e);
};
if (onload) {
imprt.addEventListener('load', loadListener);
}
if (onerror) {
imprt.addEventListener('error', errorListener);
}
if (cached) {
if (cached.__firedLoad) {
cached.dispatchEvent(new Event('load'));
}
if (cached.__firedError) {
cached.dispatchEvent(new Event('error'));
}
} else {
list[link.href] = link;
optAsync = Boolean(optAsync);
if (optAsync) {
link.setAttribute('async', '');
}
document.head.appendChild(link);
}
return imprt;
},
create: function (tag, props) {
var elt = document.createElement(tag);
if (props) {
for (var n in props) {
elt[n] = props[n];
}
}
return elt;
},
isLightDescendant: function (node) {
return this !== node && this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot();
},
isLocalDescendant: function (node) {
return this.root === Polymer.dom(node).getOwnerRoot();
}
});
if (!Polymer.Settings.useNativeCustomElements) {
var importHref = Polymer.Base.importHref;
Polymer.Base.importHref = function (href, onload, onerror, optAsync) {
CustomElements.ready = false;
var loadFn = function (e) {
CustomElements.upgradeDocumentTree(document);
CustomElements.ready = true;
if (onload) {
return onload.call(this, e);
}
};
return importHref.call(this, href, loadFn, onerror, optAsync);
};
}
}());Polymer.Bind = {
prepareModel: function (model) {
Polymer.Base.mixin(model, this._modelApi);
},
_modelApi: {
_notifyChange: function (source, event, value) {
value = value === undefined ? this[source] : value;
event = event || Polymer.CaseMap.camelToDashCase(source) + '-changed';
this.fire(event, { value: value }, {
bubbles: false,
cancelable: false,
_useCache: Polymer.Settings.eventDataCache || !Polymer.Settings.isIE
});
},
_propertySetter: function (property, value, effects, fromAbove) {
var old = this.__data__[property];
if (old !== value && (old === old || value === value)) {
this.__data__[property] = value;
if (typeof value == 'object') {
this._clearPath(property);
}
if (this._propertyChanged) {
this._propertyChanged(property, value, old);
}
if (effects) {
this._effectEffects(property, value, effects, old, fromAbove);
}
}
return old;
},
__setProperty: function (property, value, quiet, node) {
node = node || this;
var effects = node._propertyEffects && node._propertyEffects[property];
if (effects) {
node._propertySetter(property, value, effects, quiet);
} else if (node[property] !== value) {
node[property] = value;
}
},
_effectEffects: function (property, value, effects, old, fromAbove) {
for (var i = 0, l = effects.length, fx; i < l && (fx = effects[i]); i++) {
fx.fn.call(this, property, this[property], fx.effect, old, fromAbove);
}
},
_clearPath: function (path) {
for (var prop in this.__data__) {
if (Polymer.Path.isDescendant(path, prop)) {
this.__data__[prop] = undefined;
}
}
}
},
ensurePropertyEffects: function (model, property) {
if (!model._propertyEffects) {
model._propertyEffects = {};
}
var fx = model._propertyEffects[property];
if (!fx) {
fx = model._propertyEffects[property] = [];
}
return fx;
},
addPropertyEffect: function (model, property, kind, effect) {
var fx = this.ensurePropertyEffects(model, property);
var propEffect = {
kind: kind,
effect: effect,
fn: Polymer.Bind['_' + kind + 'Effect']
};
fx.push(propEffect);
return propEffect;
},
createBindings: function (model) {
var fx$ = model._propertyEffects;
if (fx$) {
for (var n in fx$) {
var fx = fx$[n];
fx.sort(this._sortPropertyEffects);
this._createAccessors(model, n, fx);
}
}
},
_sortPropertyEffects: function () {
var EFFECT_ORDER = {
'compute': 0,
'annotation': 1,
'annotatedComputation': 2,
'reflect': 3,
'notify': 4,
'observer': 5,
'complexObserver': 6,
'function': 7
};
return function (a, b) {
return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
};
}(),
_createAccessors: function (model, property, effects) {
var defun = {
get: function () {
return this.__data__[property];
}
};
var setter = function (value) {
this._propertySetter(property, value, effects);
};
var info = model.getPropertyInfo && model.getPropertyInfo(property);
if (info && info.readOnly) {
if (!info.computed) {
model['_set' + this.upper(property)] = setter;
}
} else {
defun.set = setter;
}
Object.defineProperty(model, property, defun);
},
upper: function (name) {
return name[0].toUpperCase() + name.substring(1);
},
_addAnnotatedListener: function (model, index, property, path, event, negated) {
if (!model._bindListeners) {
model._bindListeners = [];
}
var fn = this._notedListenerFactory(property, path, Polymer.Path.isDeep(path), negated);
var eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';
model._bindListeners.push({
index: index,
property: property,
path: path,
changedFn: fn,
event: eventName
});
},
_isEventBogus: function (e, target) {
return e.path && e.path[0] !== target;
},
_notedListenerFactory: function (property, path, isStructured, negated) {
return function (target, value, targetPath) {
if (targetPath) {
var newPath = Polymer.Path.translate(property, path, targetPath);
this._notifyPath(newPath, value);
} else {
value = target[property];
if (negated) {
value = !value;
}
if (!isStructured) {
this[path] = value;
} else {
if (this.__data__[path] != value) {
this.set(path, value);
}
}
}
};
},
prepareInstance: function (inst) {
inst.__data__ = Object.create(null);
},
setupBindListeners: function (inst) {
var b$ = inst._bindListeners;
for (var i = 0, l = b$.length, info; i < l && (info = b$[i]); i++) {
var node = inst._nodes[info.index];
this._addNotifyListener(node, inst, info.event, info.changedFn);
}
},
_addNotifyListener: function (element, context, event, changedFn) {
element.addEventListener(event, function (e) {
return context._notifyListener(changedFn, e);
});
}
};Polymer.Base.mixin(Polymer.Bind, {
_shouldAddListener: function (effect) {
return effect.name && effect.kind != 'attribute' && effect.kind != 'text' && !effect.isCompound && effect.parts[0].mode === '{';
},
_annotationEffect: function (source, value, effect) {
if (source != effect.value) {
value = this._get(effect.value);
this.__data__[effect.value] = value;
}
this._applyEffectValue(effect, value);
},
_reflectEffect: function (source, value, effect) {
this.reflectPropertyToAttribute(source, effect.attribute, value);
},
_notifyEffect: function (source, value, effect, old, fromAbove) {
if (!fromAbove) {
this._notifyChange(source, effect.event, value);
}
},
_functionEffect: function (source, value, fn, old, fromAbove) {
fn.call(this, source, value, old, fromAbove);
},
_observerEffect: function (source, value, effect, old) {
var fn = this[effect.method];
if (fn) {
fn.call(this, value, old);
} else {
this._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_complexObserverEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
fn.apply(this, args);
}
} else if (effect.dynamicFn) {
} else {
this._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_computeEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(this, args);
this.__setProperty(effect.name, computedvalue);
}
} else if (effect.dynamicFn) {
} else {
this._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_annotatedComputationEffect: function (source, value, effect) {
var computedHost = this._rootDataHost || this;
var fn = computedHost[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(computedHost, args);
this._applyEffectValue(effect, computedvalue);
}
} else if (effect.dynamicFn) {
} else {
computedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_marshalArgs: function (model, effect, path, value) {
var values = [];
var args = effect.args;
var bailoutEarly = args.length > 1 || effect.dynamicFn;
for (var i = 0, l = args.length; i < l; i++) {
var arg = args[i];
var name = arg.name;
var v;
if (arg.literal) {
v = arg.value;
} else if (path === name) {
v = value;
} else {
v = model[name];
if (v === undefined && arg.structured) {
v = Polymer.Base._get(name, model);
}
}
if (bailoutEarly && v === undefined) {
return;
}
if (arg.wildcard) {
var matches = Polymer.Path.isAncestor(path, name);
values[i] = {
path: matches ? path : name,
value: matches ? value : v,
base: v
};
} else {
values[i] = v;
}
}
return values;
}
});Polymer.Base._addFeature({
_addPropertyEffect: function (property, kind, effect) {
var prop = Polymer.Bind.addPropertyEffect(this, property, kind, effect);
prop.pathFn = this['_' + prop.kind + 'PathEffect'];
},
_prepEffects: function () {
Polymer.Bind.prepareModel(this);
this._addAnnotationEffects(this._notes);
},
_prepBindings: function () {
Polymer.Bind.createBindings(this);
},
_addPropertyEffects: function (properties) {
if (properties) {
for (var p in properties) {
var prop = properties[p];
if (prop.observer) {
this._addObserverEffect(p, prop.observer);
}
if (prop.computed) {
prop.readOnly = true;
this._addComputedEffect(p, prop.computed);
}
if (prop.notify) {
this._addPropertyEffect(p, 'notify', { event: Polymer.CaseMap.camelToDashCase(p) + '-changed' });
}
if (prop.reflectToAttribute) {
var attr = Polymer.CaseMap.camelToDashCase(p);
if (attr[0] === '-') {
this._warn(this._logf('_addPropertyEffects', 'Property ' + p + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.'));
} else {
this._addPropertyEffect(p, 'reflect', { attribute: attr });
}
}
if (prop.readOnly) {
Polymer.Bind.ensurePropertyEffects(this, p);
}
}
}
},
_addComputedEffect: function (name, expression) {
var sig = this._parseMethod(expression);
var dynamicFn = sig.dynamicFn;
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
this._addPropertyEffect(arg.model, 'compute', {
method: sig.method,
args: sig.args,
trigger: arg,
name: name,
dynamicFn: dynamicFn
});
}
if (dynamicFn) {
this._addPropertyEffect(sig.method, 'compute', {
method: sig.method,
args: sig.args,
trigger: null,
name: name,
dynamicFn: dynamicFn
});
}
},
_addObserverEffect: function (property, observer) {
this._addPropertyEffect(property, 'observer', {
method: observer,
property: property
});
},
_addComplexObserverEffects: function (observers) {
if (observers) {
for (var i = 0, o; i < observers.length && (o = observers[i]); i++) {
this._addComplexObserverEffect(o);
}
}
},
_addComplexObserverEffect: function (observer) {
var sig = this._parseMethod(observer);
if (!sig) {
throw new Error('Malformed observer expression \'' + observer + '\'');
}
var dynamicFn = sig.dynamicFn;
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
this._addPropertyEffect(arg.model, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: arg,
dynamicFn: dynamicFn
});
}
if (dynamicFn) {
this._addPropertyEffect(sig.method, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: null,
dynamicFn: dynamicFn
});
}
},
_addAnnotationEffects: function (notes) {
for (var i = 0, note; i < notes.length && (note = notes[i]); i++) {
var b$ = note.bindings;
for (var j = 0, binding; j < b$.length && (binding = b$[j]); j++) {
this._addAnnotationEffect(binding, i);
}
}
},
_addAnnotationEffect: function (note, index) {
if (Polymer.Bind._shouldAddListener(note)) {
Polymer.Bind._addAnnotatedListener(this, index, note.name, note.parts[0].value, note.parts[0].event, note.parts[0].negate);
}
for (var i = 0; i < note.parts.length; i++) {
var part = note.parts[i];
if (part.signature) {
this._addAnnotatedComputationEffect(note, part, index);
} else if (!part.literal) {
if (note.kind === 'attribute' && note.name[0] === '-') {
this._warn(this._logf('_addAnnotationEffect', 'Cannot set attribute ' + note.name + ' because "-" is not a valid attribute starting character'));
} else {
this._addPropertyEffect(part.model, 'annotation', {
kind: note.kind,
index: index,
name: note.name,
propertyName: note.propertyName,
value: part.value,
isCompound: note.isCompound,
compoundIndex: part.compoundIndex,
event: part.event,
customEvent: part.customEvent,
negate: part.negate
});
}
}
}
},
_addAnnotatedComputationEffect: function (note, part, index) {
var sig = part.signature;
if (sig.static) {
this.__addAnnotatedComputationEffect('__static__', index, note, part, null);
} else {
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
if (!arg.literal) {
this.__addAnnotatedComputationEffect(arg.model, index, note, part, arg);
}
}
if (sig.dynamicFn) {
this.__addAnnotatedComputationEffect(sig.method, index, note, part, null);
}
}
},
__addAnnotatedComputationEffect: function (property, index, note, part, trigger) {
this._addPropertyEffect(property, 'annotatedComputation', {
index: index,
isCompound: note.isCompound,
compoundIndex: part.compoundIndex,
kind: note.kind,
name: note.name,
negate: part.negate,
method: part.signature.method,
args: part.signature.args,
trigger: trigger,
dynamicFn: part.signature.dynamicFn
});
},
_parseMethod: function (expression) {
var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
if (m) {
var sig = {
method: m[1],
static: true
};
if (this.getPropertyInfo(sig.method) !== Polymer.nob) {
sig.static = false;
sig.dynamicFn = true;
}
if (m[2].trim()) {
var args = m[2].replace(/\\,/g, '&comma;').split(',');
return this._parseArgs(args, sig);
} else {
sig.args = Polymer.nar;
return sig;
}
}
},
_parseArgs: function (argList, sig) {
sig.args = argList.map(function (rawArg) {
var arg = this._parseArg(rawArg);
if (!arg.literal) {
sig.static = false;
}
return arg;
}, this);
return sig;
},
_parseArg: function (rawArg) {
var arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\(.)/g, '$1');
var a = { name: arg };
var fc = arg[0];
if (fc === '-') {
fc = arg[1];
}
if (fc >= '0' && fc <= '9') {
fc = '#';
}
switch (fc) {
case '\'':
case '"':
a.value = arg.slice(1, -1);
a.literal = true;
break;
case '#':
a.value = Number(arg);
a.literal = true;
break;
}
if (!a.literal) {
a.model = Polymer.Path.root(arg);
a.structured = Polymer.Path.isDeep(arg);
if (a.structured) {
a.wildcard = arg.slice(-2) == '.*';
if (a.wildcard) {
a.name = arg.slice(0, -2);
}
}
}
return a;
},
_marshalInstanceEffects: function () {
Polymer.Bind.prepareInstance(this);
if (this._bindListeners) {
Polymer.Bind.setupBindListeners(this);
}
},
_applyEffectValue: function (info, value) {
var node = this._nodes[info.index];
var property = info.name;
value = this._computeFinalAnnotationValue(node, property, value, info);
if (info.kind == 'attribute') {
this.serializeValueToAttribute(value, property, node);
} else {
var pinfo = node._propertyInfo && node._propertyInfo[property];
if (pinfo && pinfo.readOnly) {
return;
}
this.__setProperty(property, value, Polymer.Settings.suppressBindingNotifications, node);
}
},
_computeFinalAnnotationValue: function (node, property, value, info) {
if (info.negate) {
value = !value;
}
if (info.isCompound) {
var storage = node.__compoundStorage__[property];
storage[info.compoundIndex] = value;
value = storage.join('');
}
if (info.kind !== 'attribute') {
if (property === 'className') {
value = this._scopeElementClass(node, value);
}
if (property === 'textContent' || node.localName == 'input' && property == 'value') {
value = value == undefined ? '' : value;
}
}
return value;
},
_executeStaticEffects: function () {
if (this._propertyEffects && this._propertyEffects.__static__) {
this._effectEffects('__static__', null, this._propertyEffects.__static__);
}
}
});(function () {
var usePolyfillProto = Polymer.Settings.usePolyfillProto;
var avoidInstanceProperties = Boolean(Object.getOwnPropertyDescriptor(document.documentElement, 'properties'));
Polymer.Base._addFeature({
_setupConfigure: function (initialConfig) {
this._config = {};
this._handlers = [];
this._aboveConfig = null;
if (initialConfig) {
for (var i in initialConfig) {
if (initialConfig[i] !== undefined) {
this._config[i] = initialConfig[i];
}
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this._config);
},
_attributeChangedImpl: function (name) {
var model = this._clientsReadied ? this : this._config;
this._setAttributeToProperty(model, name);
},
_configValue: function (name, value) {
var info = this._propertyInfo[name];
if (!info || !info.readOnly) {
this._config[name] = value;
}
},
_beforeClientsReady: function () {
this._configure();
},
_configure: function () {
this._configureAnnotationReferences();
this._configureInstanceProperties();
this._aboveConfig = this.mixin({}, this._config);
var config = {};
for (var i = 0; i < this.behaviors.length; i++) {
this._configureProperties(this.behaviors[i].properties, config);
}
this._configureProperties(avoidInstanceProperties ? this.__proto__.properties : this.properties, config);
this.mixin(config, this._aboveConfig);
this._config = config;
if (this._clients && this._clients.length) {
this._distributeConfig(this._config);
}
},
_configureInstanceProperties: function () {
for (var i in this._propertyEffects) {
if (!usePolyfillProto && this.hasOwnProperty(i)) {
this._configValue(i, this[i]);
delete this[i];
}
}
},
_configureProperties: function (properties, config) {
for (var i in properties) {
var c = properties[i];
if (c.value !== undefined) {
var value = c.value;
if (typeof value == 'function') {
value = value.call(this, this._config);
}
config[i] = value;
}
}
},
_distributeConfig: function (config) {
var fx$ = this._propertyEffects;
if (fx$) {
for (var p in config) {
var fx = fx$[p];
if (fx) {
for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
if (x.kind === 'annotation') {
var node = this._nodes[x.effect.index];
var name = x.effect.propertyName;
var isAttr = x.effect.kind == 'attribute';
var hasEffect = node._propertyEffects && node._propertyEffects[name];
if (node._configValue && (hasEffect || !isAttr)) {
var value = p === x.effect.value ? config[p] : this._get(x.effect.value, config);
value = this._computeFinalAnnotationValue(node, name, value, x.effect);
if (isAttr) {
value = node.deserialize(this.serialize(value), node._propertyInfo[name].type);
}
node._configValue(name, value);
}
}
}
}
}
}
},
_afterClientsReady: function () {
this.importPath = this._importPath;
this.rootPath = Polymer.rootPath;
this._executeStaticEffects();
this._applyConfig(this._config, this._aboveConfig);
this._flushHandlers();
},
_applyConfig: function (config, aboveConfig) {
for (var n in config) {
if (this[n] === undefined) {
this.__setProperty(n, config[n], n in aboveConfig);
}
}
},
_notifyListener: function (fn, e) {
if (!Polymer.Bind._isEventBogus(e, e.target)) {
var value, path;
if (e.detail) {
value = e.detail.value;
path = e.detail.path;
}
if (!this._clientsReadied) {
this._queueHandler([
fn,
e.target,
value,
path
]);
} else {
return fn.call(this, e.target, value, path);
}
}
},
_queueHandler: function (args) {
this._handlers.push(args);
},
_flushHandlers: function () {
var h$ = this._handlers;
for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
h[0].call(this, h[1], h[2], h[3]);
}
this._handlers = [];
}
});
}());(function () {
'use strict';
var Path = Polymer.Path;
Polymer.Base._addFeature({
notifyPath: function (path, value, fromAbove) {
var info = {};
var v = this._get(path, this, info);
if (arguments.length === 1) {
value = v;
}
if (info.path) {
this._notifyPath(info.path, value, fromAbove);
}
},
_notifyPath: function (path, value, fromAbove) {
var old = this._propertySetter(path, value);
if (old !== value && (old === old || value === value)) {
this._pathEffector(path, value);
if (!fromAbove) {
this._notifyPathUp(path, value);
}
return true;
}
},
_getPathParts: function (path) {
if (Array.isArray(path)) {
var parts = [];
for (var i = 0; i < path.length; i++) {
var args = path[i].toString().split('.');
for (var j = 0; j < args.length; j++) {
parts.push(args[j]);
}
}
return parts;
} else {
return path.toString().split('.');
}
},
set: function (path, value, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
var last = parts[parts.length - 1];
if (parts.length > 1) {
for (var i = 0; i < parts.length - 1; i++) {
var part = parts[i];
if (array && part[0] == '#') {
prop = Polymer.Collection.get(array).getItem(part);
} else {
prop = prop[part];
if (array && parseInt(part, 10) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
}
if (!prop) {
return;
}
array = Array.isArray(prop) ? prop : null;
}
if (array) {
var coll = Polymer.Collection.get(array);
var old, key;
if (last[0] == '#') {
key = last;
old = coll.getItem(key);
last = array.indexOf(old);
coll.setItem(key, value);
} else if (parseInt(last, 10) == last) {
old = prop[last];
key = coll.getKey(old);
parts[i] = key;
coll.setItem(key, value);
}
}
prop[last] = value;
if (!root) {
this._notifyPath(parts.join('.'), value);
}
} else {
prop[path] = value;
}
},
get: function (path, root) {
return this._get(path, root);
},
_get: function (path, root, info) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
for (var i = 0; i < parts.length; i++) {
if (!prop) {
return;
}
var part = parts[i];
if (array && part[0] == '#') {
prop = Polymer.Collection.get(array).getItem(part);
} else {
prop = prop[part];
if (info && array && parseInt(part, 10) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
}
array = Array.isArray(prop) ? prop : null;
}
if (info) {
info.path = parts.join('.');
}
return prop;
},
_pathEffector: function (path, value) {
var model = Path.root(path);
var fx$ = this._propertyEffects && this._propertyEffects[model];
if (fx$) {
for (var i = 0, fx; i < fx$.length && (fx = fx$[i]); i++) {
var fxFn = fx.pathFn;
if (fxFn) {
fxFn.call(this, path, value, fx.effect);
}
}
}
if (this._boundPaths) {
this._notifyBoundPaths(path, value);
}
},
_annotationPathEffect: function (path, value, effect) {
if (Path.matches(effect.value, false, path)) {
Polymer.Bind._annotationEffect.call(this, path, value, effect);
} else if (!effect.negate && Path.isDescendant(effect.value, path)) {
var node = this._nodes[effect.index];
if (node && node._notifyPath) {
var newPath = Path.translate(effect.value, effect.name, path);
node._notifyPath(newPath, value, true);
}
}
},
_complexObserverPathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
}
},
_computePathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._computeEffect.call(this, path, value, effect);
}
},
_annotatedComputationPathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
}
},
linkPaths: function (to, from) {
this._boundPaths = this._boundPaths || {};
if (from) {
this._boundPaths[to] = from;
} else {
this.unlinkPaths(to);
}
},
unlinkPaths: function (path) {
if (this._boundPaths) {
delete this._boundPaths[path];
}
},
_notifyBoundPaths: function (path, value) {
for (var a in this._boundPaths) {
var b = this._boundPaths[a];
if (Path.isDescendant(a, path)) {
this._notifyPath(Path.translate(a, b, path), value);
} else if (Path.isDescendant(b, path)) {
this._notifyPath(Path.translate(b, a, path), value);
}
}
},
_notifyPathUp: function (path, value) {
var rootName = Path.root(path);
var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
var eventName = dashCaseName + this._EVENT_CHANGED;
this.fire(eventName, {
path: path,
value: value
}, {
bubbles: false,
_useCache: Polymer.Settings.eventDataCache || !Polymer.Settings.isIE
});
},
_EVENT_CHANGED: '-changed',
notifySplices: function (path, splices) {
var info = {};
var array = this._get(path, this, info);
this._notifySplices(array, info.path, splices);
},
_notifySplices: function (array, path, splices) {
var change = {
keySplices: Polymer.Collection.applySplices(array, splices),
indexSplices: splices
};
var splicesPath = path + '.splices';
this._notifyPath(splicesPath, change);
this._notifyPath(path + '.length', array.length);
this.__data__[splicesPath] = {
keySplices: null,
indexSplices: null
};
},
_notifySplice: function (array, path, index, added, removed) {
this._notifySplices(array, path, [{
index: index,
addedCount: added,
removed: removed,
object: array,
type: 'splice'
}]);
},
push: function (path) {
var info = {};
var array = this._get(path, this, info);
var args = Array.prototype.slice.call(arguments, 1);
var len = array.length;
var ret = array.push.apply(array, args);
if (args.length) {
this._notifySplice(array, info.path, len, args.length, []);
}
return ret;
},
pop: function (path) {
var info = {};
var array = this._get(path, this, info);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.pop.apply(array, args);
if (hadLength) {
this._notifySplice(array, info.path, array.length, 0, [ret]);
}
return ret;
},
splice: function (path, start) {
var info = {};
var array = this._get(path, this, info);
if (start < 0) {
start = array.length - Math.floor(-start);
} else {
start = Math.floor(start);
}
if (!start) {
start = 0;
}
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.splice.apply(array, args);
var addedCount = Math.max(args.length - 2, 0);
if (addedCount || ret.length) {
this._notifySplice(array, info.path, start, addedCount, ret);
}
return ret;
},
shift: function (path) {
var info = {};
var array = this._get(path, this, info);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.shift.apply(array, args);
if (hadLength) {
this._notifySplice(array, info.path, 0, 0, [ret]);
}
return ret;
},
unshift: function (path) {
var info = {};
var array = this._get(path, this, info);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.unshift.apply(array, args);
if (args.length) {
this._notifySplice(array, info.path, 0, args.length, []);
}
return ret;
},
prepareModelNotifyPath: function (model) {
this.mixin(model, {
fire: Polymer.Base.fire,
_getEvent: Polymer.Base._getEvent,
__eventCache: Polymer.Base.__eventCache,
notifyPath: Polymer.Base.notifyPath,
_get: Polymer.Base._get,
_EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,
_notifyPath: Polymer.Base._notifyPath,
_notifyPathUp: Polymer.Base._notifyPathUp,
_pathEffector: Polymer.Base._pathEffector,
_annotationPathEffect: Polymer.Base._annotationPathEffect,
_complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,
_annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,
_computePathEffect: Polymer.Base._computePathEffect,
_notifyBoundPaths: Polymer.Base._notifyBoundPaths,
_getPathParts: Polymer.Base._getPathParts
});
}
});
}());Polymer.Base._addFeature({
resolveUrl: function (url) {
return Polymer.ResolveUrl.resolveUrl(url, this._importPath);
}
});Polymer.CssParse = function () {
return {
parse: function (text) {
text = this._clean(text);
return this._parseCss(this._lex(text), text);
},
_clean: function (cssText) {
return cssText.replace(this._rx.comments, '').replace(this._rx.port, '');
},
_lex: function (text) {
var root = {
start: 0,
end: text.length
};
var n = root;
for (var i = 0, l = text.length; i < l; i++) {
switch (text[i]) {
case this.OPEN_BRACE:
if (!n.rules) {
n.rules = [];
}
var p = n;
var previous = p.rules[p.rules.length - 1];
n = {
start: i + 1,
parent: p,
previous: previous
};
p.rules.push(n);
break;
case this.CLOSE_BRACE:
n.end = i + 1;
n = n.parent || root;
break;
}
}
return root;
},
_parseCss: function (node, text) {
var t = text.substring(node.start, node.end - 1);
node.parsedCssText = node.cssText = t.trim();
if (node.parent) {
var ss = node.previous ? node.previous.end : node.parent.start;
t = text.substring(ss, node.start - 1);
t = this._expandUnicodeEscapes(t);
t = t.replace(this._rx.multipleSpaces, ' ');
t = t.substring(t.lastIndexOf(';') + 1);
var s = node.parsedSelector = node.selector = t.trim();
node.atRule = s.indexOf(this.AT_START) === 0;
if (node.atRule) {
if (s.indexOf(this.MEDIA_START) === 0) {
node.type = this.types.MEDIA_RULE;
} else if (s.match(this._rx.keyframesRule)) {
node.type = this.types.KEYFRAMES_RULE;
node.keyframesName = node.selector.split(this._rx.multipleSpaces).pop();
}
} else {
if (s.indexOf(this.VAR_START) === 0) {
node.type = this.types.MIXIN_RULE;
} else {
node.type = this.types.STYLE_RULE;
}
}
}
var r$ = node.rules;
if (r$) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this._parseCss(r, text);
}
}
return node;
},
_expandUnicodeEscapes: function (s) {
return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
var code = arguments[1], repeat = 6 - code.length;
while (repeat--) {
code = '0' + code;
}
return '\\' + code;
});
},
stringify: function (node, preserveProperties, text) {
text = text || '';
var cssText = '';
if (node.cssText || node.rules) {
var r$ = node.rules;
if (r$ && !this._hasMixinRules(r$)) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
cssText = this.stringify(r, preserveProperties, cssText);
}
} else {
cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
cssText = cssText.trim();
if (cssText) {
cssText = '  ' + cssText + '\n';
}
}
}
if (cssText) {
if (node.selector) {
text += node.selector + ' ' + this.OPEN_BRACE + '\n';
}
text += cssText;
if (node.selector) {
text += this.CLOSE_BRACE + '\n\n';
}
}
return text;
},
_hasMixinRules: function (rules) {
return rules[0].selector.indexOf(this.VAR_START) === 0;
},
removeCustomProps: function (cssText) {
cssText = this.removeCustomPropAssignment(cssText);
return this.removeCustomPropApply(cssText);
},
removeCustomPropAssignment: function (cssText) {
return cssText.replace(this._rx.customProp, '').replace(this._rx.mixinProp, '');
},
removeCustomPropApply: function (cssText) {
return cssText.replace(this._rx.mixinApply, '').replace(this._rx.varApply, '');
},
types: {
STYLE_RULE: 1,
KEYFRAMES_RULE: 7,
MEDIA_RULE: 4,
MIXIN_RULE: 1000
},
OPEN_BRACE: '{',
CLOSE_BRACE: '}',
_rx: {
comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
port: /@import[^;]*;/gim,
customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
keyframesRule: /^@[^\s]*keyframes/,
multipleSpaces: /\s+/g
},
VAR_START: '--',
MEDIA_START: '@media',
AT_START: '@'
};
}();Polymer.StyleUtil = function () {
var settings = Polymer.Settings;
return {
unscopedStyleImports: new WeakMap(),
SHADY_UNSCOPED_ATTR: 'shady-unscoped',
NATIVE_VARIABLES: Polymer.Settings.useNativeCSSProperties,
MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',
INCLUDE_ATTR: 'include',
toCssText: function (rules, callback) {
if (typeof rules === 'string') {
rules = this.parser.parse(rules);
}
if (callback) {
this.forEachRule(rules, callback);
}
return this.parser.stringify(rules, this.NATIVE_VARIABLES);
},
forRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback);
}
}
},
forActiveRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback, true);
}
}
},
rulesForStyle: function (style) {
if (!style.__cssRules && style.textContent) {
style.__cssRules = this.parser.parse(style.textContent);
}
return style.__cssRules;
},
isKeyframesSelector: function (rule) {
return rule.parent && rule.parent.type === this.ruleTypes.KEYFRAMES_RULE;
},
forEachRuleInStyle: function (style, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
var rules = this.rulesForStyle(style);
var styleCallback, keyframeCallback;
if (styleRuleCallback) {
styleCallback = function (rule) {
styleRuleCallback(rule, style);
};
}
if (keyframesRuleCallback) {
keyframeCallback = function (rule) {
keyframesRuleCallback(rule, style);
};
}
this.forEachRule(rules, styleCallback, keyframeCallback, onlyActiveRules);
},
forEachRule: function (node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
if (!node) {
return;
}
var skipRules = false;
if (onlyActiveRules) {
if (node.type === this.ruleTypes.MEDIA_RULE) {
var matchMedia = node.selector.match(this.rx.MEDIA_MATCH);
if (matchMedia) {
if (!window.matchMedia(matchMedia[1]).matches) {
skipRules = true;
}
}
}
}
if (node.type === this.ruleTypes.STYLE_RULE) {
styleRuleCallback(node);
} else if (keyframesRuleCallback && node.type === this.ruleTypes.KEYFRAMES_RULE) {
keyframesRuleCallback(node);
} else if (node.type === this.ruleTypes.MIXIN_RULE) {
skipRules = true;
}
var r$ = node.rules;
if (r$ && !skipRules) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this.forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
}
}
},
applyCss: function (cssText, moniker, target, contextNode) {
var style = this.createScopeStyle(cssText, moniker);
return this.applyStyle(style, target, contextNode);
},
applyStyle: function (style, target, contextNode) {
target = target || document.head;
var after = contextNode && contextNode.nextSibling || target.firstChild;
this.__lastHeadApplyNode = style;
return target.insertBefore(style, after);
},
createScopeStyle: function (cssText, moniker) {
var style = document.createElement('style');
if (moniker) {
style.setAttribute('scope', moniker);
}
style.textContent = cssText;
return style;
},
__lastHeadApplyNode: null,
applyStylePlaceHolder: function (moniker) {
var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
var after = this.__lastHeadApplyNode ? this.__lastHeadApplyNode.nextSibling : null;
var scope = document.head;
scope.insertBefore(placeHolder, after || scope.firstChild);
this.__lastHeadApplyNode = placeHolder;
return placeHolder;
},
cssFromModules: function (moduleIds, warnIfNotFound) {
var modules = moduleIds.trim().split(/\s+/);
var cssText = '';
for (var i = 0; i < modules.length; i++) {
cssText += this.cssFromModule(modules[i], warnIfNotFound);
}
return cssText;
},
cssFromModule: function (moduleId, warnIfNotFound) {
var m = Polymer.DomModule.import(moduleId);
if (m && !m._cssText) {
m._cssText = this.cssFromElement(m);
}
if (!m && warnIfNotFound) {
console.warn('Could not find style data in module named', moduleId);
}
return m && m._cssText || '';
},
cssFromElement: function (element) {
var cssText = '';
var content = element.content || element;
var e$ = Polymer.TreeApi.arrayCopy(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
for (var i = 0, e; i < e$.length; i++) {
e = e$[i];
if (e.localName === 'template') {
if (!e.hasAttribute('preserve-content')) {
cssText += this.cssFromElement(e);
}
} else {
if (e.localName === 'style') {
var include = e.getAttribute(this.INCLUDE_ATTR);
if (include) {
cssText += this.cssFromModules(include, true);
}
e = e.__appliedElement || e;
e.parentNode.removeChild(e);
var css = this.resolveCss(e.textContent, element.ownerDocument);
if (!settings.useNativeShadow && e.hasAttribute(this.SHADY_UNSCOPED_ATTR)) {
e.textContent = css;
document.head.insertBefore(e, document.head.firstChild);
} else {
cssText += css;
}
} else if (e.import && e.import.body) {
var importCss = this.resolveCss(e.import.body.textContent, e.import);
if (!settings.useNativeShadow && e.hasAttribute(this.SHADY_UNSCOPED_ATTR)) {
if (!this.unscopedStyleImports.has(e.import)) {
this.unscopedStyleImports.set(e.import, true);
var importStyle = document.createElement('style');
importStyle.setAttribute(this.SHADY_UNSCOPED_ATTR, '');
importStyle.textContent = importCss;
document.head.insertBefore(importStyle, document.head.firstChild);
}
} else {
cssText += importCss;
}
}
}
}
return cssText;
},
styleIncludesToTemplate: function (targetTemplate) {
var styles = targetTemplate.content.querySelectorAll('style[include]');
for (var i = 0, s; i < styles.length; i++) {
s = styles[i];
s.parentNode.insertBefore(this._includesToFragment(s.getAttribute('include')), s);
}
},
_includesToFragment: function (styleIncludes) {
var includeArray = styleIncludes.trim().split(' ');
var frag = document.createDocumentFragment();
for (var i = 0; i < includeArray.length; i++) {
var t = Polymer.DomModule.import(includeArray[i], 'template');
if (t) {
this._addStylesToFragment(frag, t.content);
}
}
return frag;
},
_addStylesToFragment: function (frag, source) {
var s$ = source.querySelectorAll('style');
for (var i = 0, s; i < s$.length; i++) {
s = s$[i];
var include = s.getAttribute('include');
if (include) {
frag.appendChild(this._includesToFragment(include));
}
if (s.textContent) {
frag.appendChild(s.cloneNode(true));
}
}
},
isTargetedBuild: function (buildType) {
return settings.useNativeShadow ? buildType === 'shadow' : buildType === 'shady';
},
cssBuildTypeForModule: function (module) {
var dm = Polymer.DomModule.import(module);
if (dm) {
return this.getCssBuildType(dm);
}
},
getCssBuildType: function (element) {
return element.getAttribute('css-build');
},
_findMatchingParen: function (text, start) {
var level = 0;
for (var i = start, l = text.length; i < l; i++) {
switch (text[i]) {
case '(':
level++;
break;
case ')':
if (--level === 0) {
return i;
}
break;
}
}
return -1;
},
processVariableAndFallback: function (str, callback) {
var start = str.indexOf('var(');
if (start === -1) {
return callback(str, '', '', '');
}
var end = this._findMatchingParen(str, start + 3);
var inner = str.substring(start + 4, end);
var prefix = str.substring(0, start);
var suffix = this.processVariableAndFallback(str.substring(end + 1), callback);
var comma = inner.indexOf(',');
if (comma === -1) {
return callback(prefix, inner.trim(), '', suffix);
}
var value = inner.substring(0, comma).trim();
var fallback = inner.substring(comma + 1).trim();
return callback(prefix, value, fallback, suffix);
},
rx: {
VAR_ASSIGN: /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,
MIXIN_MATCH: /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
VAR_CONSUMED: /(--[\w-]+)\s*([:,;)]|$)/gi,
ANIMATION_MATCH: /(animation\s*:)|(animation-name\s*:)/,
MEDIA_MATCH: /@media[^(]*(\([^)]*\))/,
IS_VAR: /^--/,
BRACKETED: /\{[^}]*\}/g,
HOST_PREFIX: '(?:^|[^.#[:])',
HOST_SUFFIX: '($|[.:[\\s>+~])'
},
resolveCss: Polymer.ResolveUrl.resolveCss,
parser: Polymer.CssParse,
ruleTypes: Polymer.CssParse.types
};
}();Polymer.StyleTransformer = function () {
var styleUtil = Polymer.StyleUtil;
var settings = Polymer.Settings;
var api = {
dom: function (node, scope, useAttr, shouldRemoveScope) {
this._transformDom(node, scope || '', useAttr, shouldRemoveScope);
},
_transformDom: function (node, selector, useAttr, shouldRemoveScope) {
if (node.setAttribute) {
this.element(node, selector, useAttr, shouldRemoveScope);
}
var c$ = Polymer.dom(node).childNodes;
for (var i = 0; i < c$.length; i++) {
this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
}
},
element: function (element, scope, useAttr, shouldRemoveScope) {
if (useAttr) {
if (shouldRemoveScope) {
element.removeAttribute(SCOPE_NAME);
} else {
element.setAttribute(SCOPE_NAME, scope);
}
} else {
if (scope) {
if (element.classList) {
if (shouldRemoveScope) {
element.classList.remove(SCOPE_NAME);
element.classList.remove(scope);
} else {
element.classList.add(SCOPE_NAME);
element.classList.add(scope);
}
} else if (element.getAttribute) {
var c = element.getAttribute(CLASS);
if (shouldRemoveScope) {
if (c) {
element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
}
} else {
element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);
}
}
}
}
},
elementStyles: function (element, callback) {
var styles = element._styles;
var cssText = '';
var cssBuildType = element.__cssBuild;
var passthrough = settings.useNativeShadow || cssBuildType === 'shady';
var cb;
if (passthrough) {
var self = this;
cb = function (rule) {
rule.selector = self._slottedToContent(rule.selector);
rule.selector = rule.selector.replace(ROOT, ':host > *');
rule.selector = self._dirShadowTransform(rule.selector);
if (callback) {
callback(rule);
}
};
}
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
var rules = styleUtil.rulesForStyle(s);
cssText += passthrough ? styleUtil.toCssText(rules, cb) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\n\n';
}
return cssText.trim();
},
css: function (rules, scope, ext, callback, useAttr) {
var hostScope = this._calcHostScope(scope, ext);
scope = this._calcElementScope(scope, useAttr);
var self = this;
return styleUtil.toCssText(rules, function (rule) {
if (!rule.isScoped) {
self.rule(rule, scope, hostScope);
rule.isScoped = true;
}
if (callback) {
callback(rule, scope, hostScope);
}
});
},
_calcElementScope: function (scope, useAttr) {
if (scope) {
return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
} else {
return '';
}
},
_calcHostScope: function (scope, ext) {
return ext ? '[is=' + scope + ']' : scope;
},
rule: function (rule, scope, hostScope) {
this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
},
_transformRule: function (rule, transformer, scope, hostScope) {
rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);
},
_splitSelectorList: function (selector) {
var parts = [];
var part = '';
for (var i = 0; i >= 0 && i < selector.length; i++) {
if (selector[i] === '(') {
var end = styleUtil._findMatchingParen(selector, i);
part += selector.slice(i, end + 1);
i = end;
} else if (selector[i] === COMPLEX_SELECTOR_SEP) {
parts.push(part);
part = '';
} else {
part += selector[i];
}
}
if (part) {
parts.push(part);
}
if (parts.length === 0) {
parts.push(selector);
}
return parts;
},
_transformRuleCss: function (rule, transformer, scope, hostScope) {
var p$ = this._splitSelectorList(rule.selector);
if (!styleUtil.isKeyframesSelector(rule)) {
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
p$[i] = transformer.call(this, p, scope, hostScope);
}
}
return p$.join(COMPLEX_SELECTOR_SEP);
},
_ensureScopedDir: function (s) {
var m = s.match(DIR_PAREN);
if (m && m[1] === '' && m[0].length === s.length) {
s = '*' + s;
}
return s;
},
_additionalDirSelectors: function (dir, after, prefix) {
if (!dir || !after) {
return '';
}
prefix = prefix || '';
return COMPLEX_SELECTOR_SEP + prefix + ' ' + dir + ' ' + after;
},
_transformComplexSelector: function (selector, scope, hostScope) {
var stop = false;
var hostContext = false;
var dir = false;
var self = this;
selector = selector.trim();
selector = this._slottedToContent(selector);
selector = selector.replace(ROOT, ':host > *');
selector = selector.replace(CONTENT_START, HOST + ' $1');
selector = this._ensureScopedDir(selector);
selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
if (!stop) {
var info = self._transformCompoundSelector(s, c, scope, hostScope);
stop = stop || info.stop;
hostContext = hostContext || info.hostContext;
dir = dir || info.dir;
c = info.combinator;
s = info.value;
} else {
s = s.replace(SCOPE_JUMP, ' ');
}
return c + s;
});
if (hostContext) {
selector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {
var replacement = pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;
if (dir) {
replacement += self._additionalDirSelectors(paren, post, hostScope);
}
return replacement;
});
}
return selector;
},
_transformDir: function (s) {
s = s.replace(HOST_DIR, HOST_DIR_REPLACE);
s = s.replace(DIR_PAREN, DIR_REPLACE);
return s;
},
_transformCompoundSelector: function (selector, combinator, scope, hostScope) {
var jumpIndex = selector.search(SCOPE_JUMP);
var hostContext = false;
var dir = false;
if (selector.match(DIR_PAREN)) {
selector = this._transformDir(selector);
dir = true;
}
if (selector.indexOf(HOST_CONTEXT) >= 0) {
hostContext = true;
} else if (selector.indexOf(HOST) >= 0) {
selector = this._transformHostSelector(selector, hostScope);
} else if (jumpIndex !== 0) {
selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
}
if (selector.indexOf(CONTENT) >= 0) {
combinator = '';
}
var stop;
if (jumpIndex >= 0) {
selector = selector.replace(SCOPE_JUMP, ' ');
stop = true;
}
return {
value: selector,
combinator: combinator,
stop: stop,
hostContext: hostContext,
dir: dir
};
},
_transformSimpleSelector: function (selector, scope) {
var p$ = selector.split(PSEUDO_PREFIX);
p$[0] += scope;
return p$.join(PSEUDO_PREFIX);
},
_transformHostSelector: function (selector, hostScope) {
var m = selector.match(HOST_PAREN);
var paren = m && m[2].trim() || '';
if (paren) {
if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {
var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];
if (typeSelector === hostScope) {
return paren;
} else {
return SELECTOR_NO_MATCH;
}
} else {
return selector.replace(HOST_PAREN, function (m, host, paren) {
return hostScope + paren;
});
}
} else {
return selector.replace(HOST, hostScope);
}
},
documentRule: function (rule) {
rule.selector = rule.parsedSelector;
this.normalizeRootSelector(rule);
if (!settings.useNativeShadow) {
this._transformRule(rule, this._transformDocumentSelector);
}
},
normalizeRootSelector: function (rule) {
rule.selector = rule.selector.replace(ROOT, 'html');
var parts = this._splitSelectorList(rule.selector);
parts = parts.filter(function (part) {
return !part.match(HOST_OR_HOST_GT_STAR);
});
rule.selector = parts.join(COMPLEX_SELECTOR_SEP);
},
_transformDocumentSelector: function (selector) {
return this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR);
},
_slottedToContent: function (cssText) {
return cssText.replace(SLOTTED_PAREN, CONTENT + '> $1');
},
_dirShadowTransform: function (selector) {
if (!selector.match(/:dir\(/)) {
return selector;
}
return this._splitSelectorList(selector).map(function (s) {
s = this._ensureScopedDir(s);
s = this._transformDir(s);
var m = HOST_CONTEXT_PAREN.exec(s);
if (m) {
s += this._additionalDirSelectors(m[2], m[3], '');
}
return s;
}, this).join(COMPLEX_SELECTOR_SEP);
},
SCOPE_NAME: 'style-scope'
};
var SCOPE_NAME = api.SCOPE_NAME;
var SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';
var COMPLEX_SELECTOR_SEP = ',';
var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g;
var SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;
var HOST = ':host';
var ROOT = ':root';
var HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
var HOST_CONTEXT = ':host-context';
var HOST_CONTEXT_PAREN = /(.*)(?::host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
var CONTENT = '::content';
var SCOPE_JUMP = /::content|::shadow|\/deep\//;
var CSS_CLASS_PREFIX = '.';
var CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';
var CSS_ATTR_SUFFIX = ']';
var PSEUDO_PREFIX = ':';
var CLASS = 'class';
var CONTENT_START = new RegExp('^(' + CONTENT + ')');
var SELECTOR_NO_MATCH = 'should_not_match';
var SLOTTED_PAREN = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
var HOST_OR_HOST_GT_STAR = /:host(?:\s*>\s*\*)?/;
var DIR_PAREN = /(.*):dir\((ltr|rtl)\)/;
var DIR_REPLACE = ':host-context([dir="$2"]) $1';
var HOST_DIR = /:host\(:dir\((rtl|ltr)\)\)/g;
var HOST_DIR_REPLACE = ':host-context([dir="$1"])';
return api;
}();Polymer.StyleExtends = function () {
var styleUtil = Polymer.StyleUtil;
return {
hasExtends: function (cssText) {
return Boolean(cssText.match(this.rx.EXTEND));
},
transform: function (style) {
var rules = styleUtil.rulesForStyle(style);
var self = this;
styleUtil.forEachRule(rules, function (rule) {
self._mapRuleOntoParent(rule);
if (rule.parent) {
var m;
while (m = self.rx.EXTEND.exec(rule.cssText)) {
var extend = m[1];
var extendor = self._findExtendor(extend, rule);
if (extendor) {
self._extendRule(rule, extendor);
}
}
}
rule.cssText = rule.cssText.replace(self.rx.EXTEND, '');
});
return styleUtil.toCssText(rules, function (rule) {
if (rule.selector.match(self.rx.STRIP)) {
rule.cssText = '';
}
}, true);
},
_mapRuleOntoParent: function (rule) {
if (rule.parent) {
var map = rule.parent.map || (rule.parent.map = {});
var parts = rule.selector.split(',');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
map[p.trim()] = rule;
}
return map;
}
},
_findExtendor: function (extend, rule) {
return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
},
_extendRule: function (target, source) {
if (target.parent !== source.parent) {
this._cloneAndAddRuleToParent(source, target.parent);
}
target.extends = target.extends || [];
target.extends.push(source);
source.selector = source.selector.replace(this.rx.STRIP, '');
source.selector = (source.selector && source.selector + ',\n') + target.selector;
if (source.extends) {
source.extends.forEach(function (e) {
this._extendRule(target, e);
}, this);
}
},
_cloneAndAddRuleToParent: function (rule, parent) {
rule = Object.create(rule);
rule.parent = parent;
if (rule.extends) {
rule.extends = rule.extends.slice();
}
parent.rules.push(rule);
},
rx: {
EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
STRIP: /%[^,]*$/
}
};
}();Polymer.ApplyShim = function () {
'use strict';
var styleUtil = Polymer.StyleUtil;
var MIXIN_MATCH = styleUtil.rx.MIXIN_MATCH;
var VAR_ASSIGN = styleUtil.rx.VAR_ASSIGN;
var BAD_VAR = /var\(\s*(--[^,]*),\s*(--[^)]*)\)/g;
var APPLY_NAME_CLEAN = /;\s*/m;
var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
var MIXIN_VAR_SEP = '_-_';
var mixinMap = {};
function mapSet(name, props) {
name = name.trim();
mixinMap[name] = {
properties: props,
dependants: {}
};
}
function mapGet(name) {
name = name.trim();
return mixinMap[name];
}
function replaceInitialOrInherit(property, value) {
var match = INITIAL_INHERIT.exec(value);
if (match) {
if (match[1]) {
value = ApplyShim._getInitialValueForProperty(property);
} else {
value = 'apply-shim-inherit';
}
}
return value;
}
function cssTextToMap(text) {
var props = text.split(';');
var property, value;
var out = {};
for (var i = 0, p, sp; i < props.length; i++) {
p = props[i];
if (p) {
sp = p.split(':');
if (sp.length > 1) {
property = sp[0].trim();
value = replaceInitialOrInherit(property, sp.slice(1).join(':'));
out[property] = value;
}
}
}
return out;
}
function invalidateMixinEntry(mixinEntry) {
var currentProto = ApplyShim.__currentElementProto;
var currentElementName = currentProto && currentProto.is;
for (var elementName in mixinEntry.dependants) {
if (elementName !== currentElementName) {
mixinEntry.dependants[elementName].__applyShimInvalid = true;
}
}
}
function produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
if (valueProperty) {
styleUtil.processVariableAndFallback(valueProperty, function (prefix, value) {
if (value && mapGet(value)) {
valueMixin = '@apply ' + value + ';';
}
});
}
if (!valueMixin) {
return matchText;
}
var mixinAsProperties = consumeCssProperties(valueMixin);
var prefix = matchText.slice(0, matchText.indexOf('--'));
var mixinValues = cssTextToMap(mixinAsProperties);
var combinedProps = mixinValues;
var mixinEntry = mapGet(propertyName);
var oldProps = mixinEntry && mixinEntry.properties;
if (oldProps) {
combinedProps = Object.create(oldProps);
combinedProps = Polymer.Base.mixin(combinedProps, mixinValues);
} else {
mapSet(propertyName, combinedProps);
}
var out = [];
var p, v;
var needToInvalidate = false;
for (p in combinedProps) {
v = mixinValues[p];
if (v === undefined) {
v = 'initial';
}
if (oldProps && !(p in oldProps)) {
needToInvalidate = true;
}
out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);
}
if (needToInvalidate) {
invalidateMixinEntry(mixinEntry);
}
if (mixinEntry) {
mixinEntry.properties = combinedProps;
}
if (valueProperty) {
prefix = matchText + ';' + prefix;
}
return prefix + out.join('; ') + ';';
}
function fixVars(matchText, varA, varB) {
return 'var(' + varA + ',' + 'var(' + varB + '))';
}
function atApplyToCssProperties(mixinName, fallbacks) {
mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
var vars = [];
var mixinEntry = mapGet(mixinName);
if (!mixinEntry) {
mapSet(mixinName, {});
mixinEntry = mapGet(mixinName);
}
if (mixinEntry) {
var currentProto = ApplyShim.__currentElementProto;
if (currentProto) {
mixinEntry.dependants[currentProto.is] = currentProto;
}
var p, parts, f;
for (p in mixinEntry.properties) {
f = fallbacks && fallbacks[p];
parts = [
p,
': var(',
mixinName,
MIXIN_VAR_SEP,
p
];
if (f) {
parts.push(',', f);
}
parts.push(')');
vars.push(parts.join(''));
}
}
return vars.join('; ');
}
function consumeCssProperties(text) {
var m;
while (m = MIXIN_MATCH.exec(text)) {
var matchText = m[0];
var mixinName = m[1];
var idx = m.index;
var applyPos = idx + matchText.indexOf('@apply');
var afterApplyPos = idx + matchText.length;
var textBeforeApply = text.slice(0, applyPos);
var textAfterApply = text.slice(afterApplyPos);
var defaults = cssTextToMap(textBeforeApply);
var replacement = atApplyToCssProperties(mixinName, defaults);
text = [
textBeforeApply,
replacement,
textAfterApply
].join('');
MIXIN_MATCH.lastIndex = idx + replacement.length;
}
return text;
}
var ApplyShim = {
_measureElement: null,
_map: mixinMap,
_separator: MIXIN_VAR_SEP,
transform: function (styles, elementProto) {
this.__currentElementProto = elementProto;
styleUtil.forRulesInStyles(styles, this._boundFindDefinitions);
styleUtil.forRulesInStyles(styles, this._boundFindApplications);
if (elementProto) {
elementProto.__applyShimInvalid = false;
}
this.__currentElementProto = null;
},
_findDefinitions: function (rule) {
var cssText = rule.parsedCssText;
cssText = cssText.replace(BAD_VAR, fixVars);
cssText = cssText.replace(VAR_ASSIGN, produceCssProperties);
rule.cssText = cssText;
if (rule.selector === ':root') {
rule.selector = ':host > *';
}
},
_findApplications: function (rule) {
rule.cssText = consumeCssProperties(rule.cssText);
},
transformRule: function (rule) {
this._findDefinitions(rule);
this._findApplications(rule);
},
_getInitialValueForProperty: function (property) {
if (!this._measureElement) {
this._measureElement = document.createElement('meta');
this._measureElement.style.all = 'initial';
document.head.appendChild(this._measureElement);
}
return window.getComputedStyle(this._measureElement).getPropertyValue(property);
}
};
ApplyShim._boundTransformRule = ApplyShim.transformRule.bind(ApplyShim);
ApplyShim._boundFindDefinitions = ApplyShim._findDefinitions.bind(ApplyShim);
ApplyShim._boundFindApplications = ApplyShim._findApplications.bind(ApplyShim);
return ApplyShim;
}();(function () {
var prepElement = Polymer.Base._prepElement;
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var styleExtends = Polymer.StyleExtends;
var applyShim = Polymer.ApplyShim;
var settings = Polymer.Settings;
Polymer.Base._addFeature({
_prepElement: function (element) {
if (this._encapsulateStyle && this.__cssBuild !== 'shady') {
styleTransformer.element(element, this.is, this._scopeCssViaAttr);
}
prepElement.call(this, element);
},
_prepStyles: function () {
if (this._encapsulateStyle === undefined) {
this._encapsulateStyle = !nativeShadow;
}
if (!nativeShadow) {
this._scopeStyle = styleUtil.applyStylePlaceHolder(this.is);
}
this.__cssBuild = styleUtil.cssBuildTypeForModule(this.is);
},
_prepShimStyles: function () {
if (this._template) {
var hasTargetedCssBuild = styleUtil.isTargetedBuild(this.__cssBuild);
if (settings.useNativeCSSProperties && this.__cssBuild === 'shadow' && hasTargetedCssBuild) {
if (settings.preserveStyleIncludes) {
styleUtil.styleIncludesToTemplate(this._template);
}
return;
}
this._styles = this._styles || this._collectStyles();
if (settings.useNativeCSSProperties && !this.__cssBuild) {
applyShim.transform(this._styles, this);
}
var cssText = settings.useNativeCSSProperties && hasTargetedCssBuild ? this._styles.length && this._styles[0].textContent.trim() : styleTransformer.elementStyles(this);
this._prepStyleProperties();
if (!this._needsStyleProperties() && cssText) {
styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null, this._scopeStyle);
}
} else {
this._styles = [];
}
},
_collectStyles: function () {
var styles = [];
var cssText = '', m$ = this.styleModules;
if (m$) {
for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
cssText += styleUtil.cssFromModule(m);
}
}
cssText += styleUtil.cssFromModule(this.is);
var p = this._template && this._template.parentNode;
if (this._template && (!p || p.id.toLowerCase() !== this.is)) {
cssText += styleUtil.cssFromElement(this._template);
}
if (cssText) {
var style = document.createElement('style');
style.textContent = cssText;
if (styleExtends.hasExtends(style.textContent)) {
cssText = styleExtends.transform(style);
}
styles.push(style);
}
return styles;
},
_elementAdd: function (node) {
if (this._encapsulateStyle) {
if (node.__styleScoped) {
node.__styleScoped = false;
} else {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
}
}
},
_elementRemove: function (node) {
if (this._encapsulateStyle) {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
}
},
scopeSubtree: function (container, shouldObserve) {
if (nativeShadow) {
return;
}
var self = this;
var scopify = function (node) {
if (node.nodeType === Node.ELEMENT_NODE) {
var className = node.getAttribute('class');
node.setAttribute('class', self._scopeElementClass(node, className));
var n$ = node.querySelectorAll('*');
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
className = n.getAttribute('class');
n.setAttribute('class', self._scopeElementClass(n, className));
}
}
};
scopify(container);
if (shouldObserve) {
var mo = new MutationObserver(function (mxns) {
for (var i = 0, m; i < mxns.length && (m = mxns[i]); i++) {
if (m.addedNodes) {
for (var j = 0; j < m.addedNodes.length; j++) {
scopify(m.addedNodes[j]);
}
}
}
});
mo.observe(container, {
childList: true,
subtree: true
});
return mo;
}
}
});
}());Polymer.StyleProperties = function () {
'use strict';
var matchesSelector = Polymer.DomApi.matchesSelector;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var IS_IE = navigator.userAgent.match('Trident');
var settings = Polymer.Settings;
return {
decorateStyles: function (styles, scope) {
var self = this, props = {}, keyframes = [], ruleIndex = 0;
var scopeSelector = styleTransformer._calcHostScope(scope.is, scope.extends);
styleUtil.forRulesInStyles(styles, function (rule, style) {
self.decorateRule(rule);
rule.index = ruleIndex++;
self.whenHostOrRootRule(scope, rule, style, function (info) {
if (rule.parent.type === styleUtil.ruleTypes.MEDIA_RULE) {
scope.__notStyleScopeCacheable = true;
}
if (info.isHost) {
var hostContextOrFunction = info.selector.split(' ').some(function (s) {
return s.indexOf(scopeSelector) === 0 && s.length !== scopeSelector.length;
});
scope.__notStyleScopeCacheable = scope.__notStyleScopeCacheable || hostContextOrFunction;
}
});
self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
}, function onKeyframesRule(rule) {
keyframes.push(rule);
});
styles._keyframes = keyframes;
var names = [];
for (var i in props) {
names.push(i);
}
return names;
},
decorateRule: function (rule) {
if (rule.propertyInfo) {
return rule.propertyInfo;
}
var info = {}, properties = {};
var hasProperties = this.collectProperties(rule, properties);
if (hasProperties) {
info.properties = properties;
rule.rules = null;
}
info.cssText = this.collectCssText(rule);
rule.propertyInfo = info;
return info;
},
collectProperties: function (rule, properties) {
var info = rule.propertyInfo;
if (info) {
if (info.properties) {
Polymer.Base.mixin(properties, info.properties);
return true;
}
} else {
var m, rx = this.rx.VAR_ASSIGN;
var cssText = rule.parsedCssText;
var value;
var any;
while (m = rx.exec(cssText)) {
value = (m[2] || m[3]).trim();
if (value !== 'inherit') {
properties[m[1].trim()] = value;
}
any = true;
}
return any;
}
},
collectCssText: function (rule) {
return this.collectConsumingCssText(rule.parsedCssText);
},
collectConsumingCssText: function (cssText) {
return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
},
collectPropertiesInCssText: function (cssText, props) {
var m;
while (m = this.rx.VAR_CONSUMED.exec(cssText)) {
var name = m[1];
if (m[2] !== ':') {
props[name] = true;
}
}
},
reify: function (props) {
var names = Object.getOwnPropertyNames(props);
for (var i = 0, n; i < names.length; i++) {
n = names[i];
props[n] = this.valueForProperty(props[n], props);
}
},
valueForProperty: function (property, props) {
if (property) {
if (property.indexOf(';') >= 0) {
property = this.valueForProperties(property, props);
} else {
var self = this;
var fn = function (prefix, value, fallback, suffix) {
var propertyValue = self.valueForProperty(props[value], props);
if (!propertyValue || propertyValue === 'initial') {
propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;
} else if (propertyValue === 'apply-shim-inherit') {
propertyValue = 'inherit';
}
return prefix + (propertyValue || '') + suffix;
};
property = styleUtil.processVariableAndFallback(property, fn);
}
}
return property && property.trim() || '';
},
valueForProperties: function (property, props) {
var parts = property.split(';');
for (var i = 0, p, m; i < parts.length; i++) {
if (p = parts[i]) {
this.rx.MIXIN_MATCH.lastIndex = 0;
m = this.rx.MIXIN_MATCH.exec(p);
if (m) {
p = this.valueForProperty(props[m[1]], props);
} else {
var colon = p.indexOf(':');
if (colon !== -1) {
var pp = p.substring(colon);
pp = pp.trim();
pp = this.valueForProperty(pp, props) || pp;
p = p.substring(0, colon) + pp;
}
}
parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';
}
}
return parts.join(';');
},
applyProperties: function (rule, props) {
var output = '';
if (!rule.propertyInfo) {
this.decorateRule(rule);
}
if (rule.propertyInfo.cssText) {
output = this.valueForProperties(rule.propertyInfo.cssText, props);
}
rule.cssText = output;
},
applyKeyframeTransforms: function (rule, keyframeTransforms) {
var input = rule.cssText;
var output = rule.cssText;
if (rule.hasAnimations == null) {
rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);
}
if (rule.hasAnimations) {
var transform;
if (rule.keyframeNamesToTransform == null) {
rule.keyframeNamesToTransform = [];
for (var keyframe in keyframeTransforms) {
transform = keyframeTransforms[keyframe];
output = transform(input);
if (input !== output) {
input = output;
rule.keyframeNamesToTransform.push(keyframe);
}
}
} else {
for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
input = transform(input);
}
output = input;
}
}
rule.cssText = output;
},
propertyDataFromStyles: function (styles, element) {
var props = {}, self = this;
var o = [];
styleUtil.forActiveRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
var selectorToMatch = rule.transformedSelector || rule.parsedSelector;
if (element && rule.propertyInfo.properties && selectorToMatch) {
if (matchesSelector.call(element, selectorToMatch)) {
self.collectProperties(rule, props);
addToBitMask(rule.index, o);
}
}
});
return {
properties: props,
key: o
};
},
_rootSelector: /:root|:host\s*>\s*\*/,
_checkRoot: function (hostScope, selector) {
return Boolean(selector.match(this._rootSelector)) || hostScope === 'html' && selector.indexOf('html') > -1;
},
whenHostOrRootRule: function (scope, rule, style, callback) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
if (!rule.propertyInfo.properties) {
return;
}
var hostScope = scope.is ? styleTransformer._calcHostScope(scope.is, scope.extends) : 'html';
var parsedSelector = rule.parsedSelector;
var isRoot = this._checkRoot(hostScope, parsedSelector);
var isHost = !isRoot && parsedSelector.indexOf(':host') === 0;
var cssBuild = scope.__cssBuild || style.__cssBuild;
if (cssBuild === 'shady') {
isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') > -1;
isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;
}
if (!isRoot && !isHost) {
return;
}
var selectorToMatch = hostScope;
if (isHost) {
if (settings.useNativeShadow && !rule.transformedSelector) {
rule.transformedSelector = styleTransformer._transformRuleCss(rule, styleTransformer._transformComplexSelector, scope.is, hostScope);
}
selectorToMatch = rule.transformedSelector || rule.parsedSelector;
}
if (isRoot && hostScope === 'html') {
selectorToMatch = rule.transformedSelector || rule.parsedSelector;
}
callback({
selector: selectorToMatch,
isHost: isHost,
isRoot: isRoot
});
},
hostAndRootPropertiesForScope: function (scope) {
var hostProps = {}, rootProps = {}, self = this;
styleUtil.forActiveRulesInStyles(scope._styles, function (rule, style) {
self.whenHostOrRootRule(scope, rule, style, function (info) {
var element = scope._element || scope;
if (matchesSelector.call(element, info.selector)) {
if (info.isHost) {
self.collectProperties(rule, hostProps);
} else {
self.collectProperties(rule, rootProps);
}
}
});
});
return {
rootProps: rootProps,
hostProps: hostProps
};
},
transformStyles: function (element, properties, scopeSelector) {
var self = this;
var hostSelector = styleTransformer._calcHostScope(element.is, element.extends);
var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
var keyframeTransforms = this._elementKeyframeTransforms(element, scopeSelector);
return styleTransformer.elementStyles(element, function (rule) {
self.applyProperties(rule, properties);
if (!settings.useNativeShadow && !Polymer.StyleUtil.isKeyframesSelector(rule) && rule.cssText) {
self.applyKeyframeTransforms(rule, keyframeTransforms);
self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);
}
});
},
_elementKeyframeTransforms: function (element, scopeSelector) {
var keyframesRules = element._styles._keyframes;
var keyframeTransforms = {};
if (!settings.useNativeShadow && keyframesRules) {
for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
this._scopeKeyframes(keyframesRule, scopeSelector);
keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);
}
}
return keyframeTransforms;
},
_keyframesRuleTransformer: function (keyframesRule) {
return function (cssText) {
return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);
};
},
_scopeKeyframes: function (rule, scopeId) {
rule.keyframesNameRx = new RegExp('\\b' + rule.keyframesName + '(?!\\B|-)', 'g');
rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;
rule.transformedSelector = rule.transformedSelector || rule.selector;
rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);
},
_hasDirOrHostContext: function (parsedSelector) {
return /:host-context|:dir/.test(parsedSelector);
},
_scopeSelector: function (rule, hostRx, hostSelector, viaAttr, scopeId) {
rule.transformedSelector = rule.transformedSelector || rule.selector;
var selector = rule.transformedSelector;
var scope = styleTransformer._calcElementScope(scopeId, viaAttr);
var hostScope = styleTransformer._calcElementScope(hostSelector, viaAttr);
var parts = selector.split(',');
var isDirOrHostContextSelector = this._hasDirOrHostContext(rule.parsedSelector);
for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
parts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : isDirOrHostContextSelector ? p.replace(hostScope, scope + ' ' + hostScope) : scope + ' ' + p;
}
rule.selector = parts.join(',');
},
applyElementScopeSelector: function (element, selector, old, viaAttr) {
var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.getAttribute('class') || '';
var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
if (c !== v) {
if (viaAttr) {
element.setAttribute(styleTransformer.SCOPE_NAME, v);
} else {
element.setAttribute('class', v);
}
}
},
applyElementStyle: function (element, properties, selector, style) {
var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
var s = element._customStyle;
if (s && !settings.useNativeShadow && s !== style) {
s._useCount--;
if (s._useCount <= 0 && s.parentNode) {
s.parentNode.removeChild(s);
}
}
if (settings.useNativeShadow) {
if (element._customStyle) {
element._customStyle.textContent = cssText;
style = element._customStyle;
} else if (cssText) {
style = styleUtil.applyCss(cssText, selector, element.root, element._scopeStyle);
}
} else {
if (!style) {
if (cssText) {
style = styleUtil.applyCss(cssText, selector, null, element._scopeStyle);
}
} else if (!style.parentNode) {
if (IS_IE && cssText.indexOf('@media') > -1) {
style.textContent = cssText;
}
styleUtil.applyStyle(style, null, element._scopeStyle);
}
}
if (style) {
style._useCount = style._useCount || 0;
if (element._customStyle != style) {
style._useCount++;
}
element._customStyle = style;
}
return style;
},
mixinCustomStyle: function (props, customStyle) {
var v;
for (var i in customStyle) {
v = customStyle[i];
if (v || v === 0) {
props[i] = v;
}
}
},
updateNativeStyleProperties: function (element, properties) {
var oldPropertyNames = element.__customStyleProperties;
if (oldPropertyNames) {
for (var i = 0; i < oldPropertyNames.length; i++) {
element.style.removeProperty(oldPropertyNames[i]);
}
}
var propertyNames = [];
for (var p in properties) {
if (properties[p] !== null) {
element.style.setProperty(p, properties[p]);
propertyNames.push(p);
}
}
element.__customStyleProperties = propertyNames;
},
rx: styleUtil.rx,
XSCOPE_NAME: 'x-scope'
};
function addToBitMask(n, bits) {
var o = parseInt(n / 32);
var v = 1 << n % 32;
bits[o] = (bits[o] || 0) | v;
}
}();(function () {
Polymer.StyleCache = function () {
this.cache = {};
};
Polymer.StyleCache.prototype = {
MAX: 100,
store: function (is, data, keyValues, keyStyles) {
data.keyValues = keyValues;
data.styles = keyStyles;
var s$ = this.cache[is] = this.cache[is] || [];
s$.push(data);
if (s$.length > this.MAX) {
s$.shift();
}
},
retrieve: function (is, keyValues, keyStyles) {
var cache = this.cache[is];
if (cache) {
for (var i = cache.length - 1, data; i >= 0; i--) {
data = cache[i];
if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
return data;
}
}
}
},
clear: function () {
this.cache = {};
},
_objectsEqual: function (target, source) {
var t, s;
for (var i in target) {
t = target[i], s = source[i];
if (!(typeof t === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
return false;
}
}
if (Array.isArray(target)) {
return target.length === source.length;
}
return true;
},
_objectsStrictlyEqual: function (target, source) {
return this._objectsEqual(target, source) && this._objectsEqual(source, target);
}
};
}());Polymer.StyleDefaults = function () {
var styleProperties = Polymer.StyleProperties;
var StyleCache = Polymer.StyleCache;
var nativeVariables = Polymer.Settings.useNativeCSSProperties;
var api = {
_styles: [],
_properties: null,
customStyle: {},
_styleCache: new StyleCache(),
_element: Polymer.DomApi.wrap(document.documentElement),
addStyle: function (style) {
this._styles.push(style);
this._properties = null;
},
get _styleProperties() {
if (!this._properties) {
styleProperties.decorateStyles(this._styles, this);
this._styles._scopeStyleProperties = null;
this._properties = styleProperties.hostAndRootPropertiesForScope(this).rootProps;
styleProperties.mixinCustomStyle(this._properties, this.customStyle);
styleProperties.reify(this._properties);
}
return this._properties;
},
hasStyleProperties: function () {
return Boolean(this._properties);
},
_needsStyleProperties: function () {
},
_computeStyleProperties: function () {
return this._styleProperties;
},
updateStyles: function (properties) {
this._properties = null;
if (properties) {
Polymer.Base.mixin(this.customStyle, properties);
}
this._styleCache.clear();
for (var i = 0, s; i < this._styles.length; i++) {
s = this._styles[i];
s = s.__importElement || s;
s._apply();
}
if (nativeVariables) {
styleProperties.updateNativeStyleProperties(document.documentElement, this.customStyle);
}
}
};
return api;
}();(function () {
'use strict';
var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
var propertyUtils = Polymer.StyleProperties;
var styleTransformer = Polymer.StyleTransformer;
var styleDefaults = Polymer.StyleDefaults;
var nativeShadow = Polymer.Settings.useNativeShadow;
var nativeVariables = Polymer.Settings.useNativeCSSProperties;
Polymer.Base._addFeature({
_prepStyleProperties: function () {
if (!nativeVariables) {
this._ownStylePropertyNames = this._styles && this._styles.length ? propertyUtils.decorateStyles(this._styles, this) : null;
}
},
customStyle: null,
getComputedStyleValue: function (property) {
if (!nativeVariables && !this._styleProperties) {
this._computeStyleProperties();
}
return !nativeVariables && this._styleProperties && this._styleProperties[property] || getComputedStyle(this).getPropertyValue(property);
},
_setupStyleProperties: function () {
this.customStyle = {};
this._styleCache = null;
this._styleProperties = null;
this._scopeSelector = null;
this._ownStyleProperties = null;
this._customStyle = null;
},
_needsStyleProperties: function () {
return Boolean(!nativeVariables && this._ownStylePropertyNames && this._ownStylePropertyNames.length);
},
_validateApplyShim: function () {
if (this.__applyShimInvalid) {
Polymer.ApplyShim.transform(this._styles, this.__proto__);
var cssText = styleTransformer.elementStyles(this);
if (nativeShadow) {
var templateStyle = this._template.content.querySelector('style');
if (templateStyle) {
templateStyle.textContent = cssText;
}
} else {
var shadyStyle = this._scopeStyle && this._scopeStyle.nextSibling;
if (shadyStyle) {
shadyStyle.textContent = cssText;
}
}
}
},
_beforeAttached: function () {
if ((!this._scopeSelector || this.__stylePropertiesInvalid) && this._needsStyleProperties()) {
this.__stylePropertiesInvalid = false;
this._updateStyleProperties();
}
},
_findStyleHost: function () {
var e = this, root;
while (root = Polymer.dom(e).getOwnerRoot()) {
if (Polymer.isInstance(root.host)) {
return root.host;
}
e = root.host;
}
return styleDefaults;
},
_updateStyleProperties: function () {
var info, scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
if (!scope._styleCache) {
scope._styleCache = new Polymer.StyleCache();
}
var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
var scopeCacheable = !this.__notStyleScopeCacheable;
if (scopeCacheable) {
scopeData.key.customStyle = this.customStyle;
info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
}
var scopeCached = Boolean(info);
if (scopeCached) {
this._styleProperties = info._styleProperties;
} else {
this._computeStyleProperties(scopeData.properties);
}
this._computeOwnStyleProperties();
if (!scopeCached) {
info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
}
var globalCached = Boolean(info) && !scopeCached;
var style = this._applyStyleProperties(info);
if (!scopeCached) {
style = style && nativeShadow ? style.cloneNode(true) : style;
info = {
style: style,
_scopeSelector: this._scopeSelector,
_styleProperties: this._styleProperties
};
if (scopeCacheable) {
scopeData.key.customStyle = {};
this.mixin(scopeData.key.customStyle, this.customStyle);
scope._styleCache.store(this.is, info, scopeData.key, this._styles);
}
if (!globalCached) {
styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
}
}
},
_computeStyleProperties: function (scopeProps) {
var scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
var props = Object.create(scope._styleProperties);
var hostAndRootProps = propertyUtils.hostAndRootPropertiesForScope(this);
this.mixin(props, hostAndRootProps.hostProps);
scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
this.mixin(props, scopeProps);
this.mixin(props, hostAndRootProps.rootProps);
propertyUtils.mixinCustomStyle(props, this.customStyle);
propertyUtils.reify(props);
this._styleProperties = props;
},
_computeOwnStyleProperties: function () {
var props = {};
for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
n = this._ownStylePropertyNames[i];
props[n] = this._styleProperties[n];
}
this._ownStyleProperties = props;
},
_scopeCount: 0,
_applyStyleProperties: function (info) {
var oldScopeSelector = this._scopeSelector;
this._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;
var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
if (!nativeShadow) {
propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
}
return style;
},
serializeValueToAttribute: function (value, attribute, node) {
node = node || this;
if (attribute === 'class' && !nativeShadow) {
var host = node === this ? this.domHost || this.dataHost : this;
if (host) {
value = host._scopeElementClass(node, value);
}
}
node = this.shadyRoot && this.shadyRoot._hasDistributed ? Polymer.dom(node) : node;
serializeValueToAttribute.call(this, value, attribute, node);
},
_scopeElementClass: function (element, selector) {
if (!nativeShadow && !this._scopeCssViaAttr) {
selector = (selector ? selector + ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');
}
return selector;
},
updateStyles: function (properties) {
if (properties) {
this.mixin(this.customStyle, properties);
}
if (nativeVariables) {
propertyUtils.updateNativeStyleProperties(this, this.customStyle);
} else {
if (this.isAttached) {
if (this._needsStyleProperties()) {
this._updateStyleProperties();
} else {
this._styleProperties = null;
}
} else {
this.__stylePropertiesInvalid = true;
}
if (this._styleCache) {
this._styleCache.clear();
}
this._updateRootStyles();
}
},
_updateRootStyles: function (root) {
root = root || this.root;
var c$ = Polymer.dom(root)._query(function (e) {
return e.shadyRoot || e.shadowRoot;
});
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.updateStyles) {
c.updateStyles();
}
}
}
});
Polymer.updateStyles = function (properties) {
styleDefaults.updateStyles(properties);
Polymer.Base._updateRootStyles(document);
};
var styleCache = new Polymer.StyleCache();
Polymer.customStyleCache = styleCache;
var SCOPE_NAME = styleTransformer.SCOPE_NAME;
var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
}());Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
if (this.factoryImpl) {
this._prepConstructor();
}
this._prepStyles();
},
_finishRegisterFeatures: function () {
this._prepTemplate();
this._prepShimStyles();
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepPropertyInfo();
this._prepBindings();
this._prepShady();
},
_prepBehavior: function (b) {
this._addPropertyEffects(b.properties);
this._addComplexObserverEffects(b.observers);
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._setupGestures();
this._setupConfigure(this.__data__);
this._setupStyleProperties();
this._setupDebouncers();
this._setupShady();
this._registerHost();
if (this._template) {
this._validateApplyShim();
this._poolContent();
this._beginHosting();
this._stampTemplate();
this._endHosting();
this._marshalAnnotationReferences();
}
this._marshalInstanceEffects();
this._marshalBehaviors();
this._marshalHostAttributes();
this._marshalAttributes();
this._tryReady();
},
_marshalBehavior: function (b) {
if (b.listeners) {
this._listenListeners(b.listeners);
}
}
});(function () {
var propertyUtils = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var cssParse = Polymer.CssParse;
var styleDefaults = Polymer.StyleDefaults;
var styleTransformer = Polymer.StyleTransformer;
var applyShim = Polymer.ApplyShim;
var debounce = Polymer.Debounce;
var settings = Polymer.Settings;
var updateDebouncer;
Polymer({
is: 'custom-style',
extends: 'style',
_template: null,
properties: { include: String },
ready: function () {
this.__appliedElement = this.__appliedElement || this;
this.__cssBuild = styleUtil.getCssBuildType(this);
if (this.__appliedElement !== this) {
this.__appliedElement.__cssBuild = this.__cssBuild;
}
if (this.ownerDocument !== window.document && this.__appliedElement === this) {
document.head.appendChild(this);
}
this._tryApply();
},
attached: function () {
this._tryApply();
},
_tryApply: function () {
if (!this._appliesToDocument) {
if (this.parentNode && this.parentNode.localName !== 'dom-module') {
this._appliesToDocument = true;
var e = this.__appliedElement;
if (!settings.useNativeCSSProperties) {
this.__needsUpdateStyles = styleDefaults.hasStyleProperties();
styleDefaults.addStyle(e);
}
if (e.textContent || this.include) {
this._apply(true);
} else {
var self = this;
var observer = new MutationObserver(function () {
observer.disconnect();
self._apply(true);
});
observer.observe(e, { childList: true });
}
}
}
},
_updateStyles: function () {
Polymer.updateStyles();
},
_apply: function (initialApply) {
var e = this.__appliedElement;
if (this.include) {
e.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;
}
if (!e.textContent) {
return;
}
var buildType = this.__cssBuild;
var targetedBuild = styleUtil.isTargetedBuild(buildType);
if (settings.useNativeCSSProperties && targetedBuild) {
return;
}
var styleRules = styleUtil.rulesForStyle(e);
if (!targetedBuild) {
styleUtil.forEachRule(styleRules, function (rule) {
styleTransformer.documentRule(rule);
});
if (settings.useNativeCSSProperties && !buildType) {
applyShim.transform([e]);
}
}
if (settings.useNativeCSSProperties) {
e.textContent = styleUtil.toCssText(styleRules);
} else {
var self = this;
var fn = function fn() {
self._flushCustomProperties();
};
if (initialApply) {
Polymer.RenderStatus.whenReady(fn);
} else {
fn();
}
}
},
_flushCustomProperties: function () {
if (this.__needsUpdateStyles) {
this.__needsUpdateStyles = false;
updateDebouncer = debounce(updateDebouncer, this._updateStyles);
} else {
this._applyCustomProperties();
}
},
_applyCustomProperties: function () {
var element = this.__appliedElement;
this._computeStyleProperties();
var props = this._styleProperties;
var rules = styleUtil.rulesForStyle(element);
if (!rules) {
return;
}
element.textContent = styleUtil.toCssText(rules, function (rule) {
var css = rule.cssText = rule.parsedCssText;
if (rule.propertyInfo && rule.propertyInfo.cssText) {
css = cssParse.removeCustomPropAssignment(css);
rule.cssText = propertyUtils.valueForProperties(css, props);
}
});
}
});
}());Polymer.Templatizer = {
properties: { __hideTemplateChildren__: { observer: '_showHideChildren' } },
_instanceProps: Polymer.nob,
_parentPropPrefix: '_parent_',
templatize: function (template) {
this._templatized = template;
if (!template._content) {
template._content = template.content;
}
if (template._content._ctor) {
this.ctor = template._content._ctor;
this._prepParentProperties(this.ctor.prototype, template);
return;
}
var archetype = Object.create(Polymer.Base);
this._customPrepAnnotations(archetype, template);
this._prepParentProperties(archetype, template);
archetype._prepEffects();
this._customPrepEffects(archetype);
archetype._prepBehaviors();
archetype._prepPropertyInfo();
archetype._prepBindings();
archetype._notifyPathUp = this._notifyPathUpImpl;
archetype._scopeElementClass = this._scopeElementClassImpl;
archetype.listen = this._listenImpl;
archetype._showHideChildren = this._showHideChildrenImpl;
archetype.__setPropertyOrig = this.__setProperty;
archetype.__setProperty = this.__setPropertyImpl;
var _constructor = this._constructorImpl;
var ctor = function TemplateInstance(model, host) {
_constructor.call(this, model, host);
};
ctor.prototype = archetype;
archetype.constructor = ctor;
template._content._ctor = ctor;
this.ctor = ctor;
},
_getRootDataHost: function () {
return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
},
_showHideChildrenImpl: function (hide) {
var c = this._children;
for (var i = 0; i < c.length; i++) {
var n = c[i];
if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
if (n.nodeType === Node.TEXT_NODE) {
if (hide) {
n.__polymerTextContent__ = n.textContent;
n.textContent = '';
} else {
n.textContent = n.__polymerTextContent__;
}
} else if (n.style) {
if (hide) {
n.__polymerDisplay__ = n.style.display;
n.style.display = 'none';
} else {
n.style.display = n.__polymerDisplay__;
}
}
}
n.__hideTemplateChildren__ = hide;
}
},
__setPropertyImpl: function (property, value, fromAbove, node) {
if (node && node.__hideTemplateChildren__ && property == 'textContent') {
property = '__polymerTextContent__';
}
this.__setPropertyOrig(property, value, fromAbove, node);
},
_debounceTemplate: function (fn) {
Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', fn));
},
_flushTemplates: function () {
Polymer.dom.flush();
},
_customPrepEffects: function (archetype) {
var parentProps = archetype._parentProps;
for (var prop in parentProps) {
archetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));
}
for (prop in this._instanceProps) {
archetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));
}
},
_customPrepAnnotations: function (archetype, template) {
var t = archetype._template = document.createElement('template');
var c = t._content = template._content;
if (!c._notes) {
var rootDataHost = archetype._rootDataHost;
if (rootDataHost) {
Polymer.Annotations.prepElement = function () {
rootDataHost._prepElement();
};
}
c._notes = Polymer.Annotations.parseAnnotations(template);
Polymer.Annotations.prepElement = null;
this._processAnnotations(c._notes);
}
archetype._notes = c._notes;
archetype._parentProps = c._parentProps;
},
_prepParentProperties: function (archetype, template) {
var parentProps = this._parentProps = archetype._parentProps;
if (this._forwardParentProp && parentProps) {
var proto = archetype._parentPropProto;
var prop;
if (!proto) {
for (prop in this._instanceProps) {
delete parentProps[prop];
}
proto = archetype._parentPropProto = Object.create(null);
if (template != this) {
Polymer.Bind.prepareModel(proto);
Polymer.Base.prepareModelNotifyPath(proto);
}
for (prop in parentProps) {
var parentProp = this._parentPropPrefix + prop;
var effects = [
{
kind: 'function',
effect: this._createForwardPropEffector(prop),
fn: Polymer.Bind._functionEffect
},
{
kind: 'notify',
fn: Polymer.Bind._notifyEffect,
effect: { event: Polymer.CaseMap.camelToDashCase(parentProp) + '-changed' }
}
];
proto._propertyEffects = proto._propertyEffects || {};
proto._propertyEffects[parentProp] = effects;
Polymer.Bind._createAccessors(proto, parentProp, effects);
}
}
var self = this;
if (template != this) {
Polymer.Bind.prepareInstance(template);
template._forwardParentProp = function (source, value) {
self._forwardParentProp(source, value);
};
}
this._extendTemplate(template, proto);
template._pathEffector = function (path, value, fromAbove) {
return self._pathEffectorImpl(path, value, fromAbove);
};
}
},
_createForwardPropEffector: function (prop) {
return function (source, value) {
this._forwardParentProp(prop, value);
};
},
_createHostPropEffector: function (prop) {
var prefix = this._parentPropPrefix;
return function (source, value) {
this.dataHost._templatized[prefix + prop] = value;
};
},
_createInstancePropEffector: function (prop) {
return function (source, value, old, fromAbove) {
if (!fromAbove) {
this.dataHost._forwardInstanceProp(this, prop, value);
}
};
},
_extendTemplate: function (template, proto) {
var n$ = Object.getOwnPropertyNames(proto);
if (proto._propertySetter) {
template._propertySetter = proto._propertySetter;
}
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
var val = template[n];
if (val && n == '_propertyEffects') {
var pe = Polymer.Base.mixin({}, val);
template._propertyEffects = Polymer.Base.mixin(pe, proto._propertyEffects);
} else {
var pd = Object.getOwnPropertyDescriptor(proto, n);
Object.defineProperty(template, n, pd);
if (val !== undefined) {
template._propertySetter(n, val);
}
}
}
},
_showHideChildren: function (hidden) {
},
_forwardInstancePath: function (inst, path, value) {
},
_forwardInstanceProp: function (inst, prop, value) {
},
_notifyPathUpImpl: function (path, value) {
var dataHost = this.dataHost;
var root = Polymer.Path.root(path);
dataHost._forwardInstancePath.call(dataHost, this, path, value);
if (root in dataHost._parentProps) {
dataHost._templatized._notifyPath(dataHost._parentPropPrefix + path, value);
}
},
_pathEffectorImpl: function (path, value, fromAbove) {
if (this._forwardParentPath) {
if (path.indexOf(this._parentPropPrefix) === 0) {
var subPath = path.substring(this._parentPropPrefix.length);
var model = Polymer.Path.root(subPath);
if (model in this._parentProps) {
this._forwardParentPath(subPath, value);
}
}
}
Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove);
},
_constructorImpl: function (model, host) {
this._rootDataHost = host._getRootDataHost();
this._setupConfigure(model);
this._registerHost(host);
this._beginHosting();
this.root = this.instanceTemplate(this._template);
this.root.__noContent = !this._notes._hasContent;
this.root.__styleScoped = true;
this._endHosting();
this._marshalAnnotatedNodes();
this._marshalInstanceEffects();
this._marshalAnnotatedListeners();
var children = [];
for (var n = this.root.firstChild; n; n = n.nextSibling) {
children.push(n);
n._templateInstance = this;
}
this._children = children;
if (host.__hideTemplateChildren__) {
this._showHideChildren(true);
}
this._tryReady();
},
_listenImpl: function (node, eventName, methodName) {
var model = this;
var host = this._rootDataHost;
var handler = host._createEventHandler(node, eventName, methodName);
var decorated = function (e) {
e.model = model;
handler(e);
};
host._listen(node, eventName, decorated);
},
_scopeElementClassImpl: function (node, value) {
var host = this._rootDataHost;
if (host) {
return host._scopeElementClass(node, value);
}
return value;
},
stamp: function (model) {
model = model || {};
if (this._parentProps) {
var templatized = this._templatized;
for (var prop in this._parentProps) {
if (model[prop] === undefined) {
model[prop] = templatized[this._parentPropPrefix + prop];
}
}
}
return new this.ctor(model, this);
},
modelForElement: function (el) {
var model;
while (el) {
if (model = el._templateInstance) {
if (model.dataHost != this) {
el = model.dataHost;
} else {
return model;
}
} else {
el = el.parentNode;
}
}
}
};Polymer({
is: 'dom-template',
extends: 'template',
_template: null,
behaviors: [Polymer.Templatizer],
ready: function () {
this.templatize(this);
}
});Polymer._collections = new WeakMap();
Polymer.Collection = function (userArray) {
Polymer._collections.set(userArray, this);
this.userArray = userArray;
this.store = userArray.slice();
this.initMap();
};
Polymer.Collection.prototype = {
constructor: Polymer.Collection,
initMap: function () {
var omap = this.omap = new WeakMap();
var pmap = this.pmap = {};
var s = this.store;
for (var i = 0; i < s.length; i++) {
var item = s[i];
if (item && typeof item == 'object') {
omap.set(item, i);
} else {
pmap[item] = i;
}
}
},
add: function (item) {
var key = this.store.push(item) - 1;
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
return '#' + key;
},
removeKey: function (key) {
if (key = this._parseKey(key)) {
this._removeFromMap(this.store[key]);
delete this.store[key];
}
},
_removeFromMap: function (item) {
if (item && typeof item == 'object') {
this.omap.delete(item);
} else {
delete this.pmap[item];
}
},
remove: function (item) {
var key = this.getKey(item);
this.removeKey(key);
return key;
},
getKey: function (item) {
var key;
if (item && typeof item == 'object') {
key = this.omap.get(item);
} else {
key = this.pmap[item];
}
if (key != undefined) {
return '#' + key;
}
},
getKeys: function () {
return Object.keys(this.store).map(function (key) {
return '#' + key;
});
},
_parseKey: function (key) {
if (key && key[0] == '#') {
return key.slice(1);
}
},
setItem: function (key, item) {
if (key = this._parseKey(key)) {
var old = this.store[key];
if (old) {
this._removeFromMap(old);
}
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
this.store[key] = item;
}
},
getItem: function (key) {
if (key = this._parseKey(key)) {
return this.store[key];
}
},
getItems: function () {
var items = [], store = this.store;
for (var key in store) {
items.push(store[key]);
}
return items;
},
_applySplices: function (splices) {
var keyMap = {}, key;
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
s.addedKeys = [];
for (var j = 0; j < s.removed.length; j++) {
key = this.getKey(s.removed[j]);
keyMap[key] = keyMap[key] ? null : -1;
}
for (j = 0; j < s.addedCount; j++) {
var item = this.userArray[s.index + j];
key = this.getKey(item);
key = key === undefined ? this.add(item) : key;
keyMap[key] = keyMap[key] ? null : 1;
s.addedKeys.push(key);
}
}
var removed = [];
var added = [];
for (key in keyMap) {
if (keyMap[key] < 0) {
this.removeKey(key);
removed.push(key);
}
if (keyMap[key] > 0) {
added.push(key);
}
}
return [{
removed: removed,
added: added
}];
}
};
Polymer.Collection.get = function (userArray) {
return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
};
Polymer.Collection.applySplices = function (userArray, splices) {
var coll = Polymer._collections.get(userArray);
return coll ? coll._applySplices(splices) : null;
};Polymer({
is: 'dom-repeat',
extends: 'template',
_template: null,
properties: {
items: { type: Array },
as: {
type: String,
value: 'item'
},
indexAs: {
type: String,
value: 'index'
},
sort: {
type: Function,
observer: '_sortChanged'
},
filter: {
type: Function,
observer: '_filterChanged'
},
observe: {
type: String,
observer: '_observeChanged'
},
delay: Number,
renderedItemCount: {
type: Number,
notify: !Polymer.Settings.suppressTemplateNotifications,
readOnly: true
},
initialCount: {
type: Number,
observer: '_initializeChunking'
},
targetFramerate: {
type: Number,
value: 20
},
notifyDomChange: { type: Boolean },
_targetFrameTime: {
type: Number,
computed: '_computeFrameTime(targetFramerate)'
}
},
behaviors: [Polymer.Templatizer],
observers: ['_itemsChanged(items.*)'],
created: function () {
this._instances = [];
this._pool = [];
this._limit = Infinity;
var self = this;
this._boundRenderChunk = function () {
self._renderChunk();
};
},
detached: function () {
this.__isDetached = true;
for (var i = 0; i < this._instances.length; i++) {
this._detachInstance(i);
}
},
attached: function () {
if (this.__isDetached) {
this.__isDetached = false;
var refNode;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode.localName == this.is) {
refNode = parentNode;
parentNode = Polymer.dom(parentNode).parentNode;
} else {
refNode = this;
}
var parent = Polymer.dom(parentNode);
for (var i = 0; i < this._instances.length; i++) {
this._attachInstance(i, parent, refNode);
}
}
},
ready: function () {
this._instanceProps = { __key__: true };
this._instanceProps[this.as] = true;
this._instanceProps[this.indexAs] = true;
if (!this.ctor) {
this.templatize(this);
}
},
_sortChanged: function (sort) {
var dataHost = this._getRootDataHost();
this._sortFn = sort && (typeof sort == 'function' ? sort : function () {
return dataHost[sort].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_filterChanged: function (filter) {
var dataHost = this._getRootDataHost();
this._filterFn = filter && (typeof filter == 'function' ? filter : function () {
return dataHost[filter].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_computeFrameTime: function (rate) {
return Math.ceil(1000 / rate);
},
_initializeChunking: function () {
if (this.initialCount) {
this._limit = this.initialCount;
this._chunkCount = this.initialCount;
this._lastChunkTime = performance.now();
}
},
_tryRenderChunk: function () {
if (this.items && this._limit < this.items.length) {
this.debounce('renderChunk', this._requestRenderChunk);
}
},
_requestRenderChunk: function () {
requestAnimationFrame(this._boundRenderChunk);
},
_renderChunk: function () {
var currChunkTime = performance.now();
var ratio = this._targetFrameTime / (currChunkTime - this._lastChunkTime);
this._chunkCount = Math.round(this._chunkCount * ratio) || 1;
this._limit += this._chunkCount;
this._lastChunkTime = currChunkTime;
this._debounceTemplate(this._render);
},
_observeChanged: function () {
this._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
},
_itemsChanged: function (change) {
if (change.path == 'items') {
if (Array.isArray(this.items)) {
this.collection = Polymer.Collection.get(this.items);
} else if (!this.items) {
this.collection = null;
} else {
this._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));
}
this._keySplices = [];
this._indexSplices = [];
this._needFullRefresh = true;
this._initializeChunking();
this._debounceTemplate(this._render);
} else if (change.path == 'items.splices') {
this._keySplices = this._keySplices.concat(change.value.keySplices);
this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
this._debounceTemplate(this._render);
} else {
var subpath = change.path.slice(6);
this._forwardItemPath(subpath, change.value);
this._checkObservedPaths(subpath);
}
},
_checkObservedPaths: function (path) {
if (this._observePaths) {
path = path.substring(path.indexOf('.') + 1);
var paths = this._observePaths;
for (var i = 0; i < paths.length; i++) {
if (path.indexOf(paths[i]) === 0) {
this._needFullRefresh = true;
if (this.delay) {
this.debounce('render', this._render, this.delay);
} else {
this._debounceTemplate(this._render);
}
return;
}
}
}
},
render: function () {
this._needFullRefresh = true;
this._debounceTemplate(this._render);
this._flushTemplates();
},
_render: function () {
if (this._needFullRefresh) {
this._applyFullRefresh();
this._needFullRefresh = false;
} else if (this._keySplices.length) {
if (this._sortFn) {
this._applySplicesUserSort(this._keySplices);
} else {
if (this._filterFn) {
this._applyFullRefresh();
} else {
this._applySplicesArrayOrder(this._indexSplices);
}
}
} else {
}
this._keySplices = [];
this._indexSplices = [];
var keyToIdx = this._keyToInstIdx = {};
for (var i = this._instances.length - 1; i >= 0; i--) {
var inst = this._instances[i];
if (inst.isPlaceholder && i < this._limit) {
inst = this._insertInstance(i, inst.__key__);
} else if (!inst.isPlaceholder && i >= this._limit) {
inst = this._downgradeInstance(i, inst.__key__);
}
keyToIdx[inst.__key__] = i;
if (!inst.isPlaceholder) {
inst.__setProperty(this.indexAs, i, true);
}
}
this._pool.length = 0;
this._setRenderedItemCount(this._instances.length);
if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
this.fire('dom-change');
}
this._tryRenderChunk();
},
_applyFullRefresh: function () {
var c = this.collection;
var keys;
if (this._sortFn) {
keys = c ? c.getKeys() : [];
} else {
keys = [];
var items = this.items;
if (items) {
for (var i = 0; i < items.length; i++) {
keys.push(c.getKey(items[i]));
}
}
}
var self = this;
if (this._filterFn) {
keys = keys.filter(function (a) {
return self._filterFn(c.getItem(a));
});
}
if (this._sortFn) {
keys.sort(function (a, b) {
return self._sortFn(c.getItem(a), c.getItem(b));
});
}
for (i = 0; i < keys.length; i++) {
var key = keys[i];
var inst = this._instances[i];
if (inst) {
inst.__key__ = key;
if (!inst.isPlaceholder && i < this._limit) {
inst.__setProperty(this.as, c.getItem(key), true);
}
} else if (i < this._limit) {
this._insertInstance(i, key);
} else {
this._insertPlaceholder(i, key);
}
}
for (var j = this._instances.length - 1; j >= i; j--) {
this._detachAndRemoveInstance(j);
}
},
_numericSort: function (a, b) {
return a - b;
},
_applySplicesUserSort: function (splices) {
var c = this.collection;
var keyMap = {};
var key;
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0; j < s.removed.length; j++) {
key = s.removed[j];
keyMap[key] = keyMap[key] ? null : -1;
}
for (j = 0; j < s.added.length; j++) {
key = s.added[j];
keyMap[key] = keyMap[key] ? null : 1;
}
}
var removedIdxs = [];
var addedKeys = [];
for (key in keyMap) {
if (keyMap[key] === -1) {
removedIdxs.push(this._keyToInstIdx[key]);
}
if (keyMap[key] === 1) {
addedKeys.push(key);
}
}
if (removedIdxs.length) {
removedIdxs.sort(this._numericSort);
for (i = removedIdxs.length - 1; i >= 0; i--) {
var idx = removedIdxs[i];
if (idx !== undefined) {
this._detachAndRemoveInstance(idx);
}
}
}
var self = this;
if (addedKeys.length) {
if (this._filterFn) {
addedKeys = addedKeys.filter(function (a) {
return self._filterFn(c.getItem(a));
});
}
addedKeys.sort(function (a, b) {
return self._sortFn(c.getItem(a), c.getItem(b));
});
var start = 0;
for (i = 0; i < addedKeys.length; i++) {
start = this._insertRowUserSort(start, addedKeys[i]);
}
}
},
_insertRowUserSort: function (start, key) {
var c = this.collection;
var item = c.getItem(key);
var end = this._instances.length - 1;
var idx = -1;
while (start <= end) {
var mid = start + end >> 1;
var midKey = this._instances[mid].__key__;
var cmp = this._sortFn(c.getItem(midKey), item);
if (cmp < 0) {
start = mid + 1;
} else if (cmp > 0) {
end = mid - 1;
} else {
idx = mid;
break;
}
}
if (idx < 0) {
idx = end + 1;
}
this._insertPlaceholder(idx, key);
return idx;
},
_applySplicesArrayOrder: function (splices) {
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0; j < s.removed.length; j++) {
this._detachAndRemoveInstance(s.index);
}
for (j = 0; j < s.addedKeys.length; j++) {
this._insertPlaceholder(s.index + j, s.addedKeys[j]);
}
}
},
_detachInstance: function (idx) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
for (var i = 0; i < inst._children.length; i++) {
var el = inst._children[i];
Polymer.dom(inst.root).appendChild(el);
}
return inst;
}
},
_attachInstance: function (idx, parent, refNode) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
parent.insertBefore(inst.root, refNode);
}
},
_detachAndRemoveInstance: function (idx) {
var inst = this._detachInstance(idx);
if (inst) {
this._pool.push(inst);
}
this._instances.splice(idx, 1);
},
_insertPlaceholder: function (idx, key) {
this._instances.splice(idx, 0, {
isPlaceholder: true,
__key__: key
});
},
_stampInstance: function (idx, key) {
var model = { __key__: key };
model[this.as] = this.collection.getItem(key);
model[this.indexAs] = idx;
return this.stamp(model);
},
_insertInstance: function (idx, key) {
var inst = this._pool.pop();
if (inst) {
inst.__setProperty(this.as, this.collection.getItem(key), true);
inst.__setProperty('__key__', key, true);
} else {
inst = this._stampInstance(idx, key);
}
var beforeRow = this._instances[idx + 1];
var beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode.localName == this.is) {
if (beforeNode == this) {
beforeNode = parentNode;
}
parentNode = Polymer.dom(parentNode).parentNode;
}
Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
this._instances[idx] = inst;
return inst;
},
_downgradeInstance: function (idx, key) {
var inst = this._detachInstance(idx);
if (inst) {
this._pool.push(inst);
}
inst = {
isPlaceholder: true,
__key__: key
};
this._instances[idx] = inst;
return inst;
},
_showHideChildren: function (hidden) {
for (var i = 0; i < this._instances.length; i++) {
if (!this._instances[i].isPlaceholder)
this._instances[i]._showHideChildren(hidden);
}
},
_forwardInstanceProp: function (inst, prop, value) {
if (prop == this.as) {
var idx;
if (this._sortFn || this._filterFn) {
idx = this.items.indexOf(this.collection.getItem(inst.__key__));
} else {
idx = inst[this.indexAs];
}
this.set('items.' + idx, value);
}
},
_forwardInstancePath: function (inst, path, value) {
if (path.indexOf(this.as + '.') === 0) {
this._notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);
}
},
_forwardParentProp: function (prop, value) {
var i$ = this._instances;
for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
if (!inst.isPlaceholder) {
inst.__setProperty(prop, value, true);
}
}
},
_forwardParentPath: function (path, value) {
var i$ = this._instances;
for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
if (!inst.isPlaceholder) {
inst._notifyPath(path, value, true);
}
}
},
_forwardItemPath: function (path, value) {
if (this._keyToInstIdx) {
var dot = path.indexOf('.');
var key = path.substring(0, dot < 0 ? path.length : dot);
var idx = this._keyToInstIdx[key];
var inst = this._instances[idx];
if (inst && !inst.isPlaceholder) {
if (dot >= 0) {
path = this.as + '.' + path.substring(dot + 1);
inst._notifyPath(path, value, true);
} else {
inst.__setProperty(this.as, value, true);
}
}
}
},
itemForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.as];
},
keyForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance.__key__;
},
indexForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.indexAs];
}
});Polymer({
is: 'array-selector',
_template: null,
properties: {
items: {
type: Array,
observer: 'clearSelection'
},
multi: {
type: Boolean,
value: false,
observer: 'clearSelection'
},
selected: {
type: Object,
notify: true
},
selectedItem: {
type: Object,
notify: true
},
toggle: {
type: Boolean,
value: false
}
},
clearSelection: function () {
if (Array.isArray(this.selected)) {
for (var i = 0; i < this.selected.length; i++) {
this.unlinkPaths('selected.' + i);
}
} else {
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
if (this.multi) {
if (!this.selected || this.selected.length) {
this.selected = [];
this._selectedColl = Polymer.Collection.get(this.selected);
}
} else {
this.selected = null;
this._selectedColl = null;
}
this.selectedItem = null;
},
isSelected: function (item) {
if (this.multi) {
return this._selectedColl.getKey(item) !== undefined;
} else {
return this.selected == item;
}
},
deselect: function (item) {
if (this.multi) {
if (this.isSelected(item)) {
var skey = this._selectedColl.getKey(item);
this.arrayDelete('selected', item);
this.unlinkPaths('selected.' + skey);
}
} else {
this.selected = null;
this.selectedItem = null;
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
},
select: function (item) {
var icol = Polymer.Collection.get(this.items);
var key = icol.getKey(item);
if (this.multi) {
if (this.isSelected(item)) {
if (this.toggle) {
this.deselect(item);
}
} else {
this.push('selected', item);
var skey = this._selectedColl.getKey(item);
this.linkPaths('selected.' + skey, 'items.' + key);
}
} else {
if (this.toggle && item == this.selected) {
this.deselect();
} else {
this.selected = item;
this.selectedItem = item;
this.linkPaths('selected', 'items.' + key);
this.linkPaths('selectedItem', 'items.' + key);
}
}
}
});Polymer({
is: 'dom-if',
extends: 'template',
_template: null,
properties: {
'if': {
type: Boolean,
value: false,
observer: '_queueRender'
},
restamp: {
type: Boolean,
value: false,
observer: '_queueRender'
},
notifyDomChange: { type: Boolean }
},
behaviors: [Polymer.Templatizer],
_queueRender: function () {
this._debounceTemplate(this._render);
},
detached: function () {
var parentNode = this.parentNode;
if (parentNode && parentNode.localName == this.is) {
parentNode = Polymer.dom(parentNode).parentNode;
}
if (!parentNode || parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && (!Polymer.Settings.hasShadow || !(parentNode instanceof ShadowRoot))) {
this._teardownInstance();
}
},
attached: function () {
if (this.if && this.ctor) {
this.async(this._ensureInstance);
}
},
render: function () {
this._flushTemplates();
},
_render: function () {
if (this.if) {
if (!this.ctor) {
this.templatize(this);
}
this._ensureInstance();
this._showHideChildren();
} else if (this.restamp) {
this._teardownInstance();
}
if (!this.restamp && this._instance) {
this._showHideChildren();
}
if (this.if != this._lastIf) {
if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
this.fire('dom-change');
}
this._lastIf = this.if;
}
},
_ensureInstance: function () {
var refNode;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode && parentNode.localName == this.is) {
refNode = parentNode;
parentNode = Polymer.dom(parentNode).parentNode;
} else {
refNode = this;
}
if (parentNode) {
if (!this._instance) {
this._instance = this.stamp();
var root = this._instance.root;
Polymer.dom(parentNode).insertBefore(root, refNode);
} else {
var c$ = this._instance._children;
if (c$ && c$.length) {
var lastChild = Polymer.dom(refNode).previousSibling;
if (lastChild !== c$[c$.length - 1]) {
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
Polymer.dom(parentNode).insertBefore(n, refNode);
}
}
}
}
}
},
_teardownInstance: function () {
if (this._instance) {
var c$ = this._instance._children;
if (c$ && c$.length) {
var parent = Polymer.dom(Polymer.dom(c$[0]).parentNode);
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
parent.removeChild(n);
}
}
this._instance = null;
}
},
_showHideChildren: function () {
var hidden = this.__hideTemplateChildren__ || !this.if;
if (this._instance) {
this._instance._showHideChildren(hidden);
}
},
_forwardParentProp: function (prop, value) {
if (this._instance) {
this._instance.__setProperty(prop, value, true);
}
},
_forwardParentPath: function (path, value) {
if (this._instance) {
this._instance._notifyPath(path, value, true);
}
}
});Polymer({
is: 'dom-bind',
properties: { notifyDomChange: { type: Boolean } },
extends: 'template',
_template: null,
created: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
if (document.readyState == 'loading') {
document.addEventListener('DOMContentLoaded', function () {
self._markImportsReady();
});
} else {
self._markImportsReady();
}
});
},
_ensureReady: function () {
if (!this._readied) {
this._readySelf();
}
},
_markImportsReady: function () {
this._importsReady = true;
this._ensureReady();
},
_registerFeatures: function () {
this._prepConstructor();
},
_insertChildren: function () {
var refNode;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode.localName == this.is) {
refNode = parentNode;
parentNode = Polymer.dom(parentNode).parentNode;
} else {
refNode = this;
}
Polymer.dom(parentNode).insertBefore(this.root, refNode);
},
_removeChildren: function () {
if (this._children) {
for (var i = 0; i < this._children.length; i++) {
this.root.appendChild(this._children[i]);
}
}
},
_initFeatures: function () {
},
_scopeElementClass: function (element, selector) {
if (this.dataHost) {
return this.dataHost._scopeElementClass(element, selector);
} else {
return selector;
}
},
_configureInstanceProperties: function () {
},
_prepConfigure: function () {
var config = {};
for (var prop in this._propertyEffects) {
config[prop] = this[prop];
}
var setupConfigure = this._setupConfigure;
this._setupConfigure = function () {
setupConfigure.call(this, config);
};
},
attached: function () {
if (this._importsReady) {
this.render();
}
},
detached: function () {
this._removeChildren();
},
render: function () {
this._ensureReady();
if (!this._children) {
this._template = this;
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepConfigure();
this._prepBindings();
this._prepPropertyInfo();
Polymer.Base._initFeatures.call(this);
this._children = Polymer.TreeApi.arrayCopyChildNodes(this.root);
}
this._insertChildren();
if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
this.fire('dom-change');
}
}
});</script>









<script>
  // This is left only for backward compatibility with projects
  // that incorrectly relied on unscoped global [hidden] rules;
  // removing would be a breaking change, but new projects
  // should never rely on this.
  (function() {
    var style = document.createElement('style');
    style.textContent = '[hidden] { display: none !important; }';
    document.head.appendChild(style);
  })();
</script>
<style is="custom-style">
  [hidden] {
    display: none !important;
  }
</style>

<style is="custom-style">
  :root {

    --layout: {
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;
    };

    --layout-inline: {
      display: -ms-inline-flexbox;
      display: -webkit-inline-flex;
      display: inline-flex;
    };

    --layout-horizontal: {
      @apply(--layout);

      -ms-flex-direction: row;
      -webkit-flex-direction: row;
      flex-direction: row;
    };

    --layout-horizontal-reverse: {
      @apply(--layout);

      -ms-flex-direction: row-reverse;
      -webkit-flex-direction: row-reverse;
      flex-direction: row-reverse;
    };

    --layout-vertical: {
      @apply(--layout);

      -ms-flex-direction: column;
      -webkit-flex-direction: column;
      flex-direction: column;
    };

    --layout-vertical-reverse: {
      @apply(--layout);

      -ms-flex-direction: column-reverse;
      -webkit-flex-direction: column-reverse;
      flex-direction: column-reverse;
    };

    --layout-wrap: {
      -ms-flex-wrap: wrap;
      -webkit-flex-wrap: wrap;
      flex-wrap: wrap;
    };

    --layout-no-wrap: {
      -ms-flex-wrap: nowrap;
      -webkit-flex-wrap: nowrap;
      flex-wrap: nowrap;
    };

    --layout-wrap-reverse: {
      -ms-flex-wrap: wrap-reverse;
      -webkit-flex-wrap: wrap-reverse;
      flex-wrap: wrap-reverse;
    };

    --layout-flex-auto: {
      -ms-flex: 1 1 auto;
      -webkit-flex: 1 1 auto;
      flex: 1 1 auto;
    };

    --layout-flex-none: {
      -ms-flex: none;
      -webkit-flex: none;
      flex: none;
    };

    --layout-flex: {
      -ms-flex: 1 1 0.000000001px;
      -webkit-flex: 1;
      flex: 1;
      -webkit-flex-basis: 0.000000001px;
      flex-basis: 0.000000001px;
    };

    --layout-flex-2: {
      -ms-flex: 2;
      -webkit-flex: 2;
      flex: 2;
    };

    --layout-flex-3: {
      -ms-flex: 3;
      -webkit-flex: 3;
      flex: 3;
    };

    --layout-flex-4: {
      -ms-flex: 4;
      -webkit-flex: 4;
      flex: 4;
    };

    --layout-flex-5: {
      -ms-flex: 5;
      -webkit-flex: 5;
      flex: 5;
    };

    --layout-flex-6: {
      -ms-flex: 6;
      -webkit-flex: 6;
      flex: 6;
    };

    --layout-flex-7: {
      -ms-flex: 7;
      -webkit-flex: 7;
      flex: 7;
    };

    --layout-flex-8: {
      -ms-flex: 8;
      -webkit-flex: 8;
      flex: 8;
    };

    --layout-flex-9: {
      -ms-flex: 9;
      -webkit-flex: 9;
      flex: 9;
    };

    --layout-flex-10: {
      -ms-flex: 10;
      -webkit-flex: 10;
      flex: 10;
    };

    --layout-flex-11: {
      -ms-flex: 11;
      -webkit-flex: 11;
      flex: 11;
    };

    --layout-flex-12: {
      -ms-flex: 12;
      -webkit-flex: 12;
      flex: 12;
    };

    /* alignment in cross axis */

    --layout-start: {
      -ms-flex-align: start;
      -webkit-align-items: flex-start;
      align-items: flex-start;
    };

    --layout-center: {
      -ms-flex-align: center;
      -webkit-align-items: center;
      align-items: center;
    };

    --layout-end: {
      -ms-flex-align: end;
      -webkit-align-items: flex-end;
      align-items: flex-end;
    };

    --layout-baseline: {
      -ms-flex-align: baseline;
      -webkit-align-items: baseline;
      align-items: baseline;
    };

    /* alignment in main axis */

    --layout-start-justified: {
      -ms-flex-pack: start;
      -webkit-justify-content: flex-start;
      justify-content: flex-start;
    };

    --layout-center-justified: {
      -ms-flex-pack: center;
      -webkit-justify-content: center;
      justify-content: center;
    };

    --layout-end-justified: {
      -ms-flex-pack: end;
      -webkit-justify-content: flex-end;
      justify-content: flex-end;
    };

    --layout-around-justified: {
      -ms-flex-pack: distribute;
      -webkit-justify-content: space-around;
      justify-content: space-around;
    };

    --layout-justified: {
      -ms-flex-pack: justify;
      -webkit-justify-content: space-between;
      justify-content: space-between;
    };

    --layout-center-center: {
      @apply(--layout-center);
      @apply(--layout-center-justified);
    };

    /* self alignment */

    --layout-self-start: {
      -ms-align-self: flex-start;
      -webkit-align-self: flex-start;
      align-self: flex-start;
    };

    --layout-self-center: {
      -ms-align-self: center;
      -webkit-align-self: center;
      align-self: center;
    };

    --layout-self-end: {
      -ms-align-self: flex-end;
      -webkit-align-self: flex-end;
      align-self: flex-end;
    };

    --layout-self-stretch: {
      -ms-align-self: stretch;
      -webkit-align-self: stretch;
      align-self: stretch;
    };

    --layout-self-baseline: {
      -ms-align-self: baseline;
      -webkit-align-self: baseline;
      align-self: baseline;
    };

    /* multi-line alignment in main axis */

    --layout-start-aligned: {
      -ms-flex-line-pack: start;  /* IE10 */
      -ms-align-content: flex-start;
      -webkit-align-content: flex-start;
      align-content: flex-start;
    };

    --layout-end-aligned: {
      -ms-flex-line-pack: end;  /* IE10 */
      -ms-align-content: flex-end;
      -webkit-align-content: flex-end;
      align-content: flex-end;
    };

    --layout-center-aligned: {
      -ms-flex-line-pack: center;  /* IE10 */
      -ms-align-content: center;
      -webkit-align-content: center;
      align-content: center;
    };

    --layout-between-aligned: {
      -ms-flex-line-pack: justify;  /* IE10 */
      -ms-align-content: space-between;
      -webkit-align-content: space-between;
      align-content: space-between;
    };

    --layout-around-aligned: {
      -ms-flex-line-pack: distribute;  /* IE10 */
      -ms-align-content: space-around;
      -webkit-align-content: space-around;
      align-content: space-around;
    };

    /*******************************
              Other Layout
    *******************************/

    --layout-block: {
      display: block;
    };

    --layout-invisible: {
      visibility: hidden !important;
    };

    --layout-relative: {
      position: relative;
    };

    --layout-fit: {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    };

    --layout-scroll: {
      -webkit-overflow-scrolling: touch;
      overflow: auto;
    };

    --layout-fullbleed: {
      margin: 0;
      height: 100vh;
    };

    /* fixed position */

    --layout-fixed-top: {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
    };

    --layout-fixed-right: {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
    };

    --layout-fixed-bottom: {
      position: fixed;
      right: 0;
      bottom: 0;
      left: 0;
    };

    --layout-fixed-left: {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
    };

  }

</style>
<dom-module id="app-drawer" assetpath="bower_components/app-layout/app-drawer/">
  <template>
    <style>
      :host {
        position: fixed;
        top: -120px;
        right: 0;
        bottom: -120px;
        left: 0;

        visibility: hidden;

        transition-property: visibility;
      }

      :host([opened]) {
        visibility: visible;
      }

      :host([persistent]) {
        width: var(--app-drawer-width, 256px);
      }

      :host([persistent][position=left]) {
        right: auto;
      }

      :host([persistent][position=right]) {
        left: auto;
      }

      #contentContainer {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;

        width: var(--app-drawer-width, 256px);
        padding: 120px 0;

        transition-property: -webkit-transform;
        transition-property: transform;
        -webkit-transform: translate3d(-100%, 0, 0);
        transform: translate3d(-100%, 0, 0);

        background-color: #FFF;

        @apply(--app-drawer-content-container);
      }

      :host([position=right]) > #contentContainer {
        right: 0;
        left: auto;

        -webkit-transform: translate3d(100%, 0, 0);
        transform: translate3d(100%, 0, 0);
      }

      :host([swipe-open]) > #contentContainer::after {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 100%;

        visibility: visible;

        width: 20px;

        content: '';
      }

      :host([swipe-open][position=right]) > #contentContainer::after {
        right: 100%;
        left: auto;
      }

      :host([opened]) > #contentContainer {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
      }

      #scrim {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;

        transition-property: opacity;
        -webkit-transform: translateZ(0);
        transform:  translateZ(0);

        opacity: 0;
        background: var(--app-drawer-scrim-background, rgba(0, 0, 0, 0.5));
      }

      :host([opened]) > #scrim {
        opacity: 1;
      }

      :host([opened][persistent]) > #scrim {
        visibility: hidden;
        /**
         * NOTE(keanulee): Keep both opacity: 0 and visibility: hidden to prevent the
         * scrim from showing when toggling between closed and opened/persistent.
         */

        opacity: 0;
      }
    </style>

    <div id="scrim" on-tap="close"></div>

    <div id="contentContainer">
      <content></content>
    </div>
  </template>

  <script>

    Polymer({
      is: 'app-drawer',

      properties: {
        /**
         * The opened state of the drawer.
         */
        opened: {
          type: Boolean,
          value: false,
          notify: true,
          reflectToAttribute: true
        },

        /**
         * The drawer does not have a scrim and cannot be swiped close.
         */
        persistent: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },

        /**
         * The transition duration of the drawer in milliseconds.
         */
        transitionDuration: {
          type: Number,
          value: 200
        },

        /**
         * The alignment of the drawer on the screen ('left', 'right', 'start' or 'end').
         * 'start' computes to left and 'end' to right in LTR layout and vice versa in RTL
         * layout.
         */
        align: {
          type: String,
          value: 'left'
        },

        /**
         * The computed, read-only position of the drawer on the screen ('left' or 'right').
         */
        position: {
          type: String,
          readOnly: true,
          reflectToAttribute: true
        },

        /**
         * Create an area at the edge of the screen to swipe open the drawer.
         */
        swipeOpen: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },

        /**
         * Trap keyboard focus when the drawer is opened and not persistent.
         */
        noFocusTrap: {
          type: Boolean,
          value: false
        },

        /**
         * Disables swiping on the drawer.
         */
        disableSwipe: {
          type: Boolean,
          value: false
        }
      },

      observers: [
        'resetLayout(position, isAttached)',
        '_resetPosition(align, isAttached)',
        '_styleTransitionDuration(transitionDuration)',
        '_openedPersistentChanged(opened, persistent)'
      ],

      _translateOffset: 0,

      _trackDetails: null,

      _drawerState: 0,

      _boundEscKeydownHandler: null,

      _firstTabStop: null,

      _lastTabStop: null,

      attached: function() {
        // Only transition the drawer after its first render (e.g. app-drawer-layout
        // may need to set the initial opened state which should not be transitioned).
        this._styleTransitionDuration(0);
        Polymer.RenderStatus.afterNextRender(this, function() {
          this._styleTransitionDuration(this.transitionDuration);
          this._boundEscKeydownHandler = this._escKeydownHandler.bind(this);
          this.addEventListener('keydown', this._tabKeydownHandler.bind(this))

          // Only listen for horizontal track so you can vertically scroll inside the drawer.
          this.listen(this, 'track', '_track');
          this.setScrollDirection('y');
        });

        this.fire('app-drawer-attached');
      },

      detached: function() {
        document.removeEventListener('keydown', this._boundEscKeydownHandler);
      },

      /**
       * Opens the drawer.
       */
      open: function() {
        this.opened = true;
      },

      /**
       * Closes the drawer.
       */
      close: function() {
        this.opened = false;
      },

      /**
       * Toggles the drawer open and close.
       */
      toggle: function() {
        this.opened = !this.opened;
      },

      /**
       * Gets the width of the drawer.
       *
       * @return {number} The width of the drawer in pixels.
       */
      getWidth: function() {
        return this.$.contentContainer.offsetWidth;
      },

      /**
       * Resets the layout. The event fired is used by app-drawer-layout to position the
       * content.
       *
       * @method resetLayout
       */
      resetLayout: function() {
        this.fire('app-drawer-reset-layout');
      },

      _isRTL: function() {
        return window.getComputedStyle(this).direction === 'rtl';
      },

      _resetPosition: function() {
        switch (this.align) {
          case 'start':
            this._setPosition(this._isRTL() ? 'right' : 'left');
            return;
          case 'end':
            this._setPosition(this._isRTL() ? 'left' : 'right');
            return;
        }
        this._setPosition(this.align);
      },

      _escKeydownHandler: function(event) {
        var ESC_KEYCODE = 27;
        if (event.keyCode === ESC_KEYCODE) {
          // Prevent any side effects if app-drawer closes.
          event.preventDefault();
          this.close();
        }
      },

      _track: function(event) {
        if (this.persistent || this.disableSwipe) {
          return;
        }

        // Disable user selection on desktop.
        event.preventDefault();

        switch (event.detail.state) {
          case 'start':
            this._trackStart(event);
            break;
          case 'track':
            this._trackMove(event);
            break;
          case 'end':
            this._trackEnd(event);
            break;
        }
      },

      _trackStart: function(event) {
        this._drawerState = this._DRAWER_STATE.TRACKING;

        // Disable transitions since style attributes will reflect user track events.
        this._styleTransitionDuration(0);
        this.style.visibility = 'visible';

        var rect = this.$.contentContainer.getBoundingClientRect();
        if (this.position === 'left') {
          this._translateOffset = rect.left;
        } else {
          this._translateOffset = rect.right - window.innerWidth;
        }

        this._trackDetails = [];
      },

      _trackMove: function(event) {
        this._translateDrawer(event.detail.dx + this._translateOffset);

        // Use Date.now() since event.timeStamp is inconsistent across browsers (e.g. most
        // browsers use milliseconds but FF 44 uses microseconds).
        this._trackDetails.push({
          dx: event.detail.dx,
          timeStamp: Date.now()
        });
      },

      _trackEnd: function(event) {
        var x = event.detail.dx + this._translateOffset;
        var drawerWidth = this.getWidth();
        var isPositionLeft = this.position === 'left';
        var isInEndState = isPositionLeft ? (x >= 0 || x <= -drawerWidth) :
          (x <= 0 || x >= drawerWidth);

        if (!isInEndState) {
          // No longer need the track events after this method returns - allow them to be GC'd.
          var trackDetails = this._trackDetails;
          this._trackDetails = null;

          this._flingDrawer(event, trackDetails);
          if (this._drawerState === this._DRAWER_STATE.FLINGING) {
            return;
          }
        }

        // If the drawer is not flinging, toggle the opened state based on the position of
        // the drawer.
        var halfWidth = drawerWidth / 2;
        if (event.detail.dx < -halfWidth) {
          this.opened = this.position === 'right';
        } else if (event.detail.dx > halfWidth) {
          this.opened = this.position === 'left';
        }

        if (isInEndState) {
          this.debounce('_resetDrawerState', this._resetDrawerState);
        } else {
          this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);
        }

        this._styleTransitionDuration(this.transitionDuration);
        this._resetDrawerTranslate();
        this.style.visibility = '';
      },

      _calculateVelocity: function(event, trackDetails) {
        // Find the oldest track event that is within 100ms using binary search.
        var now = Date.now();
        var timeLowerBound = now - 100;
        var trackDetail;
        var min = 0;
        var max = trackDetails.length - 1;

        while (min <= max) {
          // Floor of average of min and max.
          var mid = (min + max) >> 1;
          var d = trackDetails[mid];
          if (d.timeStamp >= timeLowerBound) {
            trackDetail = d;
            max = mid - 1;
          } else {
            min = mid + 1;
          }
        }

        if (trackDetail) {
          var dx = event.detail.dx - trackDetail.dx;
          var dt = (now - trackDetail.timeStamp) || 1;
          return dx / dt;
        }
        return 0;
      },

      _flingDrawer: function(event, trackDetails) {
        var velocity = this._calculateVelocity(event, trackDetails);

        // Do not fling if velocity is not above a threshold.
        if (Math.abs(velocity) < this._MIN_FLING_THRESHOLD) {
          return;
        }

        this._drawerState = this._DRAWER_STATE.FLINGING;

        var x = event.detail.dx + this._translateOffset;
        var drawerWidth = this.getWidth();
        var isPositionLeft = this.position === 'left';
        var isVelocityPositive = velocity > 0;
        var isClosingLeft = !isVelocityPositive && isPositionLeft;
        var isClosingRight = isVelocityPositive && !isPositionLeft;
        var dx;
        if (isClosingLeft) {
          dx = -(x + drawerWidth);
        } else if (isClosingRight) {
          dx = (drawerWidth - x);
        } else {
          dx = -x;
        }

        // Enforce a minimum transition velocity to make the drawer feel snappy.
        if (isVelocityPositive) {
          velocity = Math.max(velocity, this._MIN_TRANSITION_VELOCITY);
          this.opened = this.position === 'left';
        } else {
          velocity = Math.min(velocity, -this._MIN_TRANSITION_VELOCITY);
          this.opened = this.position === 'right';
        }

        // Calculate the amount of time needed to finish the transition based on the
        // initial slope of the timing function.
        var t = this._FLING_INITIAL_SLOPE * dx / velocity
        this._styleTransitionDuration(t);
        this._styleTransitionTimingFunction(this._FLING_TIMING_FUNCTION);

        this._resetDrawerTranslate();
        this.debounce('_resetDrawerState', this._resetDrawerState, t);
      },

      _styleTransitionDuration: function(duration) {
        this.style.transitionDuration = duration + 'ms';
        this.$.contentContainer.style.transitionDuration = duration + 'ms';
        this.$.scrim.style.transitionDuration = duration + 'ms';
      },

      _styleTransitionTimingFunction: function(timingFunction) {
        this.$.contentContainer.style.transitionTimingFunction = timingFunction;
        this.$.scrim.style.transitionTimingFunction = timingFunction;
      },

      _translateDrawer: function(x) {
        var drawerWidth = this.getWidth();

        if (this.position === 'left') {
          x = Math.max(-drawerWidth, Math.min(x, 0));
          this.$.scrim.style.opacity = 1 + x / drawerWidth;
        } else {
          x = Math.max(0, Math.min(x, drawerWidth));
          this.$.scrim.style.opacity = 1 - x / drawerWidth;
        }

        this.translate3d(x + 'px', '0', '0', this.$.contentContainer);
      },

      _resetDrawerTranslate: function() {
        this.$.scrim.style.opacity = '';
        this.transform('', this.$.contentContainer);
      },

      _resetDrawerState: function() {
        var oldState = this._drawerState;

        // If the drawer was flinging, we need to reset the style attributes.
        if (oldState === this._DRAWER_STATE.FLINGING) {
          this._styleTransitionDuration(this.transitionDuration);
          this._styleTransitionTimingFunction('');
          this.style.visibility = '';
        }

        if (this.opened) {
          this._drawerState = this.persistent ?
            this._DRAWER_STATE.OPENED_PERSISTENT : this._DRAWER_STATE.OPENED;
        } else {
          this._drawerState = this._DRAWER_STATE.CLOSED;
        }

        if (oldState !== this._drawerState) {
          if (this._drawerState === this._DRAWER_STATE.OPENED) {
            this._setKeyboardFocusTrap();
            document.addEventListener('keydown', this._boundEscKeydownHandler);
            document.body.style.overflow = 'hidden';
          } else {
            document.removeEventListener('keydown', this._boundEscKeydownHandler);
            document.body.style.overflow = '';
          }

          // Don't fire the event on initial load.
          if (oldState !== this._DRAWER_STATE.INIT) {
            this.fire('app-drawer-transitioned');
          }
        }
      },

      _setKeyboardFocusTrap: function() {
        if (this.noFocusTrap) {
          return;
        }

        // NOTE: Unless we use /deep/ (which we shouldn't since it's deprecated), this will
        // not select focusable elements inside shadow roots.
        var focusableElementsSelector = [
            'a[href]:not([tabindex="-1"])',
            'area[href]:not([tabindex="-1"])',
            'input:not([disabled]):not([tabindex="-1"])',
            'select:not([disabled]):not([tabindex="-1"])',
            'textarea:not([disabled]):not([tabindex="-1"])',
            'button:not([disabled]):not([tabindex="-1"])',
            'iframe:not([tabindex="-1"])',
            '[tabindex]:not([tabindex="-1"])',
            '[contentEditable=true]:not([tabindex="-1"])'
          ].join(',');
        var focusableElements = Polymer.dom(this).querySelectorAll(focusableElementsSelector);

        if (focusableElements.length > 0) {
          this._firstTabStop = focusableElements[0];
          this._lastTabStop = focusableElements[focusableElements.length - 1];
        } else {
          // Reset saved tab stops when there are no focusable elements in the drawer.
          this._firstTabStop = null;
          this._lastTabStop = null;
        }

        // Focus on app-drawer if it has non-zero tabindex. Otherwise, focus the first focusable
        // element in the drawer, if it exists. Use the tabindex attribute since the this.tabIndex
        // property in IE/Edge returns 0 (instead of -1) when the attribute is not set.
        var tabindex = this.getAttribute('tabindex');
        if (tabindex && parseInt(tabindex, 10) > -1) {
          this.focus();
        } else if (this._firstTabStop) {
          this._firstTabStop.focus();
        }
      },

      _tabKeydownHandler: function(event) {
        if (this.noFocusTrap) {
          return;
        }

        var TAB_KEYCODE = 9;
        if (this._drawerState === this._DRAWER_STATE.OPENED && event.keyCode === TAB_KEYCODE) {
          if (event.shiftKey) {
            if (this._firstTabStop && Polymer.dom(event).localTarget === this._firstTabStop) {
              event.preventDefault();
              this._lastTabStop.focus();
            }
          } else {
            if (this._lastTabStop && Polymer.dom(event).localTarget === this._lastTabStop) {
              event.preventDefault();
              this._firstTabStop.focus();
            }
          }
        }
      },

      _openedPersistentChanged: function() {
        // Use a debounce timer instead of transitionend since transitionend won't fire when
        // app-drawer is display: none.
        this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);
      },

      _MIN_FLING_THRESHOLD: 0.2,

      _MIN_TRANSITION_VELOCITY: 1.2,

      _FLING_TIMING_FUNCTION: 'cubic-bezier(0.667, 1, 0.667, 1)',

      _FLING_INITIAL_SLOPE: 1.5,

      _DRAWER_STATE: {
        INIT: 0,
        OPENED: 1,
        OPENED_PERSISTENT: 2,
        CLOSED: 3,
        TRACKING: 4,
        FLINGING: 5
      }

      /**
       * Fired when the layout of app-drawer is attached.
       *
       * @event app-drawer-attached
       */

      /**
       * Fired when the layout of app-drawer has changed.
       *
       * @event app-drawer-reset-layout
       */

      /**
       * Fired when app-drawer has finished transitioning.
       *
       * @event app-drawer-transitioned
       */
    });
  </script>
</dom-module>
<script>

  Polymer({

    is: 'iron-media-query',

    properties: {

      /**
       * The Boolean return value of the media query.
       */
      queryMatches: {
        type: Boolean,
        value: false,
        readOnly: true,
        notify: true
      },

      /**
       * The CSS media query to evaluate.
       */
      query: {
        type: String,
        observer: 'queryChanged'
      },

      /**
       * If true, the query attribute is assumed to be a complete media query
       * string rather than a single media feature.
       */
      full: {
        type: Boolean,
        value: false
      },

      /**
       * @type {function(MediaQueryList)}
       */
      _boundMQHandler: {
        value: function() {
          return this.queryHandler.bind(this);
        }
      },

      /**
       * @type {MediaQueryList}
       */
      _mq: {
        value: null
      }
    },

    attached: function() {
      this.style.display = 'none';
      this.queryChanged();
    },

    detached: function() {
      this._remove();
    },

    _add: function() {
      if (this._mq) {
        this._mq.addListener(this._boundMQHandler);
      }
    },

    _remove: function() {
      if (this._mq) {
        this._mq.removeListener(this._boundMQHandler);
      }
      this._mq = null;
    },

    queryChanged: function() {
      this._remove();
      var query = this.query;
      if (!query) {
        return;
      }
      if (!this.full && query[0] !== '(') {
        query = '(' + query + ')';
      }
      this._mq = window.matchMedia(query);
      this._add();
      this.queryHandler(this._mq);
    },

    queryHandler: function(mq) {
      this._setQueryMatches(mq.matches);
    }

  });

</script>
<script>
  /**
   * `IronResizableBehavior` is a behavior that can be used in Polymer elements to
   * coordinate the flow of resize events between "resizers" (elements that control the
   * size or hidden state of their children) and "resizables" (elements that need to be
   * notified when they are resized or un-hidden by their parents in order to take
   * action on their new measurements).
   *
   * Elements that perform measurement should add the `IronResizableBehavior` behavior to
   * their element definition and listen for the `iron-resize` event on themselves.
   * This event will be fired when they become showing after having been hidden,
   * when they are resized explicitly by another resizable, or when the window has been
   * resized.
   *
   * Note, the `iron-resize` event is non-bubbling.
   *
   * @polymerBehavior Polymer.IronResizableBehavior
   * @demo demo/index.html
   **/
  Polymer.IronResizableBehavior = {
    properties: {
      /**
       * The closest ancestor element that implements `IronResizableBehavior`.
       */
      _parentResizable: {
        type: Object,
        observer: '_parentResizableChanged'
      },

      /**
       * True if this element is currently notifying its descendant elements of
       * resize.
       */
      _notifyingDescendant: {
        type: Boolean,
        value: false
      }
    },

    listeners: {
      'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
    },

    created: function() {
      // We don't really need property effects on these, and also we want them
      // to be created before the `_parentResizable` observer fires:
      this._interestedResizables = [];
      this._boundNotifyResize = this.notifyResize.bind(this);
    },

    attached: function() {
      this.fire('iron-request-resize-notifications', null, {
        node: this,
        bubbles: true,
        cancelable: true
      });

      if (!this._parentResizable) {
        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      }
    },

    detached: function() {
      if (this._parentResizable) {
        this._parentResizable.stopResizeNotificationsFor(this);
      } else {
        window.removeEventListener('resize', this._boundNotifyResize);
      }

      this._parentResizable = null;
    },

    /**
     * Can be called to manually notify a resizable and its descendant
     * resizables of a resize change.
     */
    notifyResize: function() {
      if (!this.isAttached) {
        return;
      }

      this._interestedResizables.forEach(function(resizable) {
        if (this.resizerShouldNotify(resizable)) {
          this._notifyDescendant(resizable);
        }
      }, this);

      this._fireResize();
    },

    /**
     * Used to assign the closest resizable ancestor to this resizable
     * if the ancestor detects a request for notifications.
     */
    assignParentResizable: function(parentResizable) {
      this._parentResizable = parentResizable;
    },

    /**
     * Used to remove a resizable descendant from the list of descendants
     * that should be notified of a resize change.
     */
    stopResizeNotificationsFor: function(target) {
      var index = this._interestedResizables.indexOf(target);

      if (index > -1) {
        this._interestedResizables.splice(index, 1);
        this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
      }
    },

    /**
     * This method can be overridden to filter nested elements that should or
     * should not be notified by the current element. Return true if an element
     * should be notified, or false if it should not be notified.
     *
     * @param {HTMLElement} element A candidate descendant element that
     * implements `IronResizableBehavior`.
     * @return {boolean} True if the `element` should be notified of resize.
     */
    resizerShouldNotify: function(element) { return true; },

    _onDescendantIronResize: function(event) {
      if (this._notifyingDescendant) {
        event.stopPropagation();
        return;
      }

      // NOTE(cdata): In ShadowDOM, event retargeting makes echoing of the
      // otherwise non-bubbling event "just work." We do it manually here for
      // the case where Polymer is not using shadow roots for whatever reason:
      if (!Polymer.Settings.useShadow) {
        this._fireResize();
      }
    },

    _fireResize: function() {
      this.fire('iron-resize', null, {
        node: this,
        bubbles: false
      });
    },

    _onIronRequestResizeNotifications: function(event) {
      var target = event.path ? event.path[0] : event.target;

      if (target === this) {
        return;
      }

      if (this._interestedResizables.indexOf(target) === -1) {
        this._interestedResizables.push(target);
        this.listen(target, 'iron-resize', '_onDescendantIronResize');
      }

      target.assignParentResizable(this);
      this._notifyDescendant(target);

      event.stopPropagation();
    },

    _parentResizableChanged: function(parentResizable) {
      if (parentResizable) {
        window.removeEventListener('resize', this._boundNotifyResize);
      }
    },

    _notifyDescendant: function(descendant) {
      // NOTE(cdata): In IE10, attached is fired on children first, so it's
      // important not to notify them if the parent is not attached yet (or
      // else they will get redundantly notified when the parent attaches).
      if (!this.isAttached) {
        return;
      }

      this._notifyingDescendant = true;
      descendant.notifyResize();
      this._notifyingDescendant = false;
    }
  };
</script>

<dom-module id="app-drawer-layout" assetpath="bower_components/app-layout/app-drawer-layout/">
  <template>
    <style>
      :host {
        display: block;
      }

      :host([fullbleed]) {
        @apply(--layout-fit);
      }

      #contentContainer {
        position: relative;

        height: 100%;

        transition: var(--app-drawer-layout-content-transition, none);
      }

      #contentContainer:not(.narrow) > ::content [drawer-toggle] {
        display: none;
      }
    </style>

    <div id="contentContainer">
      <content select=":not(app-drawer)"></content>
    </div>

    <content id="drawerContent" select="app-drawer"></content>

    <iron-media-query query="[[_computeMediaQuery(forceNarrow, responsiveWidth)]]" on-query-matches-changed="_onQueryMatchesChanged"></iron-media-query>
  </template>

  <script>
    Polymer({
      is: 'app-drawer-layout',

      behaviors: [
        Polymer.IronResizableBehavior
      ],

      properties: {
        /**
         * If true, ignore `responsiveWidth` setting and force the narrow layout.
         */
        forceNarrow: {
          type: Boolean,
          value: false
        },

        /**
         * If the viewport's width is smaller than this value, the panel will change to narrow
         * layout. In the mode the drawer will be closed.
         */
        responsiveWidth: {
          type: String,
          value: '640px'
        },

        /**
         * Returns true if it is in narrow layout. This is useful if you need to show/hide
         * elements based on the layout.
         */
        narrow: {
          type: Boolean,
          readOnly: true,
          notify: true
        },

        /**
         * If true, the drawer will initially be opened when in narrow layout mode.
         */
        openedWhenNarrow: {
          type: Boolean,
          value: false
        }
      },

      listeners: {
        'tap': '_tapHandler',
        'app-drawer-attached': '_resetDrawerState',
        'app-drawer-reset-layout': 'resetLayout',
        'iron-resize': 'resetLayout'
      },

      observers: [
        'resetLayout(narrow, isAttached)',
        '_narrowChanged(narrow, isAttached)'
      ],

      /**
       * A reference to the app-drawer element.
       *
       * @property drawer
       */
      get drawer() {
        return Polymer.dom(this.$.drawerContent).getDistributedNodes()[0];
      },

      _tapHandler: function(e) {
        var target = Polymer.dom(e).localTarget;
        if (target && target.hasAttribute('drawer-toggle')) {
          var drawer = this.drawer;
          if (drawer && !drawer.persistent) {
            drawer.toggle();
          }
        }
      },

      resetLayout: function() {
        this.debounce('_resetLayout', function() {
          var drawer = this.drawer;
          var contentContainer = this.$.contentContainer;

          if (this.narrow || !drawer) {
            contentContainer.style.marginLeft = '';
            contentContainer.style.marginRight = '';
          } else {
            var drawerWidth = drawer.getWidth();
            if (drawer.position == 'right') {
              contentContainer.style.marginLeft = '';
              contentContainer.style.marginRight = drawerWidth + 'px';
            } else {
              contentContainer.style.marginLeft = drawerWidth + 'px';
              contentContainer.style.marginRight = '';
            }
          }
        });
      },

      _resetDrawerState: function() {
        this.debounce('_resetDrawerState', function() {
          var drawer = this.drawer;
          if (!drawer) {
            return;
          }

          if (this.narrow) {
            drawer.opened = this.openedWhenNarrow;
            drawer.persistent = false;
          } else {
            drawer.opened = drawer.persistent = true;
          }
        });
      },

      _narrowChanged: function(narrow) {
        this.toggleClass('narrow', narrow, this.$.contentContainer);
        this._resetDrawerState();
        this.notifyResize();
      },

      _onQueryMatchesChanged: function(event) {
        this._setNarrow(event.detail.value);
      },

      _computeMediaQuery: function(forceNarrow, responsiveWidth) {
        return forceNarrow ? '(min-width: 0px)' : '(max-width: ' + responsiveWidth + ')';
      }
    });
  </script>
</dom-module>
<script>

  /**
   * `Polymer.IronScrollTargetBehavior` allows an element to respond to scroll events from a
   * designated scroll target.
   *
   * Elements that consume this behavior can override the `_scrollHandler`
   * method to add logic on the scroll event.
   *
   * @demo demo/scrolling-region.html Scrolling Region
   * @demo demo/document.html Document Element
   * @polymerBehavior
   */
  Polymer.IronScrollTargetBehavior = {

    properties: {

      /**
       * Specifies the element that will handle the scroll event
       * on the behalf of the current element. This is typically a reference to an element,
       * but there are a few more posibilities:
       *
       * ### Elements id
       *
       *```html
       * <div id="scrollable-element" style="overflow: auto;">
       *  <x-element scroll-target="scrollable-element">
       *    <!-- Content-->
       *  </x-element>
       * </div>
       *```
       * In this case, the `scrollTarget` will point to the outer div element.
       *
       * ### Document scrolling
       *
       * For document scrolling, you can use the reserved word `document`:
       *
       *```html
       * <x-element scroll-target="document">
       *   <!-- Content -->
       * </x-element>
       *```
       *
       * ### Elements reference
       *
       *```js
       * appHeader.scrollTarget = document.querySelector('#scrollable-element');
       *```
       *
       * @type {Element}
       */
      scrollTarget: {
        type: Object,
        value: function() {
          return this._defaultScrollTarget;
        }
      }
    },

    observers: [
      '_scrollTargetChanged(scrollTarget, isAttached)'
    ],

    /**
     * True if the event listener should be installed.
     */
    _shouldHaveListener: true,

    _scrollTargetChanged: function(scrollTarget, isAttached) {
      var eventTarget;

      if (this._oldScrollTarget) {
        this._toggleScrollListener(false, this._oldScrollTarget);
        this._oldScrollTarget = null;
      }
      if (!isAttached) {
        return;
      }
      // Support element id references
      if (scrollTarget === 'document') {

        this.scrollTarget = this._doc;

      } else if (typeof scrollTarget === 'string') {

        this.scrollTarget = this.domHost ? this.domHost.$[scrollTarget] :
            Polymer.dom(this.ownerDocument).querySelector('#' + scrollTarget);

      } else if (this._isValidScrollTarget()) {

        this._boundScrollHandler = this._boundScrollHandler || this._scrollHandler.bind(this);
        this._oldScrollTarget = scrollTarget;
        this._toggleScrollListener(this._shouldHaveListener, scrollTarget);

      }
    },

    /**
     * Runs on every scroll event. Consumer of this behavior may override this method.
     *
     * @protected
     */
    _scrollHandler: function scrollHandler() {},

    /**
     * The default scroll target. Consumers of this behavior may want to customize
     * the default scroll target.
     *
     * @type {Element}
     */
    get _defaultScrollTarget() {
      return this._doc;
    },

    /**
     * Shortcut for the document element
     *
     * @type {Element}
     */
    get _doc() {
      return this.ownerDocument.documentElement;
    },

    /**
     * Gets the number of pixels that the content of an element is scrolled upward.
     *
     * @type {number}
     */
    get _scrollTop() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;
      }
      return 0;
    },

    /**
     * Gets the number of pixels that the content of an element is scrolled to the left.
     *
     * @type {number}
     */
    get _scrollLeft() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;
      }
      return 0;
    },

    /**
     * Sets the number of pixels that the content of an element is scrolled upward.
     *
     * @type {number}
     */
    set _scrollTop(top) {
      if (this.scrollTarget === this._doc) {
        window.scrollTo(window.pageXOffset, top);
      } else if (this._isValidScrollTarget()) {
        this.scrollTarget.scrollTop = top;
      }
    },

    /**
     * Sets the number of pixels that the content of an element is scrolled to the left.
     *
     * @type {number}
     */
    set _scrollLeft(left) {
      if (this.scrollTarget === this._doc) {
        window.scrollTo(left, window.pageYOffset);
      } else if (this._isValidScrollTarget()) {
        this.scrollTarget.scrollLeft = left;
      }
    },

    /**
     * Scrolls the content to a particular place.
     *
     * @method scroll
     * @param {number} left The left position
     * @param {number} top The top position
     */
    scroll: function(left, top) {
       if (this.scrollTarget === this._doc) {
        window.scrollTo(left, top);
      } else if (this._isValidScrollTarget()) {
        this.scrollTarget.scrollLeft = left;
        this.scrollTarget.scrollTop = top;
      }
    },

    /**
     * Gets the width of the scroll target.
     *
     * @type {number}
     */
    get _scrollTargetWidth() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;
      }
      return 0;
    },

    /**
     * Gets the height of the scroll target.
     *
     * @type {number}
     */
    get _scrollTargetHeight() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;
      }
      return 0;
    },

    /**
     * Returns true if the scroll target is a valid HTMLElement.
     *
     * @return {boolean}
     */
    _isValidScrollTarget: function() {
      return this.scrollTarget instanceof HTMLElement;
    },

    _toggleScrollListener: function(yes, scrollTarget) {
      if (!this._boundScrollHandler) {
        return;
      }
      var eventTarget = scrollTarget === this._doc ? window : scrollTarget;

      if (yes) {
        eventTarget.addEventListener('scroll', this._boundScrollHandler);
      } else {
        eventTarget.removeEventListener('scroll', this._boundScrollHandler);
      }
    },

    /**
     * Enables or disables the scroll event listener.
     *
     * @param {boolean} yes True to add the event, False to remove it.
     */
    toggleScrollListener: function(yes) {
      this._shouldHaveListener = yes;
      this._toggleScrollListener(yes, this.scrollTarget);
    }

  };

</script>
<script>
  Polymer.AppLayout = Polymer.AppLayout || {};

  Polymer.AppLayout._scrollEffects = Polymer.AppLayout._scrollEffects || {};

  Polymer.AppLayout.scrollTimingFunction = function easeOutQuad(t, b, c, d) {
    t /= d;
    return -c * t*(t-2) + b;
  };

  /**
   * Registers a scroll effect to be used in elements that implement the
   * `Polymer.AppScrollEffectsBehavior` behavior.
   *
   * @param {string} effectName The effect name.
   * @param {Object} effectDef The effect definition.
   */
  Polymer.AppLayout.registerEffect = function registerEffect(effectName, effectDef) {
    if (Polymer.AppLayout._scrollEffects[effectName] != null) {
      throw new Error('effect `'+ effectName + '` is already registered.');
    }
    Polymer.AppLayout._scrollEffects[effectName] = effectDef;
  };

  /**
   * Scrolls to a particular set of coordinates in a scroll target.
   * If the scroll target is not defined, then it would use the main document as the target.
   *
   * To scroll in a smooth fashion, you can set the option `behavior: 'smooth'`. e.g.
   *
   * ```js
   * Polymer.AppLayout.scroll({top: 0, behavior: 'smooth'});
   * ```
   *
   * To scroll in a silent mode, without notifying scroll changes to any app-layout elements,
   * you can set the option `behavior: 'silent'`. This is particularly useful we you are using
   * `app-header` and you desire to scroll to the top of a scrolling region without running
   * scroll effects. e.g.
   *
   * ```js
   * Polymer.AppLayout.scroll({top: 0, behavior: 'silent'});
   * ```
   *
   * @param {Object} options {top: Number, left: Number, behavior: String(smooth | silent)}
   */
  Polymer.AppLayout.scroll = function scroll(options) {
    options = options || {};

    var docEl = document.documentElement;
    var target = options.target || docEl;
    var hasNativeScrollBehavior = 'scrollBehavior' in target.style && target.scroll;
    var scrollClassName = 'app-layout-silent-scroll';
    var scrollTop = options.top || 0;
    var scrollLeft = options.left || 0;
    var scrollTo = target === docEl ? window.scrollTo :
      function scrollTo(scrollLeft, scrollTop) {
        target.scrollLeft = scrollLeft;
        target.scrollTop = scrollTop;
      };

    if (options.behavior === 'smooth') {

      if (hasNativeScrollBehavior) {

        target.scroll(options);

      } else {

        var timingFn = Polymer.AppLayout.scrollTimingFunction;
        var startTime = Date.now();
        var currentScrollTop = target === docEl ? window.pageYOffset : target.scrollTop;
        var currentScrollLeft = target === docEl ? window.pageXOffset : target.scrollLeft;
        var deltaScrollTop = scrollTop - currentScrollTop;
        var deltaScrollLeft = scrollLeft - currentScrollLeft;
        var duration = 300;
        var updateFrame = (function updateFrame() {
          var now = Date.now();
          var elapsedTime = now - startTime;

          if (elapsedTime < duration) {
            scrollTo(timingFn(elapsedTime, currentScrollLeft, deltaScrollLeft, duration),
                timingFn(elapsedTime, currentScrollTop, deltaScrollTop, duration));
            requestAnimationFrame(updateFrame);
          } else {
            scrollTo(scrollLeft, scrollTop);
          }
        }).bind(this);

        updateFrame();
      }

    } else if (options.behavior === 'silent') {

      docEl.classList.add(scrollClassName);

      // Browsers keep the scroll momentum even if the bottom of the scrolling content
      // was reached. This means that calling scroll({top: 0, behavior: 'silent'}) when
      // the momentum is still going will result in more scroll events and thus scroll effects.
      // This seems to only apply when using document scrolling.
      // Therefore, when should we remove the class from the document element?

      clearInterval(Polymer.AppLayout._scrollTimer);

      Polymer.AppLayout._scrollTimer = setTimeout(function() {
        docEl.classList.remove(scrollClassName);
        Polymer.AppLayout._scrollTimer = null;
      }, 100);

      scrollTo(scrollLeft, scrollTop);

    } else {

      scrollTo(scrollLeft, scrollTop);

    }
  };

</script>
<script>
  /**
   * `Polymer.AppScrollEffectsBehavior` provides an interface that allows an element to use scrolls effects.
   *
   * ### Importing the app-layout effects
   *
   * app-layout provides a set of scroll effects that can be used by explicitly importing
   * `app-scroll-effects.html`:
   *
   * ```html
   * <link rel="import" href="/bower_components/app-layout/app-scroll-effects/app-scroll-effects.html">
   * ```
   *
   * The scroll effects can also be used by individually importing
   * `app-layout/app-scroll-effects/effects/[effectName].html`. For example:
   *
   * ```html
   *  <link rel="import" href="/bower_components/app-layout/app-scroll-effects/effects/waterfall.html">
   * ```
   *
   * ### Consuming effects
   *
   * Effects can be consumed via the `effects` property. For example:
   *
   * ```html
   * <app-header effects="waterfall"></app-header>
   * ```
   *
   * ### Creating scroll effects
   *
   * You may want to create a custom scroll effect if you need to modify the CSS of an element
   * based on the scroll position.
   *
   * A scroll effect definition is an object with `setUp()`, `tearDown()` and `run()` functions.
   *
   * To register the effect, you can use `Polymer.AppLayout.registerEffect(effectName, effectDef)`
   * For example, let's define an effect that resizes the header's logo:
   *
   * ```js
   * Polymer.AppLayout.registerEffect('resizable-logo', {
   *   setUp: function(config) {
   *     // the effect's config is passed to the setUp.
   *     this._fxResizeLogo = { logo: Polymer.dom(this).querySelector('[logo]') };
   *   },
   *
   *   run: function(progress) {
   *      // the progress of the effect
   *      this.transform('scale3d(' + progress + ', '+ progress +', 1)',  this._fxResizeLogo.logo);
   *   },
   *
   *   tearDown: function() {
   *      // clean up and reset of states
   *      delete this._fxResizeLogo;
   *   }
   * });
   * ```
   * Now, you can consume the effect:
   *
   * ```html
   * <app-header id="appHeader" effects="resizable-logo">
   *   <img logo src="logo.svg">
   * </app-header>
   * ```
   *
   * ### Imperative API
   *
   * ```js
   * var logoEffect = appHeader.createEffect('resizable-logo', effectConfig);
   * // run the effect: logoEffect.run(progress);
   * // tear down the effect: logoEffect.tearDown();
   * ```
   *
   * ### Configuring effects
   *
   * For effects installed via the `effects` property, their configuration can be set
   * via the `effectsConfig` property. For example:
   *
   * ```html
   * <app-header effects="waterfall"
   *   effects-config='{"waterfall": {"startsAt": 0, "endsAt": 0.5}}'>
   * </app-header>
   * ```
   *
   * All effects have a `startsAt` and `endsAt` config property. They specify at what
   * point the effect should start and end. This value goes from 0 to 1 inclusive.
   *
   * @polymerBehavior
   */
  Polymer.AppScrollEffectsBehavior = [
    Polymer.IronScrollTargetBehavior,
   {

    properties: {

      /**
       * A space-separated list of the effects names that will be triggered when the user scrolls.
       * e.g. `waterfall parallax-background` installs the `waterfall` and `parallax-background`.
       */
      effects: {
        type: String
      },

      /**
       * An object that configurates the effects installed via the `effects` property. e.g.
       * ```js
       *  element.effectsConfig = {
       *   "blend-background": {
       *     "startsAt": 0.5
       *   }
       * };
       * ```
       * Every effect has at least two config properties: `startsAt` and `endsAt`.
       * These properties indicate when the event should start and end respectively
       * and relative to the overall element progress. So for example, if `blend-background`
       * starts at `0.5`, the effect will only start once the current element reaches 0.5
       * of its progress. In this context, the progress is a value in the range of `[0, 1]`
       * that indicates where this element is on the screen relative to the viewport.
       */
      effectsConfig: {
        type: Object,
        value: function() {
          return {};
        }
      },

      /**
       * Disables CSS transitions and scroll effects on the element.
       */
      disabled: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      },

      /**
       * Allows to set a `scrollTop` threshold. When greater than 0, `thresholdTriggered`
       * is true only when the scroll target's `scrollTop` has reached this value.
       *
       * For example, if `threshold = 100`, `thresholdTriggered` is true when the `scrollTop`
       * is at least `100`.
       */
      threshold: {
        type: Number,
        value: 0
      },

      /**
       * True if the `scrollTop` threshold (set in `scrollTopThreshold`) has
       * been reached.
       */
      thresholdTriggered: {
        type: Boolean,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      }
    },

    observers: [
      '_effectsChanged(effects, effectsConfig, isAttached)'
    ],

    /**
     * Updates the scroll state. This method should be overridden
     * by the consumer of this behavior.
     *
     * @method _updateScrollState
     */
    _updateScrollState: function() {},

    /**
     * Returns true if the current element is on the screen.
     * That is, visible in the current viewport. This method should be
     * overridden by the consumer of this behavior.
     *
     * @method isOnScreen
     * @return {boolean}
     */
    isOnScreen: function() {
      return false;
    },

    /**
     * Returns true if there's content below the current element. This method
     * should be overridden by the consumer of this behavior.
     *
     * @method isContentBelow
     * @return {boolean}
     */
    isContentBelow: function() {
      return false;
    },

    /**
     * List of effects handlers that will take place during scroll.
     *
     * @type {Array<Function>}
     */
    _effectsRunFn: null,

    /**
     * List of the effects definitions installed via the `effects` property.
     *
     * @type {Array<Object>}
     */
    _effects: null,

    /**
     * The clamped value of `_scrollTop`.
     * @type number
     */
    get _clampedScrollTop() {
      return Math.max(0, this._scrollTop);
    },

    detached: function() {
      this._tearDownEffects();
    },

    /**
     * Creates an effect object from an effect's name that can be used to run
     * effects programmatically.
     *
     * @method createEffect
     * @param {string} effectName The effect's name registered via `Polymer.AppLayout.registerEffect`.
     * @param {Object=} effectConfig The effect config object. (Optional)
     * @return {Object} An effect object with the following functions:
     *
     *  * `effect.setUp()`, Sets up the requirements for the effect.
     *       This function is called automatically before the `effect` function returns.
     *  * `effect.run(progress, y)`, Runs the effect given a `progress`.
     *  * `effect.tearDown()`, Cleans up any DOM nodes or element references used by the effect.
     *
     * Example:
     * ```js
     * var parallax = element.createEffect('parallax-background');
     * // runs the effect
     * parallax.run(0.5, 0);
     * ```
     */
    createEffect: function(effectName, effectConfig) {
      var effectDef = Polymer.AppLayout._scrollEffects[effectName];
      if (!effectDef) {
        throw new ReferenceError(this._getUndefinedMsg(effectName));
      }
      var prop = this._boundEffect(effectDef, effectConfig || {});
      prop.setUp();
      return prop;
    },

    /**
     * Called when `effects` or `effectsConfig` changes.
     */
    _effectsChanged: function(effects, effectsConfig, isAttached) {
      this._tearDownEffects();

      if (effects === '' || !isAttached) {
        return;
      }
      effects.split(' ').forEach(function(effectName) {
        var effectDef;
        if (effectName !== '') {
          if ((effectDef = Polymer.AppLayout._scrollEffects[effectName])) {
            this._effects.push(this._boundEffect(effectDef, effectsConfig[effectName]));
          } else {
            console.warn(this._getUndefinedMsg(effectName));
          }
        }
      }, this);

      this._setUpEffect();
    },

    /**
     * Forces layout
     */
    _layoutIfDirty: function() {
      return this.offsetWidth;
    },

    /**
     * Returns an effect object bound to the current context.
     *
     * @param {Object} effectDef
     * @param {Object=} effectsConfig The effect config object if the effect accepts config values. (Optional)
     */
    _boundEffect: function(effectDef, effectsConfig) {
      effectsConfig = effectsConfig || {};
      var startsAt = parseFloat(effectsConfig.startsAt || 0);
      var endsAt = parseFloat(effectsConfig.endsAt || 1);
      var deltaS = endsAt - startsAt;
      var noop = function() {};
      // fast path if possible
      var runFn = (startsAt === 0 && endsAt === 1) ? effectDef.run :
        function(progress, y) {
          effectDef.run.call(this,
              Math.max(0, (progress - startsAt) / deltaS), y);
        };
      return {
        setUp: effectDef.setUp ? effectDef.setUp.bind(this, effectsConfig) : noop,
        run: effectDef.run ? runFn.bind(this) : noop,
        tearDown: effectDef.tearDown ? effectDef.tearDown.bind(this) : noop
      };
    },

    /**
     * Sets up the effects.
     */
    _setUpEffect: function() {
      if (this.isAttached && this._effects) {
        this._effectsRunFn = [];
        this._effects.forEach(function(effectDef) {
          // install the effect only if no error was reported
          if (effectDef.setUp() !== false) {
            this._effectsRunFn.push(effectDef.run);
          }
        }, this);
      }
    },

    /**
     * Tears down the effects.
     */
    _tearDownEffects: function() {
      if (this._effects) {
        this._effects.forEach(function(effectDef) {
          effectDef.tearDown();
        });
      }
      this._effectsRunFn = [];
      this._effects = [];
    },

    /**
     * Runs the effects.
     *
     * @param {number} p The progress
     * @param {number} y The top position of the current element relative to the viewport.
     */
    _runEffects: function(p, y) {
      if (this._effectsRunFn) {
        this._effectsRunFn.forEach(function(run) {
          run(p, y);
        });
      }
    },

    /**
     * Overrides the `_scrollHandler`.
     */
    _scrollHandler: function() {
      if (!this.disabled) {
        var scrollTop = this._clampedScrollTop;
        this._updateScrollState(scrollTop);
        if (this.threshold > 0) {
          this._setThresholdTriggered(scrollTop >= this.threshold);
        }
      }
    },

    /**
     * Override this method to return a reference to a node in the local DOM.
     * The node is consumed by a scroll effect.
     *
     * @param {string} id The id for the node.
     */
    _getDOMRef: function(id) {
      console.warn('_getDOMRef', '`'+ id +'` is undefined');
    },

    _getUndefinedMsg: function(effectName) {
      return 'Scroll effect `' + effectName + '` is undefined. ' +
          'Did you forget to import app-layout/app-scroll-effects/effects/' + effectName + '.html ?';
    }

  }];

</script>
<dom-module id="app-header" assetpath="bower_components/app-layout/app-header/">
  <template>
    <style>
      :host {
        position: relative;
        display: block;
        transition-timing-function: linear;
        transition-property: -webkit-transform;
        transition-property: transform;
      }

      :host::before {
        position: absolute;
        right: 0px;
        bottom: -5px;
        left: 0px;
        width: 100%;
        height: 5px;
        content: "";
        transition: opacity 0.4s;
        pointer-events: none;
        opacity: 0;
        box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);
        will-change: opacity;
        @apply(--app-header-shadow);
      }

      :host([shadow])::before {
        opacity: 1;
      }

      ::content [main-title],
      ::content [condensed-title] {
        -webkit-transform-origin: left top;
        transform-origin: left top;
        white-space: nowrap;
      }

      ::content [condensed-title] {
        opacity: 0;
      }

      #background {
        @apply(--layout-fit);
        overflow: hidden;
      }

      #backgroundFrontLayer,
      #backgroundRearLayer {
        @apply(--layout-fit);
        height: 100%;
        pointer-events: none;
        background-size: cover;
      }

      #backgroundFrontLayer {
        @apply(--app-header-background-front-layer);
      }

      #backgroundRearLayer {
        opacity: 0;
        @apply(--app-header-background-rear-layer);
      }

      #contentContainer {
        position: relative;
        width: 100%;
        height: 100%;
      }

      :host([disabled]),
      :host([disabled])::after,
      :host([disabled]) #backgroundFrontLayer,
      :host([disabled]) #backgroundRearLayer,
      :host([disabled]) ::content > app-toolbar:first-of-type,
      :host([disabled]) ::content > [sticky],
      /* Silent scrolling should not run CSS transitions */
      :host-context(.app-layout-silent-scroll),
      :host-context(.app-layout-silent-scroll)::after,
      :host-context(.app-layout-silent-scroll) #backgroundFrontLayer,
      :host-context(.app-layout-silent-scroll) #backgroundRearLayer,
      :host-context(.app-layout-silent-scroll) ::content > app-toolbar:first-of-type,
      :host-context(.app-layout-silent-scroll) ::content > [sticky] {
        transition: none !important;
      }
    </style>
    <div id="contentContainer">
      <content id="content"></content>
    </div>
  </template>

  <script>
    Polymer({
      is: 'app-header',

      behaviors: [
        Polymer.AppScrollEffectsBehavior,
        Polymer.IronResizableBehavior
      ],

      properties: {
        /**
         * If true, the header will automatically collapse when scrolling down.
         * That is, the `sticky` element remains visible when the header is fully condensed
         * whereas the rest of the elements will collapse below `sticky` element.
         *
         * By default, the `sticky` element is the first toolbar in the light DOM:
         *
         *```html
         * <app-header condenses>
         *   <app-toolbar>This toolbar remains on top</app-toolbar>
         *   <app-toolbar></app-toolbar>
         *   <app-toolbar></app-toolbar>
         * </app-header>
         * ```
         *
         * Additionally, you can specify which toolbar or element remains visible in condensed mode
         * by adding the `sticky` attribute to that element. For example: if we want the last
         * toolbar to remain visible, we can add the `sticky` attribute to it.
         *
         *```html
         * <app-header condenses>
         *   <app-toolbar></app-toolbar>
         *   <app-toolbar></app-toolbar>
         *   <app-toolbar sticky>This toolbar remains on top</app-toolbar>
         * </app-header>
         * ```
         *
         * Note the `sticky` element must be a direct child of `app-header`.
         */
        condenses: {
          type: Boolean,
          value: false
        },

        /**
         * Mantains the header fixed at the top so it never moves away.
         */
        fixed: {
          type: Boolean,
          value: false
        },

        /**
         * Slides back the header when scrolling back up.
         */
        reveals: {
          type: Boolean,
          value: false
        },

        /**
         * Displays a shadow below the header.
         */
        shadow: {
          type: Boolean,
          reflectToAttribute: true,
          value: false
        }
      },

      observers: [
        'resetLayout(isAttached, condenses, fixed)'
      ],

      listeners: {
        'iron-resize': '_resizeHandler'
      },

      /**
       * A cached offsetHeight of the current element.
       *
       * @type {number}
       */
      _height: 0,

      /**
       * The distance in pixels the header will be translated to when scrolling.
       *
       * @type {number}
       */
      _dHeight: 0,

      /**
       * The offsetTop of `_stickyEl`
       *
       * @type {number}
       */
      _stickyElTop: 0,

      /**
       * The element that remains visible when the header condenses.
       *
       * @type {HTMLElement}
       */
      _stickyEl: null,

      /**
       * The header's top value used for the `transformY`
       *
       * @type {number}
       */
      _top: 0,

      /**
       * The current scroll progress.
       *
       * @type {number}
       */
      _progress: 0,

      _wasScrollingDown: false,
      _initScrollTop: 0,
      _initTimestamp: 0,
      _lastTimestamp: 0,
      _lastScrollTop: 0,

      /**
       * The distance the header is allowed to move away.
       *
       * @type {number}
       */
      get _maxHeaderTop() {
        return this.fixed ? this._dHeight : this._height + 5;
      },

      /**
       * Returns a reference to the sticky element.
       *
       * @return {HTMLElement}?
       */
      _getStickyEl: function() {
        /** @type {HTMLElement} */
        var stickyEl;
        var nodes = Polymer.dom(this.$.content).getDistributedNodes();

        for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].nodeType === Node.ELEMENT_NODE) {
            var node = /** @type {HTMLElement} */ (nodes[i]);
            if (node.hasAttribute('sticky')) {
              stickyEl = node;
              break;
            } else if (!stickyEl) {
              stickyEl = node;
            }
          }
        }
        return stickyEl;
      },

      /**
       * Resets the layout. If you changed the size of app-header via CSS
       * you can notify the changes by either firing the `iron-resize` event
       * or calling `resetLayout` directly.
       *
       * @method resetLayout
       */
      resetLayout: function() {
        this.debounce('_resetLayout', function() {
          // noop if the header isn't visible
          if (this.offsetWidth === 0 && this.offsetHeight === 0) {
            return;
          }

          var scrollTop = this._clampedScrollTop;
          var firstSetup = this._height === 0 || scrollTop === 0;
          var currentDisabled = this.disabled;

          this._height = this.offsetHeight;
          this._stickyEl = this._getStickyEl();
          this.disabled = true;

          // prepare for measurement
          if  (!firstSetup) {
            this._updateScrollState(0, true);
          }
          if (this._mayMove()) {
            this._dHeight = this._stickyEl ? this._height - this._stickyEl.offsetHeight : 0;
          } else {
            this._dHeight = 0;
          }

          this._stickyElTop = this._stickyEl ? this._stickyEl.offsetTop : 0;
          this._setUpEffect();

          if (firstSetup) {
            this._updateScrollState(scrollTop, true);
          } else {
            this._updateScrollState(this._lastScrollTop, true);
            this._layoutIfDirty();
          }
          // restore no transition
          this.disabled = currentDisabled;
          this.fire('app-header-reset-layout');
        });
      },

      /**
       * Updates the scroll state.
       *
       * @param {number} scrollTop
       * @param {boolean=} forceUpdate (default: false)
       */
      _updateScrollState: function(scrollTop, forceUpdate) {
        if (this._height === 0) {
          return;
        }

        var progress = 0;
        var top = 0;
        var lastTop = this._top;
        var lastScrollTop = this._lastScrollTop;
        var maxHeaderTop = this._maxHeaderTop;
        var dScrollTop = scrollTop - this._lastScrollTop;
        var absDScrollTop = Math.abs(dScrollTop);
        var isScrollingDown = scrollTop > this._lastScrollTop;
        var now = performance.now();

        if (this._mayMove()) {
          top = this._clamp(this.reveals ? lastTop + dScrollTop : scrollTop, 0, maxHeaderTop);
        }

        if (scrollTop >= this._dHeight) {
          top = this.condenses && !this.fixed ? Math.max(this._dHeight, top) : top;
          this.style.transitionDuration = '0ms';
        }

        if (this.reveals && !this.disabled && absDScrollTop < 100) {
          // set the initial scroll position
          if (now - this._initTimestamp > 300 || this._wasScrollingDown !== isScrollingDown) {
            this._initScrollTop = scrollTop;
            this._initTimestamp = now;
          }

          if (scrollTop >= maxHeaderTop) {
            // check if the header is allowed to snap
            if (Math.abs(this._initScrollTop - scrollTop) > 30 || absDScrollTop > 10) {
              if (isScrollingDown && scrollTop >= maxHeaderTop) {
                top = maxHeaderTop;
              } else if (!isScrollingDown && scrollTop >= this._dHeight) {
                top = this.condenses && !this.fixed ? this._dHeight : 0;
              }
              var scrollVelocity = dScrollTop / (now - this._lastTimestamp);
              this.style.transitionDuration = this._clamp((top - lastTop) / scrollVelocity, 0, 300) + 'ms';
            } else {
              top = this._top;
            }
          }
        }

        if (this._dHeight === 0) {
          progress = scrollTop > 0 ? 1 : 0;
        } else {
          progress = top / this._dHeight;
        }

        if (!forceUpdate) {
          this._lastScrollTop = scrollTop;
          this._top = top;
          this._wasScrollingDown = isScrollingDown;
          this._lastTimestamp = now;
        }

        if (forceUpdate || progress !== this._progress || lastTop !== top || scrollTop === 0) {
          this._progress = progress;
          this._runEffects(progress, top);
          this._transformHeader(top);
        }
      },

      /**
       * Returns true if the current header is allowed to move as the user scrolls.
       *
       * @return {boolean}
       */
      _mayMove: function() {
        return this.condenses || !this.fixed;
      },

      /**
       * Returns true if the current header will condense based on the size of the header
       * and the `consenses` property.
       *
       * @return {boolean}
       */
      willCondense: function() {
        return this._dHeight > 0 && this.condenses;
      },

      /**
       * Returns true if the current element is on the screen.
       * That is, visible in the current viewport.
       *
       * @method isOnScreen
       * @return {boolean}
       */
      isOnScreen: function() {
        return this._height !== 0 && this._top < this._height;
      },

      /**
       * Returns true if there's content below the current element.
       *
       * @method isContentBelow
       * @return {boolean}
       */
      isContentBelow: function() {
        if (this._top === 0) {
          return this._clampedScrollTop > 0;
        }
        return this._clampedScrollTop - this._maxHeaderTop >= 0;
      },

      /**
       * Transforms the header.
       *
       * @param {number} y
       */
      _transformHeader: function(y) {
        this.translate3d(0, (-y) + 'px', 0);
        if (this._stickyEl) {
          this.translate3d(0, this.condenses && y >= this._stickyElTop ?
              (Math.min(y, this._dHeight) - this._stickyElTop) + 'px' : 0,  0, this._stickyEl);
        }
      },

      _resizeHandler: function() {
        this.resetLayout();
      },

      _clamp: function(v, min, max) {
        return Math.min(max, Math.max(min, v));
      },

      _ensureBgContainers: function() {
        if (!this._bgContainer) {
          this._bgContainer = document.createElement('div');
          this._bgContainer.id = 'background';

          this._bgRear = document.createElement('div');
          this._bgRear.id = 'backgroundRearLayer';
          this._bgContainer.appendChild(this._bgRear);

          this._bgFront = document.createElement('div');
          this._bgFront.id = 'backgroundFrontLayer';
          this._bgContainer.appendChild(this._bgFront);

          Polymer.dom(this.root).insertBefore(this._bgContainer, this.$.contentContainer);
        }
      },

      _getDOMRef: function(id) {
        switch (id) {
          case 'backgroundFrontLayer':
            this._ensureBgContainers();
            return this._bgFront;
          case 'backgroundRearLayer':
            this._ensureBgContainers();
            return this._bgRear;
          case 'background':
            this._ensureBgContainers();
            return this._bgContainer;
          case 'mainTitle':
            return Polymer.dom(this).querySelector('[main-title]');
          case 'condensedTitle':
            return Polymer.dom(this).querySelector('[condensed-title]');
        }
        return null;
      },

      /**
       * Returns an object containing the progress value of the scroll effects
       * and the top position of the header.
       *
       * @method getScrollState
       * @return {Object}
       */
      getScrollState: function() {
        return { progress: this._progress, top: this._top };
      }

      /**
       * Fires when the layout of `app-header` changed.
       *
       * @event app-header-reset-layout
       */
    });
  </script>
</dom-module>
<dom-module id="app-header-layout" assetpath="bower_components/app-layout/app-header-layout/">
  <template>
    <style>
      :host {
        display: block;
        /**
         * Force app-header-layout to have its own stacking context so that its parent can
         * control the stacking of it relative to other elements (e.g. app-drawer-layout).
         * This could be done using `isolation: isolate`, but that's not well supported
         * across browsers.
         */
        position: relative;
        z-index: 0;
      }

      :host > ::content > app-header {
        @apply(--layout-fixed-top);
        z-index: 1;
      }

      :host([has-scrolling-region]) {
        height: 100%;
      }

      :host([has-scrolling-region]) > ::content > app-header {
        position: absolute;
      }

      :host([has-scrolling-region]) > #contentContainer {
        @apply(--layout-fit);
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }

      :host([fullbleed]) {
        @apply(--layout-vertical);
        @apply(--layout-fit);
      }

      :host([fullbleed]) > #contentContainer {
        @apply(--layout-vertical);
        @apply(--layout-flex);
      }

      #contentContainer {
        /* Create a stacking context here so that all children appear below the header. */
        position: relative;
        z-index: 0;
      }

    </style>

    <content id="header" select="app-header"></content>

    <div id="contentContainer">
      <content></content>
    </div>

  </template>

  <script>
    Polymer({
      is: 'app-header-layout',

      behaviors: [
        Polymer.IronResizableBehavior
      ],

      properties: {
        /**
         * If true, the current element will have its own scrolling region.
         * Otherwise, it will use the document scroll to control the header.
         */
        hasScrollingRegion: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        }
      },

      listeners: {
        'iron-resize': '_resizeHandler',
        'app-header-reset-layout': '_resetLayoutHandler'
      },

      observers: [
        'resetLayout(isAttached, hasScrollingRegion)'
      ],

      /**
       * A reference to the app-header element.
       *
       * @property header
       */
      get header() {
        return Polymer.dom(this.$.header).getDistributedNodes()[0];
      },

      /**
       * Resets the layout. This method is automatically called when the element is attached
       * to the DOM.
       *
       * @method resetLayout
       */
      resetLayout: function() {
        this._updateScroller();
        this.debounce('_resetLayout', this._updateContentPosition);
      },

      _updateContentPosition: function() {
        var header = this.header;
        if (!this.isAttached || !header) {
          return;
        }
        // Get header height here so that style reads are batched together before style writes
        // (i.e. getBoundingClientRect() below).
        var headerHeight = header.offsetHeight;
        // Update the header position.
        if (!this.hasScrollingRegion) {
          var rect = this.getBoundingClientRect();
          var rightOffset = document.documentElement.clientWidth - rect.right;
          header.style.left = rect.left + 'px';
          header.style.right = rightOffset + 'px';
        } else {
          header.style.left = '';
          header.style.right = '';
        }
        // Update the content container position.
        var containerStyle = this.$.contentContainer.style;
        if (header.fixed && !header.willCondense() && this.hasScrollingRegion) {
          // If the header size does not change and we're using a scrolling region, exclude
          // the header area from the scrolling region so that the header doesn't overlap
          // the scrollbar.
          containerStyle.marginTop = headerHeight + 'px';
          containerStyle.paddingTop = '';
        } else {
          containerStyle.paddingTop = headerHeight + 'px';
          containerStyle.marginTop = '';
        }
      },

      _updateScroller: function() {
        if (!this.isAttached) {
          return;
        }
        var header = this.header;
        if (header) {
          header.scrollTarget = this.hasScrollingRegion ?
              this.$.contentContainer : this.ownerDocument.documentElement;
        }
      },

      _resizeHandler: function() {
        this.resetLayout();
      },

      _resetLayoutHandler: function(e) {
        this.resetLayout();
        e.stopPropagation();
      }

    });
  </script>
</dom-module>
<script>
  /**
   * While scrolling down, fade in the rear background layer and fade out the front background
   * layer (opacity interpolated based on scroll position).
   */
  Polymer.AppLayout.registerEffect('blend-background', {
    /** @this Polymer.AppLayout.ElementWithBackground */
    setUp: function setUp() {
      var fx = {};
      fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
      fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
      fx.backgroundFrontLayer.style.willChange = 'opacity';
      fx.backgroundFrontLayer.style.transform = 'translateZ(0)';
      fx.backgroundRearLayer.style.willChange = 'opacity';
      fx.backgroundRearLayer.style.transform = 'translateZ(0)';
      fx.backgroundRearLayer.style.opacity = 0;
      this._fxBlendBackground = fx;
    },
    /** @this Polymer.AppLayout.ElementWithBackground */
    run: function run(p, y) {
      var fx = this._fxBlendBackground;
      fx.backgroundFrontLayer.style.opacity = 1 - p;
      fx.backgroundRearLayer.style.opacity = p;
    },
    /** @this Polymer.AppLayout.ElementWithBackground */
    tearDown: function tearDown() {
      delete this._fxBlendBackground;
    }
  });
</script>
<script>
  /**
   * Upon scrolling past a threshold, fade in the rear background layer and fade out the front
   * background layer (opacity CSS transitioned over time).
   *
   *
   */
  Polymer.AppLayout.registerEffect('fade-background', {
    /** @this Polymer.AppLayout.ElementWithBackground */
    setUp: function setUp(config) {
      var fx = {};
      var duration = config.duration || '0.5s';
      fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
      fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
      fx.backgroundFrontLayer.style.willChange = 'opacity';
      fx.backgroundFrontLayer.style.webkitTransform = 'translateZ(0)';
      fx.backgroundFrontLayer.style.transitionProperty = 'opacity';
      fx.backgroundFrontLayer.style.transitionDuration = duration;
      fx.backgroundRearLayer.style.willChange = 'opacity';
      fx.backgroundRearLayer.style.webkitTransform = 'translateZ(0)';
      fx.backgroundRearLayer.style.transitionProperty = 'opacity';
      fx.backgroundRearLayer.style.transitionDuration = duration;
      this._fxFadeBackground = fx;
    },
    /** @this Polymer.AppLayout.ElementWithBackground */
    run: function run(p, y) {
      var fx = this._fxFadeBackground;
      if (p >= 1) {
        fx.backgroundFrontLayer.style.opacity = 0;
        fx.backgroundRearLayer.style.opacity = 1;
      } else {
        fx.backgroundFrontLayer.style.opacity = 1;
        fx.backgroundRearLayer.style.opacity = 0;
      }
    },
    /** @this Polymer.AppLayout.ElementWithBackground */
    tearDown: function tearDown() {
      delete this._fxFadeBackground;
    }
  });
</script>
<script>
  /**
   * Toggles the shadow property in app-header when content is scrolled to create a sense of depth
   * between the element and the content underneath.
   */
  Polymer.AppLayout.registerEffect('waterfall', {
    /**
     *  @this Polymer.AppLayout.ElementWithBackground
     */
    run: function run() {
      this.shadow = this.isOnScreen() && this.isContentBelow();
    }
  });
</script>
<script>
  (function() {
    function interpolate(progress, points, fn, ctx) {
      fn.apply(ctx, points.map(function(point) {
        return point[0] + (point[1] - point[0]) * progress;
      }));
    }

    /**
     * Transform the font size of a designated title element between two values based on the scroll
     * position.
     */
    Polymer.AppLayout.registerEffect('resize-title', {
      /** @this Polymer.AppLayout.ElementWithBackground */
      setUp: function setUp() {
        var title = this._getDOMRef('mainTitle');
        var condensedTitle = this._getDOMRef('condensedTitle');

        if (!condensedTitle) {
          console.warn('Scroll effect `resize-title`: undefined `condensed-title`');
          return false;
        }
        if (!title) {
          console.warn('Scroll effect `resize-title`: undefined `main-title`');
          return false;
        }

        condensedTitle.style.willChange = 'opacity';
        title.style.willChange = 'opacity';
        condensedTitle.style.webkitTransform = 'translateZ(0)';
        title.style.webkitTransform = 'translateZ(0)';
        condensedTitle.style.transform = 'translateZ(0)';
        title.style.transform = 'translateZ(0)';

        var titleClientRect = title.getBoundingClientRect();
        var condensedTitleClientRect = condensedTitle.getBoundingClientRect();
        var fx = {};

        fx.scale = parseInt(window.getComputedStyle(condensedTitle)['font-size'], 10) /
            parseInt(window.getComputedStyle(title)['font-size'], 10);
        fx.titleDX = titleClientRect.left - condensedTitleClientRect.left;
        fx.titleDY = titleClientRect.top - condensedTitleClientRect.top;
        fx.condensedTitle = condensedTitle;
        fx.title = title;

        this._fxResizeTitle = fx;
      },
      /** @this PolymerElement */
      run: function run(p, y) {
        var fx = this._fxResizeTitle;
        if (!this.condenses) {
          y = 0;
        }
        if (p >= 1) {
          fx.title.style.opacity = 0;
          fx.condensedTitle.style.opacity = 1;
        } else {
          fx.title.style.opacity = 1;
          fx.condensedTitle.style.opacity = 0;
        }
        interpolate(Math.min(1, p), [ [1, fx.scale], [0, -fx.titleDX], [y, y-fx.titleDY] ],
          function(scale, translateX, translateY) {
            this.transform('translate(' + translateX + 'px, ' + translateY + 'px) ' +
                'scale3d(' + scale + ', ' + scale + ', 1)', fx.title);
          }, this);
      },
      /** @this Polymer.AppLayout.ElementWithBackground */
      tearDown: function tearDown() {
        delete this._fxResizeTitle;
      }
    });
  })();
</script>
<script>
  /**
   * Vertically translate the background based on a factor of the scroll position.
   */
  Polymer.AppLayout.registerEffect('parallax-background', {
    /**
     * @param {{scalar: string}} config
     * @this Polymer.AppLayout.ElementWithBackground
     */
    setUp: function setUp(config) {
      var fx = {};
      var scalar = parseFloat(config.scalar);
      fx.background = this._getDOMRef('background');
      fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
      fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
      fx.deltaBg = fx.backgroundFrontLayer.offsetHeight - fx.background.offsetHeight;
      if (fx.deltaBg === 0) {
        if (isNaN(scalar)) {
          scalar = 0.8;
        }
        fx.deltaBg = this._dHeight * scalar;
      } else {
        if (isNaN(scalar)) {
          scalar = 1;
        }
        fx.deltaBg = fx.deltaBg * scalar;
      }
      this._fxParallaxBackground = fx;
    },
    /** @this Polymer.AppLayout.ElementWithBackground */
    run: function run(p, y) {
      var fx = this._fxParallaxBackground;
      this.transform('translate3d(0px, ' + (fx.deltaBg * Math.min(1, p)) + 'px, 0px)', fx.backgroundFrontLayer);
      if (fx.backgroundRearLayer) {
        this.transform('translate3d(0px, ' + (fx.deltaBg * Math.min(1, p)) + 'px, 0px)', fx.backgroundRearLayer);
      }
    },
    /** @this Polymer.AppLayout.ElementWithBackground */
    tearDown: function tearDown() {
      delete this._fxParallaxBackground;
    }
  });
</script>
<script>
  /**
   * Shorthand for the waterfall, resize-title, blend-background, and parallax-background effects.
   */
  Polymer.AppLayout.registerEffect('material', {
    /**
     * @this Polymer.AppLayout.ElementWithBackground
     */
    setUp: function setUp() {
      this.effects = 'waterfall resize-title blend-background parallax-background';
      return false;
    }
  });
</script>
<script>
  /**
   * Upon scrolling past a threshold, CSS transition the font size of a designated title element
   * between two values.
   */
  Polymer.AppLayout.registerEffect('resize-snapped-title', {
    /**
     * @this Polymer.AppLayout.ElementWithBackground
     */
    setUp: function setUp(config) {
      var title = this._getDOMRef('mainTitle');
      var condensedTitle = this._getDOMRef('condensedTitle');
      var duration = config.duration || '0.2s';
      var fx = {};

      if (!condensedTitle) {
        console.warn('Scroll effect `resize-snapped-title`: undefined `condensed-title`');
        return false;
      }
      if (!title) {
        console.warn('Scroll effect `resize-snapped-title`: undefined `main-title`');
        return false;
      }

      title.style.transitionProperty = 'opacity';
      title.style.transitionDuration = duration;
      condensedTitle.style.transitionProperty = 'opacity';
      condensedTitle.style.transitionDuration = duration;
      fx.condensedTitle = condensedTitle;
      fx.title = title;
      this._fxResizeSnappedTitle = fx;
    },
    /** @this Polymer.AppLayout.ElementWithBackground */
    run: function run(p, y) {
      var fx = this._fxResizeSnappedTitle;
      if (p > 0) {
        fx.title.style.opacity = 0;
        fx.condensedTitle.style.opacity = 1;
      } else {
        fx.title.style.opacity = 1;
        fx.condensedTitle.style.opacity = 0;
      }
    },
    /** @this Polymer.AppLayout.ElementWithBackground */
    tearDown: function tearDown() {
      var fx = this._fxResizeSnappedTitle;
      fx.title.style.transition = '';
      fx.condensedTitle.style.transition = '';
      delete this._fxResizeSnappedTitle;
    }
  });
</script>
<dom-module id="app-toolbar" assetpath="bower_components/app-layout/app-toolbar/">
  <template>
    <style>
      :host {
        @apply(--layout-horizontal);
        @apply(--layout-center);
        position: relative;
        height: 64px;
        padding: 0 16px;
        pointer-events: none;
        font-size: var(--app-toolbar-font-size, 20px);
      }

      ::content > * {
        pointer-events: auto;
      }

      ::content > paper-icon-button {
        /* paper-icon-button/issues/33 */
        font-size: 0;
      }

      ::content > [main-title],
      ::content > [condensed-title] {
        pointer-events: none;
        @apply(--layout-flex);
      }

      ::content > [bottom-item] {
        position: absolute;
        right: 0;
        bottom: 0;
        left: 0;
      }

      ::content > [top-item] {
        position: absolute;
        top: 0;
        right: 0;
        left: 0;
      }

      ::content > [spacer] {
        margin-left: 64px;
      }
    </style>

    <content></content>
  </template>

  <script>
    Polymer({
      is: 'app-toolbar'
    });
  </script>
</dom-module>
<script>
  (function() {
    'use strict';

    Polymer({
      is: 'iron-location',
      properties: {
        /**
         * The pathname component of the URL.
         */
        path: {
          type: String,
          notify: true,
          value: function() {
            return window.decodeURIComponent(window.location.pathname);
          }
        },
        /**
         * The query string portion of the URL.
         */
        query: {
          type: String,
          notify: true,
          value: function() {
            return window.location.search.slice(1);
          }
        },
        /**
         * The hash component of the URL.
         */
        hash: {
          type: String,
          notify: true,
          value: function() {
            return window.decodeURIComponent(window.location.hash.slice(1));
          }
        },
        /**
         * If the user was on a URL for less than `dwellTime` milliseconds, it
         * won't be added to the browser's history, but instead will be replaced
         * by the next entry.
         *
         * This is to prevent large numbers of entries from clogging up the user's
         * browser history. Disable by setting to a negative number.
         */
        dwellTime: {
          type: Number,
          value: 2000
        },

        /**
         * A regexp that defines the set of URLs that should be considered part
         * of this web app.
         *
         * Clicking on a link that matches this regex won't result in a full page
         * navigation, but will instead just update the URL state in place.
         *
         * This regexp is given everything after the origin in an absolute
         * URL. So to match just URLs that start with /search/ do:
         *     url-space-regex="^/search/"
         *
         * @type {string|RegExp}
         */
        urlSpaceRegex: {
          type: String,
          value: ''
        },

        /**
         * urlSpaceRegex, but coerced into a regexp.
         *
         * @type {RegExp}
         */
        _urlSpaceRegExp: {
          computed: '_makeRegExp(urlSpaceRegex)'
        },

        _lastChangedAt: {
          type: Number
        },

        _initialized: {
          type: Boolean,
          value: false
        }
      },
      hostAttributes: {
        hidden: true
      },
      observers: [
        '_updateUrl(path, query, hash)'
      ],
      attached: function() {
        this.listen(window, 'hashchange', '_hashChanged');
        this.listen(window, 'location-changed', '_urlChanged');
        this.listen(window, 'popstate', '_urlChanged');
        this.listen(/** @type {!HTMLBodyElement} */(document.body), 'click', '_globalOnClick');
        // Give a 200ms grace period to make initial redirects without any
        // additions to the user's history.
        this._lastChangedAt = window.performance.now() - (this.dwellTime - 200);

        this._initialized = true;
        this._urlChanged();
      },
      detached: function() {
        this.unlisten(window, 'hashchange', '_hashChanged');
        this.unlisten(window, 'location-changed', '_urlChanged');
        this.unlisten(window, 'popstate', '_urlChanged');
        this.unlisten(/** @type {!HTMLBodyElement} */(document.body), 'click', '_globalOnClick');
        this._initialized = false;
      },
      _hashChanged: function() {
        this.hash = window.decodeURIComponent(window.location.hash.substring(1));
      },
      _urlChanged: function() {
        // We want to extract all info out of the updated URL before we
        // try to write anything back into it.
        //
        // i.e. without _dontUpdateUrl we'd overwrite the new path with the old
        // one when we set this.hash. Likewise for query.
        this._dontUpdateUrl = true;
        this._hashChanged();
        this.path = window.decodeURIComponent(window.location.pathname);
        this.query = window.location.search.substring(1);
        this._dontUpdateUrl = false;
        this._updateUrl();
      },
      _getUrl: function() {
        var partiallyEncodedPath = window.encodeURI(
            this.path).replace(/\#/g, '%23').replace(/\?/g, '%3F');
        var partiallyEncodedQuery = '';
        if (this.query) {
          partiallyEncodedQuery = '?' + this.query.replace(/\#/g, '%23');
        }
        var partiallyEncodedHash = '';
        if (this.hash) {
          partiallyEncodedHash = '#' + window.encodeURI(this.hash);
        }
        return (
            partiallyEncodedPath + partiallyEncodedQuery + partiallyEncodedHash);
      },
      _updateUrl: function() {
        if (this._dontUpdateUrl || !this._initialized) {
          return;
        }
        if (this.path === window.decodeURIComponent(window.location.pathname) &&
            this.query === window.location.search.substring(1) &&
            this.hash === window.decodeURIComponent(
                window.location.hash.substring(1))) {
          // Nothing to do, the current URL is a representation of our properties.
          return;
        }
        var newUrl = this._getUrl();
        // Need to use a full URL in case the containing page has a base URI.
        var fullNewUrl = new URL(
            newUrl, window.location.protocol + '//' + window.location.host).href;
        var now = window.performance.now();
        var shouldReplace =
            this._lastChangedAt + this.dwellTime > now;
        this._lastChangedAt = now;
        if (shouldReplace) {
          window.history.replaceState({}, '', fullNewUrl);
        } else {
          window.history.pushState({}, '', fullNewUrl);
        }
        this.fire('location-changed', {}, {node: window});
      },
      /**
       * A necessary evil so that links work as expected. Does its best to
       * bail out early if possible.
       *
       * @param {MouseEvent} event .
       */
      _globalOnClick: function(event) {
        // If another event handler has stopped this event then there's nothing
        // for us to do. This can happen e.g. when there are multiple
        // iron-location elements in a page.
        if (event.defaultPrevented) {
          return;
        }
        var href = this._getSameOriginLinkHref(event);
        if (!href) {
          return;
        }
        event.preventDefault();
        // If the navigation is to the current page we shouldn't add a history
        // entry or fire a change event.
        if (href === window.location.href) {
          return;
        }
        window.history.pushState({}, '', href);
        this.fire('location-changed', {}, {node: window});
      },
      /**
       * Returns the absolute URL of the link (if any) that this click event
       * is clicking on, if we can and should override the resulting full
       * page navigation. Returns null otherwise.
       *
       * @param {MouseEvent} event .
       * @return {string?} .
       */
      _getSameOriginLinkHref: function(event) {
        // We only care about left-clicks.
        if (event.button !== 0) {
          return null;
        }
        // We don't want modified clicks, where the intent is to open the page
        // in a new tab.
        if (event.metaKey || event.ctrlKey) {
          return null;
        }
        var eventPath = Polymer.dom(event).path;
        var anchor = null;
        for (var i = 0; i < eventPath.length; i++) {
          var element = eventPath[i];
          if (element.tagName === 'A' && element.href) {
            anchor = element;
            break;
          }
        }

        // If there's no link there's nothing to do.
        if (!anchor) {
          return null;
        }

        // Target blank is a new tab, don't intercept.
        if (anchor.target === '_blank') {
          return null;
        }
        // If the link is for an existing parent frame, don't intercept.
        if ((anchor.target === '_top' ||
             anchor.target === '_parent') &&
            window.top !== window) {
          return null;
        }

        var href = anchor.href;

        // It only makes sense for us to intercept same-origin navigations.
        // pushState/replaceState don't work with cross-origin links.
        var url;
        if (document.baseURI != null) {
          url = new URL(href, /** @type {string} */(document.baseURI));
        } else {
          url = new URL(href);
        }

        var origin;

        // IE Polyfill
        if (window.location.origin) {
          origin = window.location.origin;
        } else {
          origin = window.location.protocol + '//' + window.location.hostname;

          if (window.location.port) {
            origin += ':' + window.location.port;
          }
        }

        if (url.origin !== origin) {
          return null;
        }
        var normalizedHref = url.pathname + url.search + url.hash;

        // If we've been configured not to handle this url... don't handle it!
        if (this._urlSpaceRegExp &&
            !this._urlSpaceRegExp.test(normalizedHref)) {
          return null;
        }
        // Need to use a full URL in case the containing page has a base URI.
        var fullNormalizedHref = new URL(
            normalizedHref, window.location.href).href;
        return fullNormalizedHref;
      },
      _makeRegExp: function(urlSpaceRegex) {
        return RegExp(urlSpaceRegex);
      }
    });
  })();
</script>
<script>
  'use strict';

  Polymer({
    is: 'iron-query-params',
    properties: {
      paramsString: {
        type: String,
        notify: true,
        observer: 'paramsStringChanged',
      },
      paramsObject: {
        type: Object,
        notify: true,
        value: function() {
          return {};
        }
      },
      _dontReact: {
        type: Boolean,
        value: false
      }
    },
    hostAttributes: {
      hidden: true
    },
    observers: [
      'paramsObjectChanged(paramsObject.*)'
    ],
    paramsStringChanged: function() {
      this._dontReact = true;
      this.paramsObject = this._decodeParams(this.paramsString);
      this._dontReact = false;
    },
    paramsObjectChanged: function() {
      if (this._dontReact) {
        return;
      }
      this.paramsString = this._encodeParams(this.paramsObject)
          .replace(/%3F/g, '?').replace(/%2F/g, '/').replace(/'/g, '%27');
    },
    _encodeParams: function(params) {
      var encodedParams = [];
      for (var key in params) {
        var value = params[key];
        if (value === '') {
          encodedParams.push(encodeURIComponent(key));
        } else if (value) {
          encodedParams.push(
              encodeURIComponent(key) +
              '=' +
              encodeURIComponent(value.toString())
          );
        }
      }
      return encodedParams.join('&');
    },
    _decodeParams: function(paramString) {
      var params = {};

      // Work around a bug in decodeURIComponent where + is not
      // converted to spaces:
      paramString = (paramString || '').replace(/\+/g, '%20');

      var paramList = paramString.split('&');
      for (var i = 0; i < paramList.length; i++) {
        var param = paramList[i].split('=');
        if (param[0]) {
          params[decodeURIComponent(param[0])] =
              decodeURIComponent(param[1] || '');
        }
      }
      return params;
    }
  });
</script>
<script>
  (function() {
    'use strict';

    /**
     * Provides bidirectional mapping between `path` and `queryParams` and a
     * app-route compatible `route` object.
     *
     * For more information, see the docs for `app-route-converter`.
     *
     * @polymerBehavior
     */
    Polymer.AppRouteConverterBehavior = {
      properties: {
        /**
         * A model representing the deserialized path through the route tree, as
         * well as the current queryParams.
         *
         * A route object is the kernel of the routing system. It is intended to
         * be fed into consuming elements such as `app-route`.
         *
         * @type {?Object}
         */
        route: {
          type: Object,
          notify: true
        },

        /**
         * A set of key/value pairs that are universally accessible to branches of
         * the route tree.
         *
         * @type {?Object}
         */
        queryParams: {
          type: Object,
          notify: true
        },

        /**
         * The serialized path through the route tree. This corresponds to the
         * `window.location.pathname` value, and will update to reflect changes
         * to that value.
         */
        path: {
          type: String,
          notify: true,
        }
      },

      observers: [
        '_locationChanged(path, queryParams)',
        '_routeChanged(route.prefix, route.path)',
        '_routeQueryParamsChanged(route.__queryParams)'
      ],

      created: function() {
        this.linkPaths('route.__queryParams', 'queryParams');
        this.linkPaths('queryParams', 'route.__queryParams');
      },

      /**
       * Handler called when the path or queryParams change.
       */
      _locationChanged: function() {
        if (this.route &&
            this.route.path === this.path &&
            this.queryParams === this.route.__queryParams) {
          return;
        }
        this.route = {
          prefix: '',
          path: this.path,
          __queryParams: this.queryParams
        };
      },

      /**
       * Handler called when the route prefix and route path change.
       */
      _routeChanged: function() {
        if (!this.route) {
          return;
        }

        this.path = this.route.prefix + this.route.path;
      },

      /**
       * Handler called when the route queryParams change.
       *
       * @param  {Object} queryParams A set of key/value pairs that are
       * universally accessible to branches of the route tree.
       */
      _routeQueryParamsChanged: function(queryParams) {
        if (!this.route) {
          return;
        }
        this.queryParams = queryParams;
      }
    };
  })();
</script>
<dom-module id="app-location" assetpath="bower_components/app-route/">
  <template>
    <iron-location path="{{__path}}" query="{{__query}}" hash="{{__hash}}" url-space-regex="{{urlSpaceRegex}}">
    </iron-location>
    <iron-query-params params-string="{{__query}}" params-object="{{queryParams}}">
    </iron-query-params>
  </template>
  <script>
    (function() {
      'use strict';

      Polymer({
        is: 'app-location',

        properties: {
          /**
           * A model representing the deserialized path through the route tree, as
           * well as the current queryParams.
           */
          route: {
            type: Object,
            notify: true
          },

          /**
           * In many scenarios, it is convenient to treat the `hash` as a stand-in
           * alternative to the `path`. For example, if deploying an app to a static
           * web server (e.g., Github Pages) - where one does not have control over
           * server-side routing - it is usually a better experience to use the hash
           * to represent paths through one's app.
           *
           * When this property is set to true, the `hash` will be used in place of

           * the `path` for generating a `route`.
           */
          useHashAsPath: {
            type: Boolean,
            value: false
          },

          /**
           * A regexp that defines the set of URLs that should be considered part
           * of this web app.
           *
           * Clicking on a link that matches this regex won't result in a full page
           * navigation, but will instead just update the URL state in place.
           *
           * This regexp is given everything after the origin in an absolute
           * URL. So to match just URLs that start with /search/ do:
           *     url-space-regex="^/search/"
           *
           * @type {string|RegExp}
           */
          urlSpaceRegex: {
            type: String,
            notify: true
          },

          /**
           * A set of key/value pairs that are universally accessible to branches
           * of the route tree.
           */
          __queryParams: {
            type: Object
          },

          /**
           * The pathname component of the current URL.
           */
          __path: {
            type: String
          },

          /**
           * The query string portion of the current URL.
           */
          __query: {
            type: String
          },

          /**
           * The hash portion of the current URL.
           */
          __hash: {
            type: String
          },

          /**
           * The route path, which will be either the hash or the path, depending
           * on useHashAsPath.
           */
          path: {
            type: String,
            observer: '__onPathChanged'
          }
        },

        behaviors: [Polymer.AppRouteConverterBehavior],

        observers: [
          '__computeRoutePath(useHashAsPath, __hash, __path)'
        ],

        __computeRoutePath: function() {
          this.path = this.useHashAsPath ? this.__hash : this.__path;
        },

        __onPathChanged: function() {
          if (!this._readied) {
            return;
          }

          if (this.useHashAsPath) {
            this.__hash = this.path;
          } else {
            this.__path = this.path;
          }
        }
      });
    })();
  </script>
</dom-module>
<script>
  (function() {
    'use strict';

    Polymer({
      is: 'app-route',

      properties: {
        /**
         * The URL component managed by this element.
         */
        route: {
          type: Object,
          notify: true
        },

        /**
         * The pattern of slash-separated segments to match `path` against.
         *
         * For example the pattern "/foo" will match "/foo" or "/foo/bar"
         * but not "/foobar".
         *
         * Path segments like `/:named` are mapped to properties on the `data` object.
         */
        pattern: {
          type: String
        },

        /**
         * The parameterized values that are extracted from the route as
         * described by `pattern`.
         */
        data: {
          type: Object,
          value: function() {return {};},
          notify: true
        },

        /**
         * @type {?Object}
         */
        queryParams: {
          type: Object,
          value: function() {
            return {};
          },
          notify: true
        },

        /**
         * The part of `path` NOT consumed by `pattern`.
         */
        tail: {
          type: Object,
          value: function() {return {path: null, prefix: null, __queryParams: null};},
          notify: true
        },

        active: {
          type: Boolean,
          notify: true,
          readOnly: true
        },

        _queryParamsUpdating: {
          type: Boolean,
          value: false
        },
        /**
         * @type {?string}
         */
        _matched: {
          type: String,
          value: ''
        }
      },

      observers: [
        '__tryToMatch(route.path, pattern)',
        '__updatePathOnDataChange(data.*)',
        '__tailPathChanged(tail.path)',
        '__routeQueryParamsChanged(route.__queryParams)',
        '__tailQueryParamsChanged(tail.__queryParams)',
        '__queryParamsChanged(queryParams.*)'
      ],

      created: function() {
        this.linkPaths('route.__queryParams', 'tail.__queryParams');
        this.linkPaths('tail.__queryParams', 'route.__queryParams');
      },

      /**
       * Deal with the query params object being assigned to wholesale.
       * @export
       */
      __routeQueryParamsChanged: function(queryParams) {
        if (queryParams && this.tail) {
          this.set('tail.__queryParams', queryParams);

          if (!this.active || this._queryParamsUpdating) {
            return;
          }

          // Copy queryParams and track whether there are any differences compared
          // to the existing query params.
          var copyOfQueryParams = {};
          var anythingChanged = false;
          for (var key in queryParams) {
            copyOfQueryParams[key] = queryParams[key];
            if (anythingChanged ||
                !this.queryParams ||
                queryParams[key] !== this.queryParams[key]) {
              anythingChanged = true;
            }
          }
          // Need to check whether any keys were deleted
          for (var key in this.queryParams) {
            if (anythingChanged || !(key in queryParams)) {
              anythingChanged = true;
              break;
            }
          }

          if (!anythingChanged) {
            return;
          }
          this._queryParamsUpdating = true;
          this.set('queryParams', copyOfQueryParams);
          this._queryParamsUpdating = false;
        }
      },

      /**
       * @export
       */
      __tailQueryParamsChanged: function(queryParams) {
        if (queryParams && this.route) {
          this.set('route.__queryParams', queryParams);
        }
      },

      /**
       * @export
       */
      __queryParamsChanged: function(changes) {
        if (!this.active || this._queryParamsUpdating) {
          return;
        }

        this.set('route.__' + changes.path, changes.value);
      },

      __resetProperties: function() {
        this._setActive(false);
        this._matched = null;
        //this.tail = { path: null, prefix: null, queryParams: null };
        //this.data = {};
      },

      /**
       * @export
       */
      __tryToMatch: function() {
        if (!this.route) {
          return;
        }
        var path = this.route.path;
        var pattern = this.pattern;
        if (!pattern) {
          return;
        }

        if (!path) {
          this.__resetProperties();
          return;
        }

        var remainingPieces = path.split('/');
        var patternPieces = pattern.split('/');

        var matched = [];
        var namedMatches = {};

        for (var i=0; i < patternPieces.length; i++) {
          var patternPiece = patternPieces[i];
          if (!patternPiece && patternPiece !== '') {
            break;
          }
          var pathPiece = remainingPieces.shift();

          // We don't match this path.
          if (!pathPiece && pathPiece !== '') {
            this.__resetProperties();
            return;
          }
          matched.push(pathPiece);

          if (patternPiece.charAt(0) == ':') {
            namedMatches[patternPiece.slice(1)] = pathPiece;
          } else if (patternPiece !== pathPiece) {
            this.__resetProperties();
            return;
          }
        }

        this._matched = matched.join('/');

        // Properties that must be updated atomically.
        var propertyUpdates = {};

        //this.active
        if (!this.active) {
          propertyUpdates.active = true;
        }

        // this.tail
        var tailPrefix = this.route.prefix + this._matched;
        var tailPath = remainingPieces.join('/');
        if (remainingPieces.length > 0) {
          tailPath = '/' + tailPath;
        }
        if (!this.tail ||
            this.tail.prefix !== tailPrefix ||
            this.tail.path !== tailPath) {
          propertyUpdates.tail = {
            prefix: tailPrefix,
            path: tailPath,
            __queryParams: this.route.__queryParams
          };
        }

        // this.data
        propertyUpdates.data = namedMatches;
        this._dataInUrl = {};
        for (var key in namedMatches) {
          this._dataInUrl[key] = namedMatches[key];
        }

        this.__setMulti(propertyUpdates);
      },

      /**
       * @export
       */
      __tailPathChanged: function(path) {
        if (!this.active) {
          return;
        }
        var tailPath = path;
        var newPath = this._matched;
        if (tailPath) {
          if (tailPath.charAt(0) !== '/') {
            tailPath = '/' + tailPath;
          }
          newPath += tailPath;
        }
        this.set('route.path', newPath);
      },

      /**
       * @export
       */
      __updatePathOnDataChange: function() {
        if (!this.route || !this.active) {
          return;
        }
        var newPath = this.__getLink({});
        var oldPath = this.__getLink(this._dataInUrl);
        if (newPath === oldPath) {
          return;
        }
        this.set('route.path', newPath);
      },

      __getLink: function(overrideValues) {
        var values = {tail: null};
        for (var key in this.data) {
          values[key] = this.data[key];
        }
        for (var key in overrideValues) {
          values[key] = overrideValues[key];
        }
        var patternPieces = this.pattern.split('/');
        var interp = patternPieces.map(function(value) {
          if (value[0] == ':') {
            value = values[value.slice(1)];
          }
          return value;
        }, this);
        if (values.tail && values.tail.path) {
          if (interp.length > 0 && values.tail.path.charAt(0) === '/') {
            interp.push(values.tail.path.slice(1));
          } else {
            interp.push(values.tail.path);
          }
        }
        return interp.join('/');
      },

      __setMulti: function(setObj) {
        // HACK(rictic): skirting around 1.0's lack of a setMulti by poking at
        //     internal data structures. I would not advise that you copy this
        //     example.
        //
        //     In the future this will be a feature of Polymer itself.
        //     See: https://github.com/Polymer/polymer/issues/3640
        //
        //     Hacking around with private methods like this is juggling footguns,
        //     and is likely to have unexpected and unsupported rough edges.
        //
        //     Be ye so warned.
        for (var property in setObj) {
          this._propertySetter(property, setObj[property]);
        }
        //notify in a specific order
        if (setObj.data !== undefined) {
          this._pathEffector('data', this.data);
          this._notifyChange('data');
        }
        if (setObj.active !== undefined) {
          this._pathEffector('active', this.active);
          this._notifyChange('active');
        }
        if (setObj.tail !== undefined) {
          this._pathEffector('tail', this.tail);
          this._notifyChange('tail');
        }

      }
    });
  })();
</script>
<script>

  /**
   * @param {!Function} selectCallback
   * @constructor
   */
  Polymer.IronSelection = function(selectCallback) {
    this.selection = [];
    this.selectCallback = selectCallback;
  };

  Polymer.IronSelection.prototype = {

    /**
     * Retrieves the selected item(s).
     *
     * @method get
     * @returns Returns the selected item(s). If the multi property is true,
     * `get` will return an array, otherwise it will return
     * the selected item or undefined if there is no selection.
     */
    get: function() {
      return this.multi ? this.selection.slice() : this.selection[0];
    },

    /**
     * Clears all the selection except the ones indicated.
     *
     * @method clear
     * @param {Array} excludes items to be excluded.
     */
    clear: function(excludes) {
      this.selection.slice().forEach(function(item) {
        if (!excludes || excludes.indexOf(item) < 0) {
          this.setItemSelected(item, false);
        }
      }, this);
    },

    /**
     * Indicates if a given item is selected.
     *
     * @method isSelected
     * @param {*} item The item whose selection state should be checked.
     * @returns Returns true if `item` is selected.
     */
    isSelected: function(item) {
      return this.selection.indexOf(item) >= 0;
    },

    /**
     * Sets the selection state for a given item to either selected or deselected.
     *
     * @method setItemSelected
     * @param {*} item The item to select.
     * @param {boolean} isSelected True for selected, false for deselected.
     */
    setItemSelected: function(item, isSelected) {
      if (item != null) {
        if (isSelected !== this.isSelected(item)) {
          // proceed to update selection only if requested state differs from current
          if (isSelected) {
            this.selection.push(item);
          } else {
            var i = this.selection.indexOf(item);
            if (i >= 0) {
              this.selection.splice(i, 1);
            }
          }
          if (this.selectCallback) {
            this.selectCallback(item, isSelected);
          }
        }
      }
    },

    /**
     * Sets the selection state for a given item. If the `multi` property
     * is true, then the selected state of `item` will be toggled; otherwise
     * the `item` will be selected.
     *
     * @method select
     * @param {*} item The item to select.
     */
    select: function(item) {
      if (this.multi) {
        this.toggle(item);
      } else if (this.get() !== item) {
        this.setItemSelected(this.get(), false);
        this.setItemSelected(item, true);
      }
    },

    /**
     * Toggles the selection state for `item`.
     *
     * @method toggle
     * @param {*} item The item to toggle.
     */
    toggle: function(item) {
      this.setItemSelected(item, !this.isSelected(item));
    }

  };

</script>
<script>

  /** @polymerBehavior */
  Polymer.IronSelectableBehavior = {

      /**
       * Fired when iron-selector is activated (selected or deselected).
       * It is fired before the selected items are changed.
       * Cancel the event to abort selection.
       *
       * @event iron-activate
       */

      /**
       * Fired when an item is selected
       *
       * @event iron-select
       */

      /**
       * Fired when an item is deselected
       *
       * @event iron-deselect
       */

      /**
       * Fired when the list of selectable items changes (e.g., items are
       * added or removed). The detail of the event is a mutation record that
       * describes what changed.
       *
       * @event iron-items-changed
       */

    properties: {

      /**
       * If you want to use an attribute value or property of an element for
       * `selected` instead of the index, set this to the name of the attribute
       * or property. Hyphenated values are converted to camel case when used to
       * look up the property of a selectable element. Camel cased values are
       * *not* converted to hyphenated values for attribute lookup. It's
       * recommended that you provide the hyphenated form of the name so that
       * selection works in both cases. (Use `attr-or-property-name` instead of
       * `attrOrPropertyName`.)
       */
      attrForSelected: {
        type: String,
        value: null
      },

      /**
       * Gets or sets the selected element. The default is to use the index of the item.
       * @type {string|number}
       */
      selected: {
        type: String,
        notify: true
      },

      /**
       * Returns the currently selected item.
       *
       * @type {?Object}
       */
      selectedItem: {
        type: Object,
        readOnly: true,
        notify: true
      },

      /**
       * The event that fires from items when they are selected. Selectable
       * will listen for this event from items and update the selection state.
       * Set to empty string to listen to no events.
       */
      activateEvent: {
        type: String,
        value: 'tap',
        observer: '_activateEventChanged'
      },

      /**
       * This is a CSS selector string.  If this is set, only items that match the CSS selector
       * are selectable.
       */
      selectable: String,

      /**
       * The class to set on elements when selected.
       */
      selectedClass: {
        type: String,
        value: 'iron-selected'
      },

      /**
       * The attribute to set on elements when selected.
       */
      selectedAttribute: {
        type: String,
        value: null
      },

      /**
       * Default fallback if the selection based on selected with `attrForSelected`
       * is not found.
       */
      fallbackSelection: {
        type: String,
        value: null
      },

      /**
       * The list of items from which a selection can be made.
       */
      items: {
        type: Array,
        readOnly: true,
        notify: true,
        value: function() {
          return [];
        }
      },

      /**
       * The set of excluded elements where the key is the `localName`
       * of the element that will be ignored from the item list.
       *
       * @default {template: 1}
       */
      _excludedLocalNames: {
        type: Object,
        value: function() {
          return {
            'template': 1
          };
        }
      }
    },

    observers: [
      '_updateAttrForSelected(attrForSelected)',
      '_updateSelected(selected)',
      '_checkFallback(fallbackSelection)'
    ],

    created: function() {
      this._bindFilterItem = this._filterItem.bind(this);
      this._selection = new Polymer.IronSelection(this._applySelection.bind(this));
    },

    attached: function() {
      this._observer = this._observeItems(this);
      this._updateItems();
      if (!this._shouldUpdateSelection) {
        this._updateSelected();
      }
      this._addListener(this.activateEvent);
    },

    detached: function() {
      if (this._observer) {
        Polymer.dom(this).unobserveNodes(this._observer);
      }
      this._removeListener(this.activateEvent);
    },

    /**
     * Returns the index of the given item.
     *
     * @method indexOf
     * @param {Object} item
     * @returns Returns the index of the item
     */
    indexOf: function(item) {
      return this.items.indexOf(item);
    },

    /**
     * Selects the given value.
     *
     * @method select
     * @param {string|number} value the value to select.
     */
    select: function(value) {
      this.selected = value;
    },

    /**
     * Selects the previous item.
     *
     * @method selectPrevious
     */
    selectPrevious: function() {
      var length = this.items.length;
      var index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
      this.selected = this._indexToValue(index);
    },

    /**
     * Selects the next item.
     *
     * @method selectNext
     */
    selectNext: function() {
      var index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
      this.selected = this._indexToValue(index);
    },

    /**
     * Selects the item at the given index.
     *
     * @method selectIndex
     */
    selectIndex: function(index) {
      this.select(this._indexToValue(index));
    },

    /**
     * Force a synchronous update of the `items` property.
     *
     * NOTE: Consider listening for the `iron-items-changed` event to respond to
     * updates to the set of selectable items after updates to the DOM list and
     * selection state have been made.
     *
     * WARNING: If you are using this method, you should probably consider an
     * alternate approach. Synchronously querying for items is potentially
     * slow for many use cases. The `items` property will update asynchronously
     * on its own to reflect selectable items in the DOM.
     */
    forceSynchronousItemUpdate: function() {
      this._updateItems();
    },

    get _shouldUpdateSelection() {
      return this.selected != null;
    },

    _checkFallback: function() {
      if (this._shouldUpdateSelection) {
        this._updateSelected();
      }
    },

    _addListener: function(eventName) {
      this.listen(this, eventName, '_activateHandler');
    },

    _removeListener: function(eventName) {
      this.unlisten(this, eventName, '_activateHandler');
    },

    _activateEventChanged: function(eventName, old) {
      this._removeListener(old);
      this._addListener(eventName);
    },

    _updateItems: function() {
      var nodes = Polymer.dom(this).queryDistributedElements(this.selectable || '*');
      nodes = Array.prototype.filter.call(nodes, this._bindFilterItem);
      this._setItems(nodes);
    },

    _updateAttrForSelected: function() {
      if (this._shouldUpdateSelection) {
        this.selected = this._indexToValue(this.indexOf(this.selectedItem));
      }
    },

    _updateSelected: function() {
      this._selectSelected(this.selected);
    },

    _selectSelected: function(selected) {
      this._selection.select(this._valueToItem(this.selected));
      // Check for items, since this array is populated only when attached
      // Since Number(0) is falsy, explicitly check for undefined
      if (this.fallbackSelection && this.items.length && (this._selection.get() === undefined)) {
        this.selected = this.fallbackSelection;
      }
    },

    _filterItem: function(node) {
      return !this._excludedLocalNames[node.localName];
    },

    _valueToItem: function(value) {
      return (value == null) ? null : this.items[this._valueToIndex(value)];
    },

    _valueToIndex: function(value) {
      if (this.attrForSelected) {
        for (var i = 0, item; item = this.items[i]; i++) {
          if (this._valueForItem(item) == value) {
            return i;
          }
        }
      } else {
        return Number(value);
      }
    },

    _indexToValue: function(index) {
      if (this.attrForSelected) {
        var item = this.items[index];
        if (item) {
          return this._valueForItem(item);
        }
      } else {
        return index;
      }
    },

    _valueForItem: function(item) {
      var propValue = item[Polymer.CaseMap.dashToCamelCase(this.attrForSelected)];
      return propValue != undefined ? propValue : item.getAttribute(this.attrForSelected);
    },

    _applySelection: function(item, isSelected) {
      if (this.selectedClass) {
        this.toggleClass(this.selectedClass, isSelected, item);
      }
      if (this.selectedAttribute) {
        this.toggleAttribute(this.selectedAttribute, isSelected, item);
      }
      this._selectionChange();
      this.fire('iron-' + (isSelected ? 'select' : 'deselect'), {item: item});
    },

    _selectionChange: function() {
      this._setSelectedItem(this._selection.get());
    },

    // observe items change under the given node.
    _observeItems: function(node) {
      return Polymer.dom(node).observeNodes(function(mutation) {
        this._updateItems();

        if (this._shouldUpdateSelection) {
          this._updateSelected();
        }

        // Let other interested parties know about the change so that
        // we don't have to recreate mutation observers everywhere.
        this.fire('iron-items-changed', mutation, {
          bubbles: false,
          cancelable: false
        });
      });
    },

    _activateHandler: function(e) {
      var t = e.target;
      var items = this.items;
      while (t && t != this) {
        var i = items.indexOf(t);
        if (i >= 0) {
          var value = this._indexToValue(i);
          this._itemActivate(value, t);
          return;
        }
        t = t.parentNode;
      }
    },

    _itemActivate: function(value, item) {
      if (!this.fire('iron-activate',
          {selected: value, item: item}, {cancelable: true}).defaultPrevented) {
        this.select(value);
      }
    }

  };

</script>
<script>
  /** @polymerBehavior Polymer.IronMultiSelectableBehavior */
  Polymer.IronMultiSelectableBehaviorImpl = {
    properties: {

      /**
       * If true, multiple selections are allowed.
       */
      multi: {
        type: Boolean,
        value: false,
        observer: 'multiChanged'
      },

      /**
       * Gets or sets the selected elements. This is used instead of `selected` when `multi`
       * is true.
       */
      selectedValues: {
        type: Array,
        notify: true
      },

      /**
       * Returns an array of currently selected items.
       */
      selectedItems: {
        type: Array,
        readOnly: true,
        notify: true
      },

    },

    observers: [
      '_updateSelected(selectedValues.splices)'
    ],

    /**
     * Selects the given value. If the `multi` property is true, then the selected state of the
     * `value` will be toggled; otherwise the `value` will be selected.
     *
     * @method select
     * @param {string|number} value the value to select.
     */
    select: function(value) {
      if (this.multi) {
        if (this.selectedValues) {
          this._toggleSelected(value);
        } else {
          this.selectedValues = [value];
        }
      } else {
        this.selected = value;
      }
    },

    multiChanged: function(multi) {
      this._selection.multi = multi;
    },

    get _shouldUpdateSelection() {
      return this.selected != null ||
        (this.selectedValues != null && this.selectedValues.length);
    },

    _updateAttrForSelected: function() {
      if (!this.multi) {
        Polymer.IronSelectableBehavior._updateAttrForSelected.apply(this);
      } else if (this._shouldUpdateSelection) {
        this.selectedValues = this.selectedItems.map(function(selectedItem) {
          return this._indexToValue(this.indexOf(selectedItem));
        }, this).filter(function(unfilteredValue) {
          return unfilteredValue != null;
        }, this);
      }
    },

    _updateSelected: function() {
      if (this.multi) {
        this._selectMulti(this.selectedValues);
      } else {
        this._selectSelected(this.selected);
      }
    },

    _selectMulti: function(values) {
      if (values) {
        var selectedItems = this._valuesToItems(values);
        // clear all but the current selected items
        this._selection.clear(selectedItems);
        // select only those not selected yet
        for (var i = 0; i < selectedItems.length; i++) {
          this._selection.setItemSelected(selectedItems[i], true);
        }
        // Check for items, since this array is populated only when attached
        if (this.fallbackSelection && this.items.length && !this._selection.get().length) {
          var fallback = this._valueToItem(this.fallbackSelection);
          if (fallback) {
            this.selectedValues = [this.fallbackSelection];
          }
        }
      } else {
        this._selection.clear();
      }
    },

    _selectionChange: function() {
      var s = this._selection.get();
      if (this.multi) {
        this._setSelectedItems(s);
      } else {
        this._setSelectedItems([s]);
        this._setSelectedItem(s);
      }
    },

    _toggleSelected: function(value) {
      var i = this.selectedValues.indexOf(value);
      var unselected = i < 0;
      if (unselected) {
        this.push('selectedValues',value);
      } else {
        this.splice('selectedValues',i,1);
      }
    },

    _valuesToItems: function(values) {
      return (values == null) ? null : values.map(function(value) {
        return this._valueToItem(value);
      }, this);
    }
  };

  /** @polymerBehavior */
  Polymer.IronMultiSelectableBehavior = [
    Polymer.IronSelectableBehavior,
    Polymer.IronMultiSelectableBehaviorImpl
  ];

</script>
<script>
  /**
  `iron-selector` is an element which can be used to manage a list of elements
  that can be selected.  Tapping on the item will make the item selected.  The `selected` indicates
  which item is being selected.  The default is to use the index of the item.

  Example:

      <iron-selector selected="0">
        <div>Item 1</div>
        <div>Item 2</div>
        <div>Item 3</div>
      </iron-selector>

  If you want to use the attribute value of an element for `selected` instead of the index,
  set `attrForSelected` to the name of the attribute.  For example, if you want to select item by
  `name`, set `attrForSelected` to `name`.

  Example:

      <iron-selector attr-for-selected="name" selected="foo">
        <div name="foo">Foo</div>
        <div name="bar">Bar</div>
        <div name="zot">Zot</div>
      </iron-selector>

  You can specify a default fallback with `fallbackSelection` in case the `selected` attribute does
  not match the `attrForSelected` attribute of any elements.

  Example:

        <iron-selector attr-for-selected="name" selected="non-existing"
                       fallback-selection="default">
          <div name="foo">Foo</div>
          <div name="bar">Bar</div>
          <div name="default">Default</div>
        </iron-selector>

  Note: When the selector is multi, the selection will set to `fallbackSelection` iff
  the number of matching elements is zero.

  `iron-selector` is not styled. Use the `iron-selected` CSS class to style the selected element.

  Example:

      <style>
        .iron-selected {
          background: #eee;
        }
      </style>

      ...

      <iron-selector selected="0">
        <div>Item 1</div>
        <div>Item 2</div>
        <div>Item 3</div>
      </iron-selector>

  @demo demo/index.html
  */

  Polymer({

    is: 'iron-selector',

    behaviors: [
      Polymer.IronMultiSelectableBehavior
    ]

  });

</script>
<script>

  (function() {

    // monostate data
    var metaDatas = {};
    var metaArrays = {};
    var singleton = null;

    Polymer.IronMeta = Polymer({

      is: 'iron-meta',

      properties: {

        /**
         * The type of meta-data.  All meta-data of the same type is stored
         * together.
         */
        type: {
          type: String,
          value: 'default',
          observer: '_typeChanged'
        },

        /**
         * The key used to store `value` under the `type` namespace.
         */
        key: {
          type: String,
          observer: '_keyChanged'
        },

        /**
         * The meta-data to store or retrieve.
         */
        value: {
          type: Object,
          notify: true,
          observer: '_valueChanged'
        },

        /**
         * If true, `value` is set to the iron-meta instance itself.
         */
         self: {
          type: Boolean,
          observer: '_selfChanged'
        },

        /**
         * Array of all meta-data values for the given type.
         */
        list: {
          type: Array,
          notify: true
        }

      },

      hostAttributes: {
        hidden: true
      },

      /**
       * Only runs if someone invokes the factory/constructor directly
       * e.g. `new Polymer.IronMeta()`
       *
       * @param {{type: (string|undefined), key: (string|undefined), value}=} config
       */
      factoryImpl: function(config) {
        if (config) {
          for (var n in config) {
            switch(n) {
              case 'type':
              case 'key':
              case 'value':
                this[n] = config[n];
                break;
            }
          }
        }
      },

      created: function() {
        // TODO(sjmiles): good for debugging?
        this._metaDatas = metaDatas;
        this._metaArrays = metaArrays;
      },

      _keyChanged: function(key, old) {
        this._resetRegistration(old);
      },

      _valueChanged: function(value) {
        this._resetRegistration(this.key);
      },

      _selfChanged: function(self) {
        if (self) {
          this.value = this;
        }
      },

      _typeChanged: function(type) {
        this._unregisterKey(this.key);
        if (!metaDatas[type]) {
          metaDatas[type] = {};
        }
        this._metaData = metaDatas[type];
        if (!metaArrays[type]) {
          metaArrays[type] = [];
        }
        this.list = metaArrays[type];
        this._registerKeyValue(this.key, this.value);
      },

      /**
       * Retrieves meta data value by key.
       *
       * @method byKey
       * @param {string} key The key of the meta-data to be returned.
       * @return {*}
       */
      byKey: function(key) {
        return this._metaData && this._metaData[key];
      },

      _resetRegistration: function(oldKey) {
        this._unregisterKey(oldKey);
        this._registerKeyValue(this.key, this.value);
      },

      _unregisterKey: function(key) {
        this._unregister(key, this._metaData, this.list);
      },

      _registerKeyValue: function(key, value) {
        this._register(key, value, this._metaData, this.list);
      },

      _register: function(key, value, data, list) {
        if (key && data && value !== undefined) {
          data[key] = value;
          list.push(value);
        }
      },

      _unregister: function(key, data, list) {
        if (key && data) {
          if (key in data) {
            var value = data[key];
            delete data[key];
            this.arrayDelete(list, value);
          }
        }
      }

    });

    Polymer.IronMeta.getIronMeta = function getIronMeta() {
       if (singleton === null) {
         singleton = new Polymer.IronMeta();
       }
       return singleton;
     };

    /**
    `iron-meta-query` can be used to access infomation stored in `iron-meta`.

    Examples:

    If I create an instance like this:

        <iron-meta key="info" value="foo/bar"></iron-meta>

    Note that value="foo/bar" is the metadata I've defined. I could define more
    attributes or use child nodes to define additional metadata.

    Now I can access that element (and it's metadata) from any `iron-meta-query` instance:

         var value = new Polymer.IronMetaQuery({key: 'info'}).value;

    @group Polymer Iron Elements
    @element iron-meta-query
    */
    Polymer.IronMetaQuery = Polymer({

      is: 'iron-meta-query',

      properties: {

        /**
         * The type of meta-data.  All meta-data of the same type is stored
         * together.
         */
        type: {
          type: String,
          value: 'default',
          observer: '_typeChanged'
        },

        /**
         * Specifies a key to use for retrieving `value` from the `type`
         * namespace.
         */
        key: {
          type: String,
          observer: '_keyChanged'
        },

        /**
         * The meta-data to store or retrieve.
         */
        value: {
          type: Object,
          notify: true,
          readOnly: true
        },

        /**
         * Array of all meta-data values for the given type.
         */
        list: {
          type: Array,
          notify: true
        }

      },

      /**
       * Actually a factory method, not a true constructor. Only runs if
       * someone invokes it directly (via `new Polymer.IronMeta()`);
       *
       * @param {{type: (string|undefined), key: (string|undefined)}=} config
       */
      factoryImpl: function(config) {
        if (config) {
          for (var n in config) {
            switch(n) {
              case 'type':
              case 'key':
                this[n] = config[n];
                break;
            }
          }
        }
      },

      created: function() {
        // TODO(sjmiles): good for debugging?
        this._metaDatas = metaDatas;
        this._metaArrays = metaArrays;
      },

      _keyChanged: function(key) {
        this._setValue(this._metaData && this._metaData[key]);
      },

      _typeChanged: function(type) {
        this._metaData = metaDatas[type];
        this.list = metaArrays[type];
        if (this.key) {
          this._keyChanged(this.key);
        }
      },

      /**
       * Retrieves meta data value by key.
       * @param {string} key The key of the meta-data to be returned.
       * @return {*}
       */
      byKey: function(key) {
        return this._metaData && this._metaData[key];
      }

    });

  })();
</script>
<dom-module id="iron-icon" assetpath="bower_components/iron-icon/">
  <template>
    <style>
      :host {
        @apply(--layout-inline);
        @apply(--layout-center-center);
        position: relative;

        vertical-align: middle;

        fill: var(--iron-icon-fill-color, currentcolor);
        stroke: var(--iron-icon-stroke-color, none);

        width: var(--iron-icon-width, 24px);
        height: var(--iron-icon-height, 24px);
        @apply(--iron-icon);
      }
    </style>
  </template>

  <script>

    Polymer({

      is: 'iron-icon',

      properties: {

        /**
         * The name of the icon to use. The name should be of the form:
         * `iconset_name:icon_name`.
         */
        icon: {
          type: String
        },

        /**
         * The name of the theme to used, if one is specified by the
         * iconset.
         */
        theme: {
          type: String
        },

        /**
         * If using iron-icon without an iconset, you can set the src to be
         * the URL of an individual icon image file. Note that this will take
         * precedence over a given icon attribute.
         */
        src: {
          type: String
        },

        /**
         * @type {!Polymer.IronMeta}
         */
        _meta: {
          value: Polymer.Base.create('iron-meta', {type: 'iconset'})
        }

      },

      observers: [
        '_updateIcon(_meta, isAttached)',
        '_updateIcon(theme, isAttached)',
        '_srcChanged(src, isAttached)',
        '_iconChanged(icon, isAttached)'
      ],

      _DEFAULT_ICONSET: 'icons',

      _iconChanged: function(icon) {
        var parts = (icon || '').split(':');
        this._iconName = parts.pop();
        this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
        this._updateIcon();
      },

      _srcChanged: function(src) {
        this._updateIcon();
      },

      _usesIconset: function() {
        return this.icon || !this.src;
      },

      /** @suppress {visibility} */
      _updateIcon: function() {
        if (this._usesIconset()) {
          if (this._img && this._img.parentNode) {
            Polymer.dom(this.root).removeChild(this._img);
          }
          if (this._iconName === "") {
            if (this._iconset) {
              this._iconset.removeIcon(this);
            }
          } else if (this._iconsetName && this._meta) {
            this._iconset = /** @type {?Polymer.Iconset} */ (
              this._meta.byKey(this._iconsetName));
            if (this._iconset) {
              this._iconset.applyIcon(this, this._iconName, this.theme);
              this.unlisten(window, 'iron-iconset-added', '_updateIcon');
            } else {
              this.listen(window, 'iron-iconset-added', '_updateIcon');
            }
          }
        } else {
          if (this._iconset) {
            this._iconset.removeIcon(this);
          }
          if (!this._img) {
            this._img = document.createElement('img');
            this._img.style.width = '100%';
            this._img.style.height = '100%';
            this._img.draggable = false;
          }
          this._img.src = this.src;
          Polymer.dom(this.root).appendChild(this._img);
        }
      }

    });

  </script>

</dom-module>
<script>
  (function() {
    'use strict';

    /**
     * Chrome uses an older version of DOM Level 3 Keyboard Events
     *
     * Most keys are labeled as text, but some are Unicode codepoints.
     * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
     */
    var KEY_IDENTIFIER = {
      'U+0008': 'backspace',
      'U+0009': 'tab',
      'U+001B': 'esc',
      'U+0020': 'space',
      'U+007F': 'del'
    };

    /**
     * Special table for KeyboardEvent.keyCode.
     * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
     * than that.
     *
     * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
     */
    var KEY_CODE = {
      8: 'backspace',
      9: 'tab',
      13: 'enter',
      27: 'esc',
      33: 'pageup',
      34: 'pagedown',
      35: 'end',
      36: 'home',
      32: 'space',
      37: 'left',
      38: 'up',
      39: 'right',
      40: 'down',
      46: 'del',
      106: '*'
    };

    /**
     * MODIFIER_KEYS maps the short name for modifier keys used in a key
     * combo string to the property name that references those same keys
     * in a KeyboardEvent instance.
     */
    var MODIFIER_KEYS = {
      'shift': 'shiftKey',
      'ctrl': 'ctrlKey',
      'alt': 'altKey',
      'meta': 'metaKey'
    };

    /**
     * KeyboardEvent.key is mostly represented by printable character made by
     * the keyboard, with unprintable keys labeled nicely.
     *
     * However, on OS X, Alt+char can make a Unicode character that follows an
     * Apple-specific mapping. In this case, we fall back to .keyCode.
     */
    var KEY_CHAR = /[a-z0-9*]/;

    /**
     * Matches a keyIdentifier string.
     */
    var IDENT_CHAR = /U\+/;

    /**
     * Matches arrow keys in Gecko 27.0+
     */
    var ARROW_KEY = /^arrow/;

    /**
     * Matches space keys everywhere (notably including IE10's exceptional name
     * `spacebar`).
     */
    var SPACE_KEY = /^space(bar)?/;

    /**
     * Matches ESC key.
     *
     * Value from: http://w3c.github.io/uievents-key/#key-Escape
     */
    var ESC_KEY = /^escape$/;

    /**
     * Transforms the key.
     * @param {string} key The KeyBoardEvent.key
     * @param {Boolean} [noSpecialChars] Limits the transformation to
     * alpha-numeric characters.
     */
    function transformKey(key, noSpecialChars) {
      var validKey = '';
      if (key) {
        var lKey = key.toLowerCase();
        if (lKey === ' ' || SPACE_KEY.test(lKey)) {
          validKey = 'space';
        } else if (ESC_KEY.test(lKey)) {
          validKey = 'esc';
        } else if (lKey.length == 1) {
          if (!noSpecialChars || KEY_CHAR.test(lKey)) {
            validKey = lKey;
          }
        } else if (ARROW_KEY.test(lKey)) {
          validKey = lKey.replace('arrow', '');
        } else if (lKey == 'multiply') {
          // numpad '*' can map to Multiply on IE/Windows
          validKey = '*';
        } else {
          validKey = lKey;
        }
      }
      return validKey;
    }

    function transformKeyIdentifier(keyIdent) {
      var validKey = '';
      if (keyIdent) {
        if (keyIdent in KEY_IDENTIFIER) {
          validKey = KEY_IDENTIFIER[keyIdent];
        } else if (IDENT_CHAR.test(keyIdent)) {
          keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
          validKey = String.fromCharCode(keyIdent).toLowerCase();
        } else {
          validKey = keyIdent.toLowerCase();
        }
      }
      return validKey;
    }

    function transformKeyCode(keyCode) {
      var validKey = '';
      if (Number(keyCode)) {
        if (keyCode >= 65 && keyCode <= 90) {
          // ascii a-z
          // lowercase is 32 offset from uppercase
          validKey = String.fromCharCode(32 + keyCode);
        } else if (keyCode >= 112 && keyCode <= 123) {
          // function keys f1-f12
          validKey = 'f' + (keyCode - 112);
        } else if (keyCode >= 48 && keyCode <= 57) {
          // top 0-9 keys
          validKey = String(keyCode - 48);
        } else if (keyCode >= 96 && keyCode <= 105) {
          // num pad 0-9
          validKey = String(keyCode - 96);
        } else {
          validKey = KEY_CODE[keyCode];
        }
      }
      return validKey;
    }

    /**
      * Calculates the normalized key for a KeyboardEvent.
      * @param {KeyboardEvent} keyEvent
      * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
      * transformation to alpha-numeric chars. This is useful with key
      * combinations like shift + 2, which on FF for MacOS produces
      * keyEvent.key = @
      * To get 2 returned, set noSpecialChars = true
      * To get @ returned, set noSpecialChars = false
     */
    function normalizedKeyForEvent(keyEvent, noSpecialChars) {
      // Fall back from .key, to .detail.key for artifical keyboard events,
      // and then to deprecated .keyIdentifier and .keyCode.
      if (keyEvent.key) {
        return transformKey(keyEvent.key, noSpecialChars);
      }
      if (keyEvent.detail && keyEvent.detail.key) {
        return transformKey(keyEvent.detail.key, noSpecialChars);
      }
      return transformKeyIdentifier(keyEvent.keyIdentifier) ||
        transformKeyCode(keyEvent.keyCode) || '';
    }

    function keyComboMatchesEvent(keyCombo, event) {
      // For combos with modifiers we support only alpha-numeric keys
      var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
      return keyEvent === keyCombo.key &&
        (!keyCombo.hasModifiers || (
          !!event.shiftKey === !!keyCombo.shiftKey &&
          !!event.ctrlKey === !!keyCombo.ctrlKey &&
          !!event.altKey === !!keyCombo.altKey &&
          !!event.metaKey === !!keyCombo.metaKey)
        );
    }

    function parseKeyComboString(keyComboString) {
      if (keyComboString.length === 1) {
        return {
          combo: keyComboString,
          key: keyComboString,
          event: 'keydown'
        };
      }
      return keyComboString.split('+').reduce(function(parsedKeyCombo, keyComboPart) {
        var eventParts = keyComboPart.split(':');
        var keyName = eventParts[0];
        var event = eventParts[1];

        if (keyName in MODIFIER_KEYS) {
          parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
          parsedKeyCombo.hasModifiers = true;
        } else {
          parsedKeyCombo.key = keyName;
          parsedKeyCombo.event = event || 'keydown';
        }

        return parsedKeyCombo;
      }, {
        combo: keyComboString.split(':').shift()
      });
    }

    function parseEventString(eventString) {
      return eventString.trim().split(' ').map(function(keyComboString) {
        return parseKeyComboString(keyComboString);
      });
    }

    /**
     * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing
     * keyboard commands that pertain to [WAI-ARIA best practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding).
     * The element takes care of browser differences with respect to Keyboard events
     * and uses an expressive syntax to filter key presses.
     *
     * Use the `keyBindings` prototype property to express what combination of keys
     * will trigger the callback. A key binding has the format
     * `"KEY+MODIFIER:EVENT": "callback"` (`"KEY": "callback"` or
     * `"KEY:EVENT": "callback"` are valid as well). Some examples:
     *
     *      keyBindings: {
     *        'space': '_onKeydown', // same as 'space:keydown'
     *        'shift+tab': '_onKeydown',
     *        'enter:keypress': '_onKeypress',
     *        'esc:keyup': '_onKeyup'
     *      }
     *
     * The callback will receive with an event containing the following information in `event.detail`:
     *
     *      _onKeydown: function(event) {
     *        console.log(event.detail.combo); // KEY+MODIFIER, e.g. "shift+tab"
     *        console.log(event.detail.key); // KEY only, e.g. "tab"
     *        console.log(event.detail.event); // EVENT, e.g. "keydown"
     *        console.log(event.detail.keyboardEvent); // the original KeyboardEvent
     *      }
     *
     * Use the `keyEventTarget` attribute to set up event handlers on a specific
     * node.
     *
     * See the [demo source code](https://github.com/PolymerElements/iron-a11y-keys-behavior/blob/master/demo/x-key-aware.html)
     * for an example.
     *
     * @demo demo/index.html
     * @polymerBehavior
     */
    Polymer.IronA11yKeysBehavior = {
      properties: {
        /**
         * The EventTarget that will be firing relevant KeyboardEvents. Set it to
         * `null` to disable the listeners.
         * @type {?EventTarget}
         */
        keyEventTarget: {
          type: Object,
          value: function() {
            return this;
          }
        },

        /**
         * If true, this property will cause the implementing element to
         * automatically stop propagation on any handled KeyboardEvents.
         */
        stopKeyboardEventPropagation: {
          type: Boolean,
          value: false
        },

        _boundKeyHandlers: {
          type: Array,
          value: function() {
            return [];
          }
        },

        // We use this due to a limitation in IE10 where instances will have
        // own properties of everything on the "prototype".
        _imperativeKeyBindings: {
          type: Object,
          value: function() {
            return {};
          }
        }
      },

      observers: [
        '_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'
      ],


      /**
       * To be used to express what combination of keys  will trigger the relative
       * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
       * @type {!Object}
       */
      keyBindings: {},

      registered: function() {
        this._prepKeyBindings();
      },

      attached: function() {
        this._listenKeyEventListeners();
      },

      detached: function() {
        this._unlistenKeyEventListeners();
      },

      /**
       * Can be used to imperatively add a key binding to the implementing
       * element. This is the imperative equivalent of declaring a keybinding
       * in the `keyBindings` prototype property.
       */
      addOwnKeyBinding: function(eventString, handlerName) {
        this._imperativeKeyBindings[eventString] = handlerName;
        this._prepKeyBindings();
        this._resetKeyEventListeners();
      },

      /**
       * When called, will remove all imperatively-added key bindings.
       */
      removeOwnKeyBindings: function() {
        this._imperativeKeyBindings = {};
        this._prepKeyBindings();
        this._resetKeyEventListeners();
      },

      /**
       * Returns true if a keyboard event matches `eventString`.
       *
       * @param {KeyboardEvent} event
       * @param {string} eventString
       * @return {boolean}
       */
      keyboardEventMatchesKeys: function(event, eventString) {
        var keyCombos = parseEventString(eventString);
        for (var i = 0; i < keyCombos.length; ++i) {
          if (keyComboMatchesEvent(keyCombos[i], event)) {
            return true;
          }
        }
        return false;
      },

      _collectKeyBindings: function() {
        var keyBindings = this.behaviors.map(function(behavior) {
          return behavior.keyBindings;
        });

        if (keyBindings.indexOf(this.keyBindings) === -1) {
          keyBindings.push(this.keyBindings);
        }

        return keyBindings;
      },

      _prepKeyBindings: function() {
        this._keyBindings = {};

        this._collectKeyBindings().forEach(function(keyBindings) {
          for (var eventString in keyBindings) {
            this._addKeyBinding(eventString, keyBindings[eventString]);
          }
        }, this);

        for (var eventString in this._imperativeKeyBindings) {
          this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
        }

        // Give precedence to combos with modifiers to be checked first.
        for (var eventName in this._keyBindings) {
          this._keyBindings[eventName].sort(function (kb1, kb2) {
            var b1 = kb1[0].hasModifiers;
            var b2 = kb2[0].hasModifiers;
            return (b1 === b2) ? 0 : b1 ? -1 : 1;
          })
        }
      },

      _addKeyBinding: function(eventString, handlerName) {
        parseEventString(eventString).forEach(function(keyCombo) {
          this._keyBindings[keyCombo.event] =
            this._keyBindings[keyCombo.event] || [];

          this._keyBindings[keyCombo.event].push([
            keyCombo,
            handlerName
          ]);
        }, this);
      },

      _resetKeyEventListeners: function() {
        this._unlistenKeyEventListeners();

        if (this.isAttached) {
          this._listenKeyEventListeners();
        }
      },

      _listenKeyEventListeners: function() {
        if (!this.keyEventTarget) {
          return;
        }
        Object.keys(this._keyBindings).forEach(function(eventName) {
          var keyBindings = this._keyBindings[eventName];
          var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

          this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

          this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
        }, this);
      },

      _unlistenKeyEventListeners: function() {
        var keyHandlerTuple;
        var keyEventTarget;
        var eventName;
        var boundKeyHandler;

        while (this._boundKeyHandlers.length) {
          // My kingdom for block-scope binding and destructuring assignment..
          keyHandlerTuple = this._boundKeyHandlers.pop();
          keyEventTarget = keyHandlerTuple[0];
          eventName = keyHandlerTuple[1];
          boundKeyHandler = keyHandlerTuple[2];

          keyEventTarget.removeEventListener(eventName, boundKeyHandler);
        }
      },

      _onKeyBindingEvent: function(keyBindings, event) {
        if (this.stopKeyboardEventPropagation) {
          event.stopPropagation();
        }

        // if event has been already prevented, don't do anything
        if (event.defaultPrevented) {
          return;
        }

        for (var i = 0; i < keyBindings.length; i++) {
          var keyCombo = keyBindings[i][0];
          var handlerName = keyBindings[i][1];
          if (keyComboMatchesEvent(keyCombo, event)) {
            this._triggerKeyHandler(keyCombo, handlerName, event);
            // exit the loop if eventDefault was prevented
            if (event.defaultPrevented) {
              return;
            }
          }
        }
      },

      _triggerKeyHandler: function(keyCombo, handlerName, keyboardEvent) {
        var detail = Object.create(keyCombo);
        detail.keyboardEvent = keyboardEvent;
        var event = new CustomEvent(keyCombo.event, {
          detail: detail,
          cancelable: true
        });
        this[handlerName].call(this, event);
        if (event.defaultPrevented) {
          keyboardEvent.preventDefault();
        }
      }
    };
  })();
</script>
<script>

  /**
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronControlState = {

    properties: {

      /**
       * If true, the element currently has focus.
       */
      focused: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },

      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        value: false,
        notify: true,
        observer: '_disabledChanged',
        reflectToAttribute: true
      },

      _oldTabIndex: {
        type: Number
      },

      _boundFocusBlurHandler: {
        type: Function,
        value: function() {
          return this._focusBlurHandler.bind(this);
        }
      }

    },

    observers: [
      '_changedControlState(focused, disabled)'
    ],

    ready: function() {
      this.addEventListener('focus', this._boundFocusBlurHandler, true);
      this.addEventListener('blur', this._boundFocusBlurHandler, true);
    },

    _focusBlurHandler: function(event) {
      // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
      // eventually become `this` due to retargeting; if we are not in
      // ShadowDOM land, `event.target` will eventually become `this` due
      // to the second conditional which fires a synthetic event (that is also
      // handled). In either case, we can disregard `event.path`.

      if (event.target === this) {
        this._setFocused(event.type === 'focus');
      } else if (!this.shadowRoot) {
        var target = /** @type {Node} */(Polymer.dom(event).localTarget);
        if (!this.isLightDescendant(target)) {
          this.fire(event.type, {sourceEvent: event}, {
            node: this,
            bubbles: event.bubbles,
            cancelable: event.cancelable
          });
        }
      }
    },

    _disabledChanged: function(disabled, old) {
      this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
      this.style.pointerEvents = disabled ? 'none' : '';
      if (disabled) {
        this._oldTabIndex = this.tabIndex;
        this._setFocused(false);
        this.tabIndex = -1;
        this.blur();
      } else if (this._oldTabIndex !== undefined) {
        this.tabIndex = this._oldTabIndex;
      }
    },

    _changedControlState: function() {
      // _controlStateChanged is abstract, follow-on behaviors may implement it
      if (this._controlStateChanged) {
        this._controlStateChanged();
      }
    }

  };

</script>
<script>

  /**
   * @demo demo/index.html
   * @polymerBehavior Polymer.IronButtonState
   */
  Polymer.IronButtonStateImpl = {

    properties: {

      /**
       * If true, the user is currently holding down the button.
       */
      pressed: {
        type: Boolean,
        readOnly: true,
        value: false,
        reflectToAttribute: true,
        observer: '_pressedChanged'
      },

      /**
       * If true, the button toggles the active state with each tap or press
       * of the spacebar.
       */
      toggles: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * If true, the button is a toggle and is currently in the active state.
       */
      active: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true
      },

      /**
       * True if the element is currently being pressed by a "pointer," which
       * is loosely defined as mouse or touch input (but specifically excluding
       * keyboard input).
       */
      pointerDown: {
        type: Boolean,
        readOnly: true,
        value: false
      },

      /**
       * True if the input device that caused the element to receive focus
       * was a keyboard.
       */
      receivedFocusFromKeyboard: {
        type: Boolean,
        readOnly: true
      },

      /**
       * The aria attribute to be set if the button is a toggle and in the
       * active state.
       */
      ariaActiveAttribute: {
        type: String,
        value: 'aria-pressed',
        observer: '_ariaActiveAttributeChanged'
      }
    },

    listeners: {
      down: '_downHandler',
      up: '_upHandler',
      tap: '_tapHandler'
    },

    observers: [
      '_focusChanged(focused)',
      '_activeChanged(active, ariaActiveAttribute)'
    ],

    keyBindings: {
      'enter:keydown': '_asyncClick',
      'space:keydown': '_spaceKeyDownHandler',
      'space:keyup': '_spaceKeyUpHandler',
    },

    _mouseEventRe: /^mouse/,

    _tapHandler: function() {
      if (this.toggles) {
       // a tap is needed to toggle the active state
        this._userActivate(!this.active);
      } else {
        this.active = false;
      }
    },

    _focusChanged: function(focused) {
      this._detectKeyboardFocus(focused);

      if (!focused) {
        this._setPressed(false);
      }
    },

    _detectKeyboardFocus: function(focused) {
      this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
    },

    // to emulate native checkbox, (de-)activations from a user interaction fire
    // 'change' events
    _userActivate: function(active) {
      if (this.active !== active) {
        this.active = active;
        this.fire('change');
      }
    },

    _downHandler: function(event) {
      this._setPointerDown(true);
      this._setPressed(true);
      this._setReceivedFocusFromKeyboard(false);
    },

    _upHandler: function() {
      this._setPointerDown(false);
      this._setPressed(false);
    },

    /**
     * @param {!KeyboardEvent} event .
     */
    _spaceKeyDownHandler: function(event) {
      var keyboardEvent = event.detail.keyboardEvent;
      var target = Polymer.dom(keyboardEvent).localTarget;

      // Ignore the event if this is coming from a focused light child, since that
      // element will deal with it.
      if (this.isLightDescendant(/** @type {Node} */(target)))
        return;

      keyboardEvent.preventDefault();
      keyboardEvent.stopImmediatePropagation();
      this._setPressed(true);
    },

    /**
     * @param {!KeyboardEvent} event .
     */
    _spaceKeyUpHandler: function(event) {
      var keyboardEvent = event.detail.keyboardEvent;
      var target = Polymer.dom(keyboardEvent).localTarget;

      // Ignore the event if this is coming from a focused light child, since that
      // element will deal with it.
      if (this.isLightDescendant(/** @type {Node} */(target)))
        return;

      if (this.pressed) {
        this._asyncClick();
      }
      this._setPressed(false);
    },

    // trigger click asynchronously, the asynchrony is useful to allow one
    // event handler to unwind before triggering another event
    _asyncClick: function() {
      this.async(function() {
        this.click();
      }, 1);
    },

    // any of these changes are considered a change to button state

    _pressedChanged: function(pressed) {
      this._changedButtonState();
    },

    _ariaActiveAttributeChanged: function(value, oldValue) {
      if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
        this.removeAttribute(oldValue);
      }
    },

    _activeChanged: function(active, ariaActiveAttribute) {
      if (this.toggles) {
        this.setAttribute(this.ariaActiveAttribute,
                          active ? 'true' : 'false');
      } else {
        this.removeAttribute(this.ariaActiveAttribute);
      }
      this._changedButtonState();
    },

    _controlStateChanged: function() {
      if (this.disabled) {
        this._setPressed(false);
      } else {
        this._changedButtonState();
      }
    },

    // provide hook for follow-on behaviors to react to button-state

    _changedButtonState: function() {
      if (this._buttonStateChanged) {
        this._buttonStateChanged(); // abstract
      }
    }

  };

  /** @polymerBehavior */
  Polymer.IronButtonState = [
    Polymer.IronA11yKeysBehavior,
    Polymer.IronButtonStateImpl
  ];

</script>
<dom-module id="paper-ripple" assetpath="bower_components/paper-ripple/">

  <template>
    <style>
      :host {
        display: block;
        position: absolute;
        border-radius: inherit;
        overflow: hidden;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;

        /* See PolymerElements/paper-behaviors/issues/34. On non-Chrome browsers,
         * creating a node (with a position:absolute) in the middle of an event
         * handler "interrupts" that event handler (which happens when the
         * ripple is created on demand) */
        pointer-events: none;
      }

      :host([animating]) {
        /* This resolves a rendering issue in Chrome (as of 40) where the
           ripple is not properly clipped by its parent (which may have
           rounded corners). See: http://jsbin.com/temexa/4

           Note: We only apply this style conditionally. Otherwise, the browser
           will create a new compositing layer for every ripple element on the
           page, and that would be bad. */
        -webkit-transform: translate(0, 0);
        transform: translate3d(0, 0, 0);
      }

      #background,
      #waves,
      .wave-container,
      .wave {
        pointer-events: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      #background,
      .wave {
        opacity: 0;
      }

      #waves,
      .wave {
        overflow: hidden;
      }

      .wave-container,
      .wave {
        border-radius: 50%;
      }

      :host(.circle) #background,
      :host(.circle) #waves {
        border-radius: 50%;
      }

      :host(.circle) .wave-container {
        overflow: hidden;
      }
    </style>

    <div id="background"></div>
    <div id="waves"></div>
  </template>
</dom-module>
<script>
  (function() {
    var Utility = {
      distance: function(x1, y1, x2, y2) {
        var xDelta = (x1 - x2);
        var yDelta = (y1 - y2);

        return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
      },

      now: window.performance && window.performance.now ?
          window.performance.now.bind(window.performance) : Date.now
    };

    /**
     * @param {HTMLElement} element
     * @constructor
     */
    function ElementMetrics(element) {
      this.element = element;
      this.width = this.boundingRect.width;
      this.height = this.boundingRect.height;

      this.size = Math.max(this.width, this.height);
    }

    ElementMetrics.prototype = {
      get boundingRect () {
        return this.element.getBoundingClientRect();
      },

      furthestCornerDistanceFrom: function(x, y) {
        var topLeft = Utility.distance(x, y, 0, 0);
        var topRight = Utility.distance(x, y, this.width, 0);
        var bottomLeft = Utility.distance(x, y, 0, this.height);
        var bottomRight = Utility.distance(x, y, this.width, this.height);

        return Math.max(topLeft, topRight, bottomLeft, bottomRight);
      }
    };

    /**
     * @param {HTMLElement} element
     * @constructor
     */
    function Ripple(element) {
      this.element = element;
      this.color = window.getComputedStyle(element).color;

      this.wave = document.createElement('div');
      this.waveContainer = document.createElement('div');
      this.wave.style.backgroundColor = this.color;
      this.wave.classList.add('wave');
      this.waveContainer.classList.add('wave-container');
      Polymer.dom(this.waveContainer).appendChild(this.wave);

      this.resetInteractionState();
    }

    Ripple.MAX_RADIUS = 300;

    Ripple.prototype = {
      get recenters() {
        return this.element.recenters;
      },

      get center() {
        return this.element.center;
      },

      get mouseDownElapsed() {
        var elapsed;

        if (!this.mouseDownStart) {
          return 0;
        }

        elapsed = Utility.now() - this.mouseDownStart;

        if (this.mouseUpStart) {
          elapsed -= this.mouseUpElapsed;
        }

        return elapsed;
      },

      get mouseUpElapsed() {
        return this.mouseUpStart ?
          Utility.now () - this.mouseUpStart : 0;
      },

      get mouseDownElapsedSeconds() {
        return this.mouseDownElapsed / 1000;
      },

      get mouseUpElapsedSeconds() {
        return this.mouseUpElapsed / 1000;
      },

      get mouseInteractionSeconds() {
        return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
      },

      get initialOpacity() {
        return this.element.initialOpacity;
      },

      get opacityDecayVelocity() {
        return this.element.opacityDecayVelocity;
      },

      get radius() {
        var width2 = this.containerMetrics.width * this.containerMetrics.width;
        var height2 = this.containerMetrics.height * this.containerMetrics.height;
        var waveRadius = Math.min(
          Math.sqrt(width2 + height2),
          Ripple.MAX_RADIUS
        ) * 1.1 + 5;

        var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
        var timeNow = this.mouseInteractionSeconds / duration;
        var size = waveRadius * (1 - Math.pow(80, -timeNow));

        return Math.abs(size);
      },

      get opacity() {
        if (!this.mouseUpStart) {
          return this.initialOpacity;
        }

        return Math.max(
          0,
          this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity
        );
      },

      get outerOpacity() {
        // Linear increase in background opacity, capped at the opacity
        // of the wavefront (waveOpacity).
        var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
        var waveOpacity = this.opacity;

        return Math.max(
          0,
          Math.min(outerOpacity, waveOpacity)
        );
      },

      get isOpacityFullyDecayed() {
        return this.opacity < 0.01 &&
          this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
      },

      get isRestingAtMaxRadius() {
        return this.opacity >= this.initialOpacity &&
          this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
      },

      get isAnimationComplete() {
        return this.mouseUpStart ?
          this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
      },

      get translationFraction() {
        return Math.min(
          1,
          this.radius / this.containerMetrics.size * 2 / Math.sqrt(2)
        );
      },

      get xNow() {
        if (this.xEnd) {
          return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
        }

        return this.xStart;
      },

      get yNow() {
        if (this.yEnd) {
          return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
        }

        return this.yStart;
      },

      get isMouseDown() {
        return this.mouseDownStart && !this.mouseUpStart;
      },

      resetInteractionState: function() {
        this.maxRadius = 0;
        this.mouseDownStart = 0;
        this.mouseUpStart = 0;

        this.xStart = 0;
        this.yStart = 0;
        this.xEnd = 0;
        this.yEnd = 0;
        this.slideDistance = 0;

        this.containerMetrics = new ElementMetrics(this.element);
      },

      draw: function() {
        var scale;
        var translateString;
        var dx;
        var dy;

        this.wave.style.opacity = this.opacity;

        scale = this.radius / (this.containerMetrics.size / 2);
        dx = this.xNow - (this.containerMetrics.width / 2);
        dy = this.yNow - (this.containerMetrics.height / 2);


        // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
        // https://bugs.webkit.org/show_bug.cgi?id=98538
        this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
        this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
        this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
        this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
      },

      /** @param {Event=} event */
      downAction: function(event) {
        var xCenter = this.containerMetrics.width / 2;
        var yCenter = this.containerMetrics.height / 2;

        this.resetInteractionState();
        this.mouseDownStart = Utility.now();

        if (this.center) {
          this.xStart = xCenter;
          this.yStart = yCenter;
          this.slideDistance = Utility.distance(
            this.xStart, this.yStart, this.xEnd, this.yEnd
          );
        } else {
          this.xStart = event ?
              event.detail.x - this.containerMetrics.boundingRect.left :
              this.containerMetrics.width / 2;
          this.yStart = event ?
              event.detail.y - this.containerMetrics.boundingRect.top :
              this.containerMetrics.height / 2;
        }

        if (this.recenters) {
          this.xEnd = xCenter;
          this.yEnd = yCenter;
          this.slideDistance = Utility.distance(
            this.xStart, this.yStart, this.xEnd, this.yEnd
          );
        }

        this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(
          this.xStart,
          this.yStart
        );

        this.waveContainer.style.top =
          (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
        this.waveContainer.style.left =
          (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

        this.waveContainer.style.width = this.containerMetrics.size + 'px';
        this.waveContainer.style.height = this.containerMetrics.size + 'px';
      },

      /** @param {Event=} event */
      upAction: function(event) {
        if (!this.isMouseDown) {
          return;
        }

        this.mouseUpStart = Utility.now();
      },

      remove: function() {
        Polymer.dom(this.waveContainer.parentNode).removeChild(
          this.waveContainer
        );
      }
    };

    Polymer({
      is: 'paper-ripple',

      behaviors: [
        Polymer.IronA11yKeysBehavior
      ],

      properties: {
        /**
         * The initial opacity set on the wave.
         *
         * @attribute initialOpacity
         * @type number
         * @default 0.25
         */
        initialOpacity: {
          type: Number,
          value: 0.25
        },

        /**
         * How fast (opacity per second) the wave fades out.
         *
         * @attribute opacityDecayVelocity
         * @type number
         * @default 0.8
         */
        opacityDecayVelocity: {
          type: Number,
          value: 0.8
        },

        /**
         * If true, ripples will exhibit a gravitational pull towards
         * the center of their container as they fade away.
         *
         * @attribute recenters
         * @type boolean
         * @default false
         */
        recenters: {
          type: Boolean,
          value: false
        },

        /**
         * If true, ripples will center inside its container
         *
         * @attribute recenters
         * @type boolean
         * @default false
         */
        center: {
          type: Boolean,
          value: false
        },

        /**
         * A list of the visual ripples.
         *
         * @attribute ripples
         * @type Array
         * @default []
         */
        ripples: {
          type: Array,
          value: function() {
            return [];
          }
        },

        /**
         * True when there are visible ripples animating within the
         * element.
         */
        animating: {
          type: Boolean,
          readOnly: true,
          reflectToAttribute: true,
          value: false
        },

        /**
         * If true, the ripple will remain in the "down" state until `holdDown`
         * is set to false again.
         */
        holdDown: {
          type: Boolean,
          value: false,
          observer: '_holdDownChanged'
        },

        /**
         * If true, the ripple will not generate a ripple effect
         * via pointer interaction.
         * Calling ripple's imperative api like `simulatedRipple` will
         * still generate the ripple effect.
         */
        noink: {
          type: Boolean,
          value: false
        },

        _animating: {
          type: Boolean
        },

        _boundAnimate: {
          type: Function,
          value: function() {
            return this.animate.bind(this);
          }
        }
      },

      get target () {
        return this.keyEventTarget;
      },

      keyBindings: {
        'enter:keydown': '_onEnterKeydown',
        'space:keydown': '_onSpaceKeydown',
        'space:keyup': '_onSpaceKeyup'
      },

      attached: function() {
        // Set up a11yKeysBehavior to listen to key events on the target,
        // so that space and enter activate the ripple even if the target doesn't
        // handle key events. The key handlers deal with `noink` themselves.
        if (this.parentNode.nodeType == 11) { // DOCUMENT_FRAGMENT_NODE
          this.keyEventTarget = Polymer.dom(this).getOwnerRoot().host;
        } else {
          this.keyEventTarget = this.parentNode;
        }
        var keyEventTarget = /** @type {!EventTarget} */ (this.keyEventTarget);
        this.listen(keyEventTarget, 'up', 'uiUpAction');
        this.listen(keyEventTarget, 'down', 'uiDownAction');
      },

      detached: function() {
        this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
        this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
        this.keyEventTarget = null;
      },

      get shouldKeepAnimating () {
        for (var index = 0; index < this.ripples.length; ++index) {
          if (!this.ripples[index].isAnimationComplete) {
            return true;
          }
        }

        return false;
      },

      simulatedRipple: function() {
        this.downAction(null);

        // Please see polymer/polymer#1305
        this.async(function() {
          this.upAction();
        }, 1);
      },

      /**
       * Provokes a ripple down effect via a UI event,
       * respecting the `noink` property.
       * @param {Event=} event
       */
      uiDownAction: function(event) {
        if (!this.noink) {
          this.downAction(event);
        }
      },

      /**
       * Provokes a ripple down effect via a UI event,
       * *not* respecting the `noink` property.
       * @param {Event=} event
       */
      downAction: function(event) {
        if (this.holdDown && this.ripples.length > 0) {
          return;
        }

        var ripple = this.addRipple();

        ripple.downAction(event);

        if (!this._animating) {
          this._animating = true;
          this.animate();
        }
      },

      /**
       * Provokes a ripple up effect via a UI event,
       * respecting the `noink` property.
       * @param {Event=} event
       */
      uiUpAction: function(event) {
        if (!this.noink) {
          this.upAction(event);
        }
      },

      /**
       * Provokes a ripple up effect via a UI event,
       * *not* respecting the `noink` property.
       * @param {Event=} event
       */
      upAction: function(event) {
        if (this.holdDown) {
          return;
        }

        this.ripples.forEach(function(ripple) {
          ripple.upAction(event);
        });

        this._animating = true;
        this.animate();
      },

      onAnimationComplete: function() {
        this._animating = false;
        this.$.background.style.backgroundColor = null;
        this.fire('transitionend');
      },

      addRipple: function() {
        var ripple = new Ripple(this);

        Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
        this.$.background.style.backgroundColor = ripple.color;
        this.ripples.push(ripple);

        this._setAnimating(true);

        return ripple;
      },

      removeRipple: function(ripple) {
        var rippleIndex = this.ripples.indexOf(ripple);

        if (rippleIndex < 0) {
          return;
        }

        this.ripples.splice(rippleIndex, 1);

        ripple.remove();

        if (!this.ripples.length) {
          this._setAnimating(false);
        }
      },

      /**
       * This conflicts with Element#antimate().
       * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
       * @suppress {checkTypes}
       */
      animate: function() {
        if (!this._animating) {
          return;
        }
        var index;
        var ripple;

        for (index = 0; index < this.ripples.length; ++index) {
          ripple = this.ripples[index];

          ripple.draw();

          this.$.background.style.opacity = ripple.outerOpacity;

          if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
            this.removeRipple(ripple);
          }
        }

        if (!this.shouldKeepAnimating && this.ripples.length === 0) {
          this.onAnimationComplete();
        } else {
          window.requestAnimationFrame(this._boundAnimate);
        }
      },

      _onEnterKeydown: function() {
        this.uiDownAction();
        this.async(this.uiUpAction, 1);
      },

      _onSpaceKeydown: function() {
        this.uiDownAction();
      },

      _onSpaceKeyup: function() {
        this.uiUpAction();
      },

      // note: holdDown does not respect noink since it can be a focus based
      // effect.
      _holdDownChanged: function(newVal, oldVal) {
        if (oldVal === undefined) {
          return;
        }
        if (newVal) {
          this.downAction();
        } else {
          this.upAction();
        }
      }

      /**
      Fired when the animation finishes.
      This is useful if you want to wait until
      the ripple animation finishes to perform some action.

      @event transitionend
      @param {{node: Object}} detail Contains the animated node.
      */
    });
  })();
</script>
<script>
  /**
   * `Polymer.PaperRippleBehavior` dynamically implements a ripple
   * when the element has focus via pointer or keyboard.
   *
   * NOTE: This behavior is intended to be used in conjunction with and after
   * `Polymer.IronButtonState` and `Polymer.IronControlState`.
   *
   * @polymerBehavior Polymer.PaperRippleBehavior
   */
  Polymer.PaperRippleBehavior = {
    properties: {
      /**
       * If true, the element will not produce a ripple effect when interacted
       * with via the pointer.
       */
      noink: {
        type: Boolean,
        observer: '_noinkChanged'
      },

      /**
       * @type {Element|undefined}
       */
      _rippleContainer: {
        type: Object,
      }
    },

    /**
     * Ensures a `<paper-ripple>` element is available when the element is
     * focused.
     */
    _buttonStateChanged: function() {
      if (this.focused) {
        this.ensureRipple();
      }
    },

    /**
     * In addition to the functionality provided in `IronButtonState`, ensures
     * a ripple effect is created when the element is in a `pressed` state.
     */
    _downHandler: function(event) {
      Polymer.IronButtonStateImpl._downHandler.call(this, event);
      if (this.pressed) {
        this.ensureRipple(event);
      }
    },

    /**
     * Ensures this element contains a ripple effect. For startup efficiency
     * the ripple effect is dynamically on demand when needed.
     * @param {!Event=} optTriggeringEvent (optional) event that triggered the
     * ripple.
     */
    ensureRipple: function(optTriggeringEvent) {
      if (!this.hasRipple()) {
        this._ripple = this._createRipple();
        this._ripple.noink = this.noink;
        var rippleContainer = this._rippleContainer || this.root;
        if (rippleContainer) {
          Polymer.dom(rippleContainer).appendChild(this._ripple);
        }
        if (optTriggeringEvent) {
          // Check if the event happened inside of the ripple container
          // Fall back to host instead of the root because distributed text
          // nodes are not valid event targets
          var domContainer = Polymer.dom(this._rippleContainer || this);
          var target = Polymer.dom(optTriggeringEvent).rootTarget;
          if (domContainer.deepContains( /** @type {Node} */(target))) {
            this._ripple.uiDownAction(optTriggeringEvent);
          }
        }
      }
    },

    /**
     * Returns the `<paper-ripple>` element used by this element to create
     * ripple effects. The element's ripple is created on demand, when
     * necessary, and calling this method will force the
     * ripple to be created.
     */
    getRipple: function() {
      this.ensureRipple();
      return this._ripple;
    },

    /**
     * Returns true if this element currently contains a ripple effect.
     * @return {boolean}
     */
    hasRipple: function() {
      return Boolean(this._ripple);
    },

    /**
     * Create the element's ripple effect via creating a `<paper-ripple>`.
     * Override this method to customize the ripple element.
     * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
     */
    _createRipple: function() {
      return /** @type {!PaperRippleElement} */ (
          document.createElement('paper-ripple'));
    },

    _noinkChanged: function(noink) {
      if (this.hasRipple()) {
        this._ripple.noink = noink;
      }
    }
  };
</script>
<script>
  /**
   * `Polymer.PaperInkyFocusBehavior` implements a ripple when the element has keyboard focus.
   *
   * @polymerBehavior Polymer.PaperInkyFocusBehavior
   */
  Polymer.PaperInkyFocusBehaviorImpl = {
    observers: [
      '_focusedChanged(receivedFocusFromKeyboard)'
    ],

    _focusedChanged: function(receivedFocusFromKeyboard) {
      if (receivedFocusFromKeyboard) {
        this.ensureRipple();
      }
      if (this.hasRipple()) {
        this._ripple.holdDown = receivedFocusFromKeyboard;
      }
    },

    _createRipple: function() {
      var ripple = Polymer.PaperRippleBehavior._createRipple();
      ripple.id = 'ink';
      ripple.setAttribute('center', '');
      ripple.classList.add('circle');
      return ripple;
    }
  };

  /** @polymerBehavior Polymer.PaperInkyFocusBehavior */
  Polymer.PaperInkyFocusBehavior = [
    Polymer.IronButtonState,
    Polymer.IronControlState,
    Polymer.PaperRippleBehavior,
    Polymer.PaperInkyFocusBehaviorImpl
  ];
</script>
<style is="custom-style">

  :root {

    /* Material Design color palette for Google products */

    --google-red-100: #f4c7c3;
    --google-red-300: #e67c73;
    --google-red-500: #db4437;
    --google-red-700: #c53929;

    --google-blue-100: #c6dafc;
    --google-blue-300: #7baaf7;
    --google-blue-500: #4285f4;
    --google-blue-700: #3367d6;

    --google-green-100: #b7e1cd;
    --google-green-300: #57bb8a;
    --google-green-500: #0f9d58;
    --google-green-700: #0b8043;

    --google-yellow-100: #fce8b2;
    --google-yellow-300: #f7cb4d;
    --google-yellow-500: #f4b400;
    --google-yellow-700: #f09300;

    --google-grey-100: #f5f5f5;
    --google-grey-300: #e0e0e0;
    --google-grey-500: #9e9e9e;
    --google-grey-700: #616161;
    
    /* Material Design color palette from online spec document */

    --paper-red-50: #ffebee;
    --paper-red-100: #ffcdd2;
    --paper-red-200: #ef9a9a;
    --paper-red-300: #e57373;
    --paper-red-400: #ef5350;
    --paper-red-500: #f44336;
    --paper-red-600: #e53935;
    --paper-red-700: #d32f2f;
    --paper-red-800: #c62828;
    --paper-red-900: #b71c1c;
    --paper-red-a100: #ff8a80;
    --paper-red-a200: #ff5252;
    --paper-red-a400: #ff1744;
    --paper-red-a700: #d50000;
 
    --paper-pink-50: #fce4ec;
    --paper-pink-100: #f8bbd0;
    --paper-pink-200: #f48fb1;
    --paper-pink-300: #f06292;
    --paper-pink-400: #ec407a;
    --paper-pink-500: #e91e63;
    --paper-pink-600: #d81b60;
    --paper-pink-700: #c2185b;
    --paper-pink-800: #ad1457;
    --paper-pink-900: #880e4f;
    --paper-pink-a100: #ff80ab;
    --paper-pink-a200: #ff4081;
    --paper-pink-a400: #f50057;
    --paper-pink-a700: #c51162;
 
    --paper-purple-50: #f3e5f5;
    --paper-purple-100: #e1bee7;
    --paper-purple-200: #ce93d8;
    --paper-purple-300: #ba68c8;
    --paper-purple-400: #ab47bc;
    --paper-purple-500: #9c27b0;
    --paper-purple-600: #8e24aa;
    --paper-purple-700: #7b1fa2;
    --paper-purple-800: #6a1b9a;
    --paper-purple-900: #4a148c;
    --paper-purple-a100: #ea80fc;
    --paper-purple-a200: #e040fb;
    --paper-purple-a400: #d500f9;
    --paper-purple-a700: #aa00ff;
 
    --paper-deep-purple-50: #ede7f6;
    --paper-deep-purple-100: #d1c4e9;
    --paper-deep-purple-200: #b39ddb;
    --paper-deep-purple-300: #9575cd;
    --paper-deep-purple-400: #7e57c2;
    --paper-deep-purple-500: #673ab7;
    --paper-deep-purple-600: #5e35b1;
    --paper-deep-purple-700: #512da8;
    --paper-deep-purple-800: #4527a0;
    --paper-deep-purple-900: #311b92;
    --paper-deep-purple-a100: #b388ff;
    --paper-deep-purple-a200: #7c4dff;
    --paper-deep-purple-a400: #651fff;
    --paper-deep-purple-a700: #6200ea;
 
    --paper-indigo-50: #e8eaf6;
    --paper-indigo-100: #c5cae9;
    --paper-indigo-200: #9fa8da;
    --paper-indigo-300: #7986cb;
    --paper-indigo-400: #5c6bc0;
    --paper-indigo-500: #3f51b5;
    --paper-indigo-600: #3949ab;
    --paper-indigo-700: #303f9f;
    --paper-indigo-800: #283593;
    --paper-indigo-900: #1a237e;
    --paper-indigo-a100: #8c9eff;
    --paper-indigo-a200: #536dfe;
    --paper-indigo-a400: #3d5afe;
    --paper-indigo-a700: #304ffe;
 
    --paper-blue-50: #e3f2fd;
    --paper-blue-100: #bbdefb;
    --paper-blue-200: #90caf9;
    --paper-blue-300: #64b5f6;
    --paper-blue-400: #42a5f5;
    --paper-blue-500: #2196f3;
    --paper-blue-600: #1e88e5;
    --paper-blue-700: #1976d2;
    --paper-blue-800: #1565c0;
    --paper-blue-900: #0d47a1;
    --paper-blue-a100: #82b1ff;
    --paper-blue-a200: #448aff;
    --paper-blue-a400: #2979ff;
    --paper-blue-a700: #2962ff;
 
    --paper-light-blue-50: #e1f5fe;
    --paper-light-blue-100: #b3e5fc;
    --paper-light-blue-200: #81d4fa;
    --paper-light-blue-300: #4fc3f7;
    --paper-light-blue-400: #29b6f6;
    --paper-light-blue-500: #03a9f4;
    --paper-light-blue-600: #039be5;
    --paper-light-blue-700: #0288d1;
    --paper-light-blue-800: #0277bd;
    --paper-light-blue-900: #01579b;
    --paper-light-blue-a100: #80d8ff;
    --paper-light-blue-a200: #40c4ff;
    --paper-light-blue-a400: #00b0ff;
    --paper-light-blue-a700: #0091ea;
 
    --paper-cyan-50: #e0f7fa;
    --paper-cyan-100: #b2ebf2;
    --paper-cyan-200: #80deea;
    --paper-cyan-300: #4dd0e1;
    --paper-cyan-400: #26c6da;
    --paper-cyan-500: #00bcd4;
    --paper-cyan-600: #00acc1;
    --paper-cyan-700: #0097a7;
    --paper-cyan-800: #00838f;
    --paper-cyan-900: #006064;
    --paper-cyan-a100: #84ffff;
    --paper-cyan-a200: #18ffff;
    --paper-cyan-a400: #00e5ff;
    --paper-cyan-a700: #00b8d4;
 
    --paper-teal-50: #e0f2f1;
    --paper-teal-100: #b2dfdb;
    --paper-teal-200: #80cbc4;
    --paper-teal-300: #4db6ac;
    --paper-teal-400: #26a69a;
    --paper-teal-500: #009688;
    --paper-teal-600: #00897b;
    --paper-teal-700: #00796b;
    --paper-teal-800: #00695c;
    --paper-teal-900: #004d40;
    --paper-teal-a100: #a7ffeb;
    --paper-teal-a200: #64ffda;
    --paper-teal-a400: #1de9b6;
    --paper-teal-a700: #00bfa5;
 
    --paper-green-50: #e8f5e9;
    --paper-green-100: #c8e6c9;
    --paper-green-200: #a5d6a7;
    --paper-green-300: #81c784;
    --paper-green-400: #66bb6a;
    --paper-green-500: #4caf50;
    --paper-green-600: #43a047;
    --paper-green-700: #388e3c;
    --paper-green-800: #2e7d32;
    --paper-green-900: #1b5e20;
    --paper-green-a100: #b9f6ca;
    --paper-green-a200: #69f0ae;
    --paper-green-a400: #00e676;
    --paper-green-a700: #00c853;
 
    --paper-light-green-50: #f1f8e9;
    --paper-light-green-100: #dcedc8;
    --paper-light-green-200: #c5e1a5;
    --paper-light-green-300: #aed581;
    --paper-light-green-400: #9ccc65;
    --paper-light-green-500: #8bc34a;
    --paper-light-green-600: #7cb342;
    --paper-light-green-700: #689f38;
    --paper-light-green-800: #558b2f;
    --paper-light-green-900: #33691e;
    --paper-light-green-a100: #ccff90;
    --paper-light-green-a200: #b2ff59;
    --paper-light-green-a400: #76ff03;
    --paper-light-green-a700: #64dd17;
 
    --paper-lime-50: #f9fbe7;
    --paper-lime-100: #f0f4c3;
    --paper-lime-200: #e6ee9c;
    --paper-lime-300: #dce775;
    --paper-lime-400: #d4e157;
    --paper-lime-500: #cddc39;
    --paper-lime-600: #c0ca33;
    --paper-lime-700: #afb42b;
    --paper-lime-800: #9e9d24;
    --paper-lime-900: #827717;
    --paper-lime-a100: #f4ff81;
    --paper-lime-a200: #eeff41;
    --paper-lime-a400: #c6ff00;
    --paper-lime-a700: #aeea00;
 
    --paper-yellow-50: #fffde7;
    --paper-yellow-100: #fff9c4;
    --paper-yellow-200: #fff59d;
    --paper-yellow-300: #fff176;
    --paper-yellow-400: #ffee58;
    --paper-yellow-500: #ffeb3b;
    --paper-yellow-600: #fdd835;
    --paper-yellow-700: #fbc02d;
    --paper-yellow-800: #f9a825;
    --paper-yellow-900: #f57f17;
    --paper-yellow-a100: #ffff8d;
    --paper-yellow-a200: #ffff00;
    --paper-yellow-a400: #ffea00;
    --paper-yellow-a700: #ffd600;
 
    --paper-amber-50: #fff8e1;
    --paper-amber-100: #ffecb3;
    --paper-amber-200: #ffe082;
    --paper-amber-300: #ffd54f;
    --paper-amber-400: #ffca28;
    --paper-amber-500: #ffc107;
    --paper-amber-600: #ffb300;
    --paper-amber-700: #ffa000;
    --paper-amber-800: #ff8f00;
    --paper-amber-900: #ff6f00;
    --paper-amber-a100: #ffe57f;
    --paper-amber-a200: #ffd740;
    --paper-amber-a400: #ffc400;
    --paper-amber-a700: #ffab00;
 
    --paper-orange-50: #fff3e0;
    --paper-orange-100: #ffe0b2;
    --paper-orange-200: #ffcc80;
    --paper-orange-300: #ffb74d;
    --paper-orange-400: #ffa726;
    --paper-orange-500: #ff9800;
    --paper-orange-600: #fb8c00;
    --paper-orange-700: #f57c00;
    --paper-orange-800: #ef6c00;
    --paper-orange-900: #e65100;
    --paper-orange-a100: #ffd180;
    --paper-orange-a200: #ffab40;
    --paper-orange-a400: #ff9100;
    --paper-orange-a700: #ff6500;
 
    --paper-deep-orange-50: #fbe9e7;
    --paper-deep-orange-100: #ffccbc;
    --paper-deep-orange-200: #ffab91;
    --paper-deep-orange-300: #ff8a65;
    --paper-deep-orange-400: #ff7043;
    --paper-deep-orange-500: #ff5722;
    --paper-deep-orange-600: #f4511e;
    --paper-deep-orange-700: #e64a19;
    --paper-deep-orange-800: #d84315;
    --paper-deep-orange-900: #bf360c;
    --paper-deep-orange-a100: #ff9e80;
    --paper-deep-orange-a200: #ff6e40;
    --paper-deep-orange-a400: #ff3d00;
    --paper-deep-orange-a700: #dd2c00;
 
    --paper-brown-50: #efebe9;
    --paper-brown-100: #d7ccc8;
    --paper-brown-200: #bcaaa4;
    --paper-brown-300: #a1887f;
    --paper-brown-400: #8d6e63;
    --paper-brown-500: #795548;
    --paper-brown-600: #6d4c41;
    --paper-brown-700: #5d4037;
    --paper-brown-800: #4e342e;
    --paper-brown-900: #3e2723;
 
    --paper-grey-50: #fafafa;
    --paper-grey-100: #f5f5f5;
    --paper-grey-200: #eeeeee;
    --paper-grey-300: #e0e0e0;
    --paper-grey-400: #bdbdbd;
    --paper-grey-500: #9e9e9e;
    --paper-grey-600: #757575;
    --paper-grey-700: #616161;
    --paper-grey-800: #424242;
    --paper-grey-900: #212121;
 
    --paper-blue-grey-50: #eceff1;
    --paper-blue-grey-100: #cfd8dc;
    --paper-blue-grey-200: #b0bec5;
    --paper-blue-grey-300: #90a4ae;
    --paper-blue-grey-400: #78909c;
    --paper-blue-grey-500: #607d8b;
    --paper-blue-grey-600: #546e7a;
    --paper-blue-grey-700: #455a64;
    --paper-blue-grey-800: #37474f;
    --paper-blue-grey-900: #263238;

    /* opacity for dark text on a light background */
    --dark-divider-opacity: 0.12;
    --dark-disabled-opacity: 0.38; /* or hint text or icon */
    --dark-secondary-opacity: 0.54;
    --dark-primary-opacity: 0.87;

    /* opacity for light text on a dark background */
    --light-divider-opacity: 0.12;
    --light-disabled-opacity: 0.3; /* or hint text or icon */
    --light-secondary-opacity: 0.7;
    --light-primary-opacity: 1.0;

  }

</style>
<style is="custom-style">

  :root {
    /*
     * You can use these generic variables in your elements for easy theming.
     * For example, if all your elements use `--primary-text-color` as its main
     * color, then switching from a light to a dark theme is just a matter of
     * changing the value of `--primary-text-color` in your application.
     */
    --primary-text-color: var(--light-theme-text-color);
    --primary-background-color: var(--light-theme-background-color);
    --secondary-text-color: var(--light-theme-secondary-color);
    --disabled-text-color: var(--light-theme-disabled-color);
    --divider-color: var(--light-theme-divider-color);
    --error-color: var(--paper-deep-orange-a700);

    /*
     * Primary and accent colors. Also see color.html for more colors.
     */
    --primary-color: var(--paper-indigo-500);
    --light-primary-color: var(--paper-indigo-100);
    --dark-primary-color: var(--paper-indigo-700);

    --accent-color: var(--paper-pink-a200);
    --light-accent-color: var(--paper-pink-a100);
    --dark-accent-color: var(--paper-pink-a400);


    /*
     * Material Design Light background theme
     */
    --light-theme-background-color: #ffffff;
    --light-theme-base-color: #000000;
    --light-theme-text-color: var(--paper-grey-900);
    --light-theme-secondary-color: #737373;  /* for secondary text and icons */
    --light-theme-disabled-color: #9b9b9b;  /* disabled/hint text */
    --light-theme-divider-color: #dbdbdb;

    /*
     * Material Design Dark background theme
     */
    --dark-theme-background-color: var(--paper-grey-900);
    --dark-theme-base-color: #ffffff;
    --dark-theme-text-color: #ffffff;
    --dark-theme-secondary-color: #bcbcbc;  /* for secondary text and icons */
    --dark-theme-disabled-color: #646464;  /* disabled/hint text */
    --dark-theme-divider-color: #3c3c3c;

    /*
     * Deprecated values because of their confusing names.
     */
    --text-primary-color: var(--dark-theme-text-color);
    --default-primary-color: var(--primary-color);

  }

</style>
<dom-module id="paper-icon-button" assetpath="bower_components/paper-icon-button/">
  <template strip-whitespace="">
    <style>
      :host {
        display: inline-block;
        position: relative;
        padding: 8px;
        outline: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        cursor: pointer;
        z-index: 0;
        line-height: 1;

        width: 40px;
        height: 40px;

        /* NOTE: Both values are needed, since some phones require the value to be `transparent`. */
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        -webkit-tap-highlight-color: transparent;

        /* Because of polymer/2558, this style has lower specificity than * */
        box-sizing: border-box !important;

        @apply(--paper-icon-button);
      }

      :host #ink {
        color: var(--paper-icon-button-ink-color, --primary-text-color);
        opacity: 0.6;
      }

      :host([disabled]) {
        color: var(--paper-icon-button-disabled-text, --disabled-text-color);
        pointer-events: none;
        cursor: auto;

        @apply(--paper-icon-button-disabled);
      }

      :host(:hover) {
        @apply(--paper-icon-button-hover);
      }

      iron-icon {
        --iron-icon-width: 100%;
        --iron-icon-height: 100%;
      }
    </style>

    <iron-icon id="icon" src="[[src]]" icon="[[icon]]" alt$="[[alt]]"></iron-icon>
  </template>

  <script>
    Polymer({
      is: 'paper-icon-button',

      hostAttributes: {
        role: 'button',
        tabindex: '0'
      },

      behaviors: [
        Polymer.PaperInkyFocusBehavior
      ],

      properties: {
        /**
         * The URL of an image for the icon. If the src property is specified,
         * the icon property should not be.
         */
        src: {
          type: String
        },

        /**
         * Specifies the icon name or index in the set of icons available in
         * the icon's icon set. If the icon property is specified,
         * the src property should not be.
         */
        icon: {
          type: String
        },

        /**
         * Specifies the alternate text for the button, for accessibility.
         */
        alt: {
          type: String,
          observer: "_altChanged"
        }
      },

      _altChanged: function(newValue, oldValue) {
        var label = this.getAttribute('aria-label');

        // Don't stomp over a user-set aria-label.
        if (!label || oldValue == label) {
          this.setAttribute('aria-label', newValue);
        }
      }
    });
  </script>
</dom-module>
<script>
  /**
   * The `iron-iconset-svg` element allows users to define their own icon sets
   * that contain svg icons. The svg icon elements should be children of the
   * `iron-iconset-svg` element. Multiple icons should be given distinct id's.
   *
   * Using svg elements to create icons has a few advantages over traditional
   * bitmap graphics like jpg or png. Icons that use svg are vector based so
   * they are resolution independent and should look good on any device. They
   * are stylable via css. Icons can be themed, colorized, and even animated.
   *
   * Example:
   *
   *     <iron-iconset-svg name="my-svg-icons" size="24">
   *       <svg>
   *         <defs>
   *           <g id="shape">
   *             <rect x="12" y="0" width="12" height="24" />
   *             <circle cx="12" cy="12" r="12" />
   *           </g>
   *         </defs>
   *       </svg>
   *     </iron-iconset-svg>
   *
   * This will automatically register the icon set "my-svg-icons" to the iconset
   * database.  To use these icons from within another element, make a
   * `iron-iconset` element and call the `byId` method
   * to retrieve a given iconset. To apply a particular icon inside an
   * element use the `applyIcon` method. For example:
   *
   *     iconset.applyIcon(iconNode, 'car');
   *
   * @element iron-iconset-svg
   * @demo demo/index.html
   * @implements {Polymer.Iconset}
   */
  Polymer({
    is: 'iron-iconset-svg',

    properties: {

      /**
       * The name of the iconset.
       */
      name: {
        type: String,
        observer: '_nameChanged'
      },

      /**
       * The size of an individual icon. Note that icons must be square.
       */
      size: {
        type: Number,
        value: 24
      },

      /**
       * Set to true to enable mirroring of icons where specified when they are
       * stamped. Icons that should be mirrored should be decorated with a
       * `mirror-in-rtl` attribute.
       *
       * NOTE: For performance reasons, direction will be resolved once per
       * document per iconset, so moving icons in and out of RTL subtrees will
       * not cause their mirrored state to change.
       */
      rtlMirroring: {
        type: Boolean,
        value: false
      }
    },

    attached: function() {
      this.style.display = 'none';
    },

    /**
     * Construct an array of all icon names in this iconset.
     *
     * @return {!Array} Array of icon names.
     */
    getIconNames: function() {
      this._icons = this._createIconMap();
      return Object.keys(this._icons).map(function(n) {
        return this.name + ':' + n;
      }, this);
    },

    /**
     * Applies an icon to the given element.
     *
     * An svg icon is prepended to the element's shadowRoot if it exists,
     * otherwise to the element itself.
     *
     * If RTL mirroring is enabled, and the icon is marked to be mirrored in
     * RTL, the element will be tested (once and only once ever for each
     * iconset) to determine the direction of the subtree the element is in.
     * This direction will apply to all future icon applications, although only
     * icons marked to be mirrored will be affected.
     *
     * @method applyIcon
     * @param {Element} element Element to which the icon is applied.
     * @param {string} iconName Name of the icon to apply.
     * @return {?Element} The svg element which renders the icon.
     */
    applyIcon: function(element, iconName) {
      // insert svg element into shadow root, if it exists
      element = element.root || element;
      // Remove old svg element
      this.removeIcon(element);
      // install new svg element
      var svg = this._cloneIcon(iconName,
          this.rtlMirroring && this._targetIsRTL(element));
      if (svg) {
        var pde = Polymer.dom(element);
        pde.insertBefore(svg, pde.childNodes[0]);
        return element._svgIcon = svg;
      }
      return null;
    },

    /**
     * Remove an icon from the given element by undoing the changes effected
     * by `applyIcon`.
     *
     * @param {Element} element The element from which the icon is removed.
     */
    removeIcon: function(element) {
      // Remove old svg element
      element = element.root || element;
      if (element._svgIcon) {
        Polymer.dom(element).removeChild(element._svgIcon);
        element._svgIcon = null;
      }
    },

    /**
     * Measures and memoizes the direction of the element. Note that this
     * measurement is only done once and the result is memoized for future
     * invocations.
     */
    _targetIsRTL: function(target) {
      if (this.__targetIsRTL == null) {
        if (target && target.nodeType !== Node.ELEMENT_NODE) {
          target = target.host;
        }

        this.__targetIsRTL = target &&
            window.getComputedStyle(target)['direction'] === 'rtl';
      }

      return this.__targetIsRTL;
    },

    /**
     *
     * When name is changed, register iconset metadata
     *
     */
    _nameChanged: function() {
      new Polymer.IronMeta({type: 'iconset', key: this.name, value: this});
      this.async(function() {
        this.fire('iron-iconset-added', this, {node: window});
      });
    },

    /**
     * Create a map of child SVG elements by id.
     *
     * @return {!Object} Map of id's to SVG elements.
     */
    _createIconMap: function() {
      // Objects chained to Object.prototype (`{}`) have members. Specifically,
      // on FF there is a `watch` method that confuses the icon map, so we
      // need to use a null-based object here.
      var icons = Object.create(null);
      Polymer.dom(this).querySelectorAll('[id]')
        .forEach(function(icon) {
          icons[icon.id] = icon;
        });
      return icons;
    },

    /**
     * Produce installable clone of the SVG element matching `id` in this
     * iconset, or `undefined` if there is no matching element.
     *
     * @return {Element} Returns an installable clone of the SVG element
     * matching `id`.
     */
    _cloneIcon: function(id, mirrorAllowed) {
      // create the icon map on-demand, since the iconset itself has no discrete
      // signal to know when it's children are fully parsed
      this._icons = this._icons || this._createIconMap();
      return this._prepareSvgClone(this._icons[id], this.size, mirrorAllowed);
    },

    /**
     * @param {Element} sourceSvg
     * @param {number} size
     * @param {Boolean} mirrorAllowed
     * @return {Element}
     */
    _prepareSvgClone: function(sourceSvg, size, mirrorAllowed) {
      if (sourceSvg) {
        var content = sourceSvg.cloneNode(true),
            svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),
            viewBox = content.getAttribute('viewBox') || '0 0 ' + size + ' ' + size,
            cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';

        if (mirrorAllowed && content.hasAttribute('mirror-in-rtl')) {
          cssText += '-webkit-transform:scale(-1,1);transform:scale(-1,1);';
        }

        svg.setAttribute('viewBox', viewBox);
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svg.setAttribute('focusable', 'false');
        // TODO(dfreedm): `pointer-events: none` works around https://crbug.com/370136
        // TODO(sjmiles): inline style may not be ideal, but avoids requiring a shadow-root
        svg.style.cssText = cssText;
        svg.appendChild(content).removeAttribute('id');
        return svg;
      }
      return null;
    }

  });

</script>
<iron-iconset-svg name="appl-icons" size="24">
  <svg>
    <defs>
      <g id="arrow-back">
        <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path>
      </g>
      <g id="menu">
        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path>
      </g>
      <g id="chevron-right">
        <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path>
      </g>
      <g id="filter">
        <path d="m 10.487089,23.492943 0,-6.6881 -9.4662938,-12.6117002 21.9394728,0 -9.433,12.6117002 0,6.6881 z"></path>
      </g>
      <g id="close">
        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path>
      </g>
      <g id="plus">
        <path d="m 10.221407,0.29475413 c -1.1010578,0 -1.9874653,0.88640937 -1.9874653,1.98746817 l 0,5.9582835 -5.9582886,0 c -1.1010554,0 -1.98746527,0.8864127 -1.98746527,1.9874662 l 0,3.564045 c 0,1.101056 0.88640987,1.987472 1.98746527,1.987472 l 5.9582886,0 0,5.958283 c 0,1.101053 0.8864075,1.987472 1.9874653,1.987472 l 3.564041,0 c 1.101058,0 1.987465,-0.886419 1.987465,-1.987472 l 0,-5.958283 5.958289,0 c 1.101057,0 1.987474,-0.886416 1.987474,-1.987472 l 0,-3.564045 c 0,-1.1010535 -0.886417,-1.9874662 -1.987474,-1.9874662 l -5.958289,0 0,-5.9582835 c 0,-1.1010588 -0.886407,-1.98746817 -1.987465,-1.98746817 l -3.564041,0 z"></path>
      </g>
    </defs>
  </svg>
</iron-iconset-svg>
<dom-module id="appl-signature" assetpath="src/">
	<template>
		<style>
			:host {display: inline-block;}
			:host > img {
				width: inherit;
				height: inherit;
			}
		</style>
		<img src="[[signature]]" alt="T. Roggendorf">
	</template>

	<script>
var signature = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4QCARXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAABIAAAAAQAAAEgAAAABAAOQAAAHAAAABDAyMTCgAAAHAAAABDAxMDCgAQADAAAAAf//AAAAAAAA/+ECjGh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4KPHg6eG1wbWV0YSB4bWxuczp4PSdhZG9iZTpuczptZXRhLyc+CjxyZGY6UkRGIHhtbG5zOnJkZj0naHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyc+CgogPHJkZjpEZXNjcmlwdGlvbiB4bWxuczpleGlmPSdodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyc+CiAgPGV4aWY6WFJlc29sdXRpb24+NzI8L2V4aWY6WFJlc29sdXRpb24+CiAgPGV4aWY6WVJlc29sdXRpb24+NzI8L2V4aWY6WVJlc29sdXRpb24+CiAgPGV4aWY6UmVzb2x1dGlvblVuaXQ+Wm9sbDwvZXhpZjpSZXNvbHV0aW9uVW5pdD4KICA8ZXhpZjpFeGlmVmVyc2lvbj5FeGlmLVZlcnNpb24gMi4xPC9leGlmOkV4aWZWZXJzaW9uPgogIDxleGlmOkZsYXNoUGl4VmVyc2lvbj5GbGFzaFBpeC1WZXJzaW9uIDEuMDwvZXhpZjpGbGFzaFBpeFZlcnNpb24+CiAgPGV4aWY6Q29sb3JTcGFjZT5JbnRlcm5lciBGZWhsZXIgKHVuYmVrYW5udGVyIFdlcnQgNjU1MzUpPC9leGlmOkNvbG9yU3BhY2U+CiA8L3JkZjpEZXNjcmlwdGlvbj4KCjwvcmRmOlJERj4KPC94OnhtcG1ldGE+Cjw/eHBhY2tldCBlbmQ9J3InPz4K/9sAQwADAgIDAgIDAwMDBAMDBAUIBQUEBAUKBwcGCAwKDAwLCgsLDQ4SEA0OEQ4LCxAWEBETFBUVFQwPFxgWFBgSFBUU/8IACwgAgQDwAQERAP/EABwAAQACAwEBAQAA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";
Polymer({
	is: 'appl-signature',
	properties:{signature:{value:signature}}
});

	</script>
</dom-module>
<dom-module id="shared-styles" assetpath="src/">
	<template>
		<style>
			:root {
				--appl-z1-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
				--appl-z2-shadow: 0 3px 4px 0 rgba(0, 0, 0, 0.14), 0 1px 8px 0 rgba(0, 0, 0, 0.12), 0 3px 3px -2px rgba(0, 0, 0, 0.4);
			}

			@media screen and (min-width: 450px) {
				.card {
					margin: 24px;
					box-shadow: var(--appl-z1-shadow);
				}
			}
			.card {
				padding: 16px;
				color: #333;
				border-radius: 5px;
				background-color: #fff;
				@apply(--appl-print-theme);
				max-width: 21cm;
			}

			.circle {
				display: inline-block;
				width: 64px;
				height: 64px;
				text-align: center;
				color: #555;
				border-radius: 50%;
				background: #ddd;
				font-size: 30px;
				line-height: 64px;
			}

			h1 {
				margin: 1em 0 0.5em 0;
				color: #212121;
				font-size: 22px;
			}
		</style>
	</template>
</dom-module>
<dom-module id="appl-hello" assetpath="src/">
	<template>
		<style include="shared-styles">
			:host {
			}
			:host div.signature {max-width: 20em; text-align: right;}
			:host appl-signature {height: 7em;}
		</style>
		<div class="card">
			<header><content></content></header>
			<p>
				Dear Reader
			</p>
			<p>
				This is a demo version of the job application app. I removed
				some information in order to avoid spamming. If you need this
				information, you'll have received it from me, please stick to
				that version.
			</p>
			<p>
				Otherwise you may be interested in using this for your own job
				applications. Cool! Go ahead, feel free to swap out all the
				content and change it however you like.
			</p>
			<p>
				If you mention me, the original author of this, in the source
				of your job application I'll feel deeply honored and my belief
				in the good in man will be boosted. Maybe not my belief in the
				cunning of man, though: we all have to face real life, and
				maintaining a mention of me in your job application is not exactly
				ideal. Therefor this application is non-copyrighted, i.e. public
				domain under the <a href="http://unlicense.org/">Unlicense</a>.
				So screw me and get that job/project :-)
			</p>
			<p>
				Still, I'd obviously love to get improvements back into the source
				of this application. So pretty please, if you improve upon it,
				share it back. My personal tentative plans involve some helper
				tools for quickly generating project applications, or even a UI for
				customizing the whole thing. But whatever you got, please fork it
				and drop me a pull request on
				<a href="https://github.com/schrotie/job-application">GitHub</a>.
			</p>
			<div class="signature"><appl-signature></appl-signature></div>
		</div>
	</template>

	<script>
Polymer({
	is: 'appl-hello'
});
	</script>
</dom-module>
<dom-module id="appl-portrait" assetpath="src/">
	<template>
		<style>
			:host {display: inline-block;}
			:host > img {
				width: inherit;
				height: inherit;
			}
		</style>
		<img src="[[portrait]]" alt="Thorsten Roggendorf">
	</template>

	<script>
var portrait = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEBLAEsAAD/4Q9hRXhpZgAASUkqAAgAAAAHABoBBQABAAAAYgAAABsBBQABAAAAagAAACgBAwABAAAAAgAAADEBAgAMAAAAcgAAADIBAgAUAAAAfgAAADsBAgAPAAAAkgAAAGmHBAABAAAAogAAACQBAAAsAQAAAQAAACwBAAABAAAAR0lNUCAyLjguMTYAMjAxNjowODowMyAyMTo1Nzo1MgBQZXRlciBXZWhvd3NreQAABwAAkAcABAAAADAyMzADkAIAFAAAAPwAAAAEkAIAFAAAABABAACRkgIAAwAAADAwAACSkgIAAwAAADAwAAAAoAcABAAAADAxMDABoAMAAQAAAP//AAAAAAAAMjAxNToxMjoyOSAxMToxODowMQAyMDE1OjEyOjI5IDExOjE4OjAxAAYAAwEDAAEAAAAGAAAAGgEFAAEAAAByAQAAGwEFAAEAAAB6AQAAKAEDAAEAAAACAAAAAQIEAAEAAACCAQAAAgIEAAEAAADXDQAAAAAAAEgAAAABAAAASAAAAAEAAAD/2P/gABBKRklGAAEBAAABAAEAAP/bAEMACgcHCAcGCggICAsKCgsOGBAODQ0OHRUWERgjHyUkIh8iISYrNy8mKTQpISIwQTE0OTs+Pj4lLkRJQzxINz0+O//bAEMBCgsLDg0OHBAQHDsoIig7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O//AABEIAIIAxAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/AOEVKkC0oWn7a1MhmKTFSEUmKAK14ubdgO3JqvZvkEE4xyfp6VcuEzC/0NZtqSrYPTNZT3NYbHQRWh8pJXHzscKtdxoGnCzskB++3zMfeuZ09VkMcrHpworuLMfKmcdKwqHXRWty1GoqYR7sYzxQiDNXIVUECskjobsU9jZ71HIhKntWjIgByMVVlUYNNoSdzmNV01J1ZsfP61xeoWU0DkkNt9+K9LmjDgjuaxr6x8xCG2kH2qbtFOKZ5pdNk/MOfeqUqAjK811Oq6TGmSnHPIxXP3FmYx3GR0NaxZyzjYzj69+9W7J8krx61VdcZJ6Z5p1s7JIMc1smc7RqYoxSjkClxWpiMxTSKeRTSKBjCKYwqUimEUARYop5FFAGwFpdtShaNtUSRbaTbUpWk20ARMvymsRji4YYwN1dBtrAu0KX7jBxuqJmkDrtEOfKkc5/pXfWWHRSBjjivL9I1AhVQduR716dpoMdtHu67a5ah20TTXsKnjNVozu5zVmMrng1CNmPfJXI5qrISeKttjHJqtJt3VTEik6k5xVC5Q7T9K0pZUQZJ71kahf28WQ8m0VFjS5zuoRltxNc3qYAIHtxXU3F3auDtlBFcpqkiNJhGBwaqKMJswrg/Ky+hzUETlWyKkuwVlPuKS0tnuHCrgAck10I5GbERLRKxHUU4inhcAAdqCK1MSIimkVIRTSKAIzTSKkIphFADCKKdRQBv7aNtS7aNtUSQ7aTbU22jbQBDtqhd6dLdzf6PHllXcx6AAVqba2PD1otxNMHGVULx+NRUdo3NaK5ppHN+HoNJR4Y7yeZZiTnYCQOeBwDXXT+Kvsdz9lexbYCFEhJHHr0qnqGgR6b4qiMXMcqhl44Xnkfp+tdXLZQ3kO2RFYEd65JNbs7IReqTMK48Wwzb4bWKTaM5dnxisx/GdxbKSjqdoPYsMevStCfwtbyEMflH8SrxzUt34es7qzjheEbIx8uB0pKUepo4StoZ9t4w1K5lRmGFb7owQD+Nb1rrsakfb2kg3fdYqWBP1FZ0NmN8URjxFH0worcsLdW1EyhdscKkKMdWPf8qV1cvlaXmYmseI9PijZILncw77SMfmK5K81SW93SojuinG4cKPxNX/HsbPqyuBlSuMVLo9vEdJMHllo3+Yjrg1a5VqZS527HOR3ELJ5jQsEY9SxqG5iDSAo2MjIGM8Vv3tisdv5McQKjoNtZdvZMo3OOFPQ07roZuL2ZiXsBCb3cZHChe9TaQrGRj2xTr5Q5UelXdPtBDEJATlwDj0rWBhPQnIppFSlaaRWpiQkUwipiKjIoAiIphqUimEUAR0U7FFIDqNtG2pttG2rJINlJsqfbRtoAg21r+GpVi1Bom4EqY/EHP9KzttOjZoZVkThlORUyV1YuEuWSZ1ep25uLhbk9IMD8z0q7asWUCqcdyl5pLzocHC5Hcc8g1asjmMGuFo9W6bui+LeOQYZQfemm0iUEDH5U+NjinyEBc5phYrC0ijXdgZ9aaHEfAo+0bw4UcAcn0qGN4lbEjgDvU7su1jiPGkb/AGtXx8nrT/DZSeDYxIYccHFXvGMlktsyiQbmb5R61y+gX/2TUPKLcN0qraEStznaT2HylixNc1qqeWhCjFdW84aDd7Vx+uzYc479qS3CaSRzE7gSoG/iJrYhiKRAN2HAqha2ourtSwyE5NbJWuqmup59R9CuVprLU5WmMtaGRXIqNhU7Co2FAEDCmEVMwqMikBFiinEUUAdjso2VNto2VZJDspNlT7KNlAEGygpU+yk20gJNK1KKCO6spm2MzqY8/wAXT/CuisXATAPFcfdWu8iReHA610WmXQkiXPXHI9K5qsbO520Z3VjcWXC1QvNQkeUWsJAYjLN2QepqUN1wcZrG1Ay2jO0XzGU5wKwudSdjdilghs2QNkAfMSeWNc5PbwxTSXEO/cQernP86jDX6wq1xby5yTxg9fxqC4n3W7I8M8ZY8ErkfpTt2KXMzmdatLm/d5lmZ17hu1ULG2ZZwWJDLXQyTR20DRrHPKfTYQMfWsWR5RKXjtpPfAFWtjGcWnc7LTrsTWflsf3ijp6j1rmNcfNyVzxWjZO0TxS5IYD5xntisjVphcXfycknHFTHcJyuiTSbZgHnbo3C1fZalhh8mBI/7qgUjLXWlZHnyd3crlaiZasstRMKYiuwqJhVhhUTCgZAwqJhU7ComFAERFFKRRSA7rbRtqXbS7asgh20bam20baBkO2jZU22jbQBBsq1aW8jRM8Od6HO3+8KrXVxBZwmW4kWNB3PetXRGLxiUIy7xkKwwcVjVfum9BXkNgvInAXJDA8g8c06WYM6blAz39MVJqWl75DcwYWUjkHo31rn7jUDFOkU0bRzKeARkH6Vy2udl7HRPOphDKV6dzwaxb/U/JDRm2IB688VZtZTOpDEqSclTg4/z6VeuLKznQPLGGyOuaaui1N9DkrnUUuBtMDEgYHNU13BjJKNqr91a6ZrK1VCyRqQD1Pc1g6267AoXp1HemtWTOUrXbMy81AIz4blhjinaNZNcS/bJVwin5M9z61DpGmjVLlp5Cfs8RwB/e9q6ny1RQqgADgAdq3hDqcU530K7LUbLVllqNlrUyKrLULLVplqF1oAqsKiYVZZahYUhlZhUTCrDioWFAEJHNFOI5opAegBaXbTlFOxVkke2jbUV3qFnYruubmOP2J5/Kub1TxtCI3i05GaQ8CVxgD6DvQFjfvtRs9OTddTpH6DPJ/CuU1Hxw0jGLTYto/56yDJ/AVy93cTXTSSzSNI7cksck1CDgDFK5Vjq/DDNrniKM6hMZvKQuqueMj2r020XZMa8V0u/k0zUYbyLlomzj1HcV7JpV/b6nDHeWzho5FB91PcH3rmqJ81zrotctjXZQyVjappkN3GQ6ZI5BHUVsK2VxUUgFZmpxjQX2nTBjGbiEH7w+8B9O9Jd+JoY4irB1bPRl7YrppkVgePqKwdT06G4VgyfpTv3Js1sYzeJIFiLByzc4A9awtQ1KW9JUcI3JOOam1GwitHwPyrNdtqsx7CqXkZybe5v+H9a0uG1+xtOIZVY7t/AJ9jW8s0MozHKjj/AGWBryNmJYt3JzSrI68qxB9jXQjlep62VzUbCvNINZ1G3I8q8mGOxbI/I1tWPjSdMJewiVf76cH8qdwOrYVCy0yy1Sz1JM20oLDqh4YfhUzigCs4qBxVpxUDigCs4qBxVlxUDikBARzRTiOaKQzp9W8TWmlZiX9/cf3FPC/U1yN94p1W8JH2gwof4Yvl/XrWMXZ2LMSSeST3pKu4rD3keRizsWJ6knOajNKSMc0wnNIY4nkZ6dDSMm3GOV7GilDFOCMqe1ACCtzw14luPD93uGZLZz+8iz+o96xdoPKHI9Kacik1cE2ndHu2matZ6rarc2cyuh6+oPoR2NWJGz0NeGabq97pNx51lO0bdx2b6jvXe6N8QrO6Cx6kv2aXpvHKH/CsZU2tjpjVT3OsmOV9Pesu5k2g8g1ba6huYfMhlWRD0ZGyKwr64JcqprI1bVjnNbO64JrFuMeUwPQg1tXVvJPK8jn5VrmtQuMu0aHgdTWkVcwkzMNA6Uu3ccCnbfToK3OcZRTsUYoAdDNJbyrJE5R15BBrrNE8Rm7cW16QJD9x+m72NcjilBKnIOCKBnpLioHFVdDvzf6apc5kj+Vvf3q29AFdxUD1Yeq8hoArnrRSMeaKQHPDoaU/dNFFUAlNoooAWndjRRQAwE7hUzD5aKKAIDSUUUCLVhdXFvOBDPLECedjkZ/Kuos5ZJCxeRmPqTmiispGsdihrM0qW7BZHUE84YiuYc5PNFFVHYmYD/VGlbpRRVEDKKKKACiiigDpPCJ/4+R2+X+tdA9FFIZXeq0lFFAFZutFFFAz/9n/4QYDaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49J++7vycgaWQ9J1c1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCc/Pgo8eDp4bXBtZXRhIHhtbG5zOng9J2Fkb2JlOm5zOm1ldGEvJz4KPHJkZjpSREYgeG1sbnM6cmRmPSdodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjJz4KCiA8cmRmOkRlc2NyaXB0aW9uIHhtbG5zOmRjPSdodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyc+CiAgPGRjOmZvcm1hdD5pbWFnZS9qcGVnPC9kYzpmb3JtYXQ+CiAgPGRjOmNyZWF0b3I+CiAgIDxyZGY6U2VxPgogICAgPHJkZjpsaT5QZXRlciBXZWhvd3NreTwvcmRmOmxpPgogICA8L3JkZjpTZXE+CiAgPC9kYzpjcmVhdG9yPgogPC9yZGY6RGVzY3JpcHRpb24+CgogPHJkZjpEZXNjcmlwdGlvbiB4bWxuczp4bXA9J2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8nPgogIDx4bXA6TW9kaWZ5RGF0ZT4yMDE1LTEyLTI5VDEwOjUwOjE2KzAxOjAwPC94bXA6TW9kaWZ5RGF0ZT4KICA8eG1wOkNyZWF0ZURhdGU+MjAxNS0xMi0yOVQxMToxODowMS4wMDwveG1wOkNyZWF0ZURhdGU+CiAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgTGlnaHRyb29tIDUuNy4xIChXaW5kb3dzKTwveG1wOkNyZWF0b3JUb29sPgogIDx4bXA6TWV0YWRhdGFEYXRlPjIwMTUtMTItMjlUMTA6NTA6MTYrMDE6MDA8L3htcDpNZXRhZGF0YURhdGU+CiA8L3JkZjpEZXNjcmlwdGlvbj4KCiA8cmRmOkRlc2NyaXB0aW9uIHhtbG5zOnBob3Rvc2hvcD0naHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyc+CiAgPHBob3Rvc2hvcDpEYXRlQ3JlYXRlZD4yMDE1LTEyLTI5VDExOjE4OjAxLjAwPC9waG90b3Nob3A6RGF0ZUNyZWF0ZWQ+CiA8L3JkZjpEZXNjcmlwdGlvbj4KCiA8cmRmOkRlc2NyaXB0aW9uIHhtbG5zOnhtcE1NPSdodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vJz4KICA8eG1wTU06T3JpZ2luYWxEb2N1bWVudElEPjg0NTE3RkFENjRDNTIxNDAzREE2QTdBRkI2MTdDRDQwPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDo0YTU1ZDMxYi1iYTE2LThkNGUtYTA1Zi04MjFhMWJmOGNmMGU8L3htcE1NOkluc3RhbmNlSUQ+CiAgPHhtcE1NOkRvY3VtZW50SUQgcmRmOnJlc291cmNlPSd4bXAuZGlkOjRhNTVkMzFiLWJhMTYtOGQ0ZS1hMDVmLTgyMWExYmY4Y2YwZScgLz4KICA8eG1wTU06T3JpZ2luYWxEb2N1bWVudElEPjg0NTE3RkFENjRDNTIxNDAzREE2QTdBRkI2MTdDRDQwPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDo0YTU1ZDMxYi1iYTE2LThkNGUtYTA1Zi04MjFhMWJmOGNmMGU8L3htcE1NOkluc3RhbmNlSUQ+CiAgPHhtcE1NOkRlcml2ZWRGcm9tIHJkZjpwYXJzZVR5cGU9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r1l0Uq6QaqEWpIENWSVZmXEc15Jxs8VnCzgYi2ZMWYSEM2RMWQ0ZBaqdrN2UAAAgAAIAAQAgICA9FgoKCgAAAApFhwxrhL0XZ3MHqO9nOakfYzv053tdFKaoUAEEEVJQMGFwnJfMnlTjZwOSYsGbMIBiyWYssShCnWztc0CkKQAIACAAAgBAQEPRZQUoAAAAAAXJzzfPnVXodjZ7DoeRfo519DO+k1spSlKtsG0iwICRYFzGDmuDnHnrgnms86YTnZzsykqpAYsxZozFobT0azQUgpAAEAAIAAQAgID0WUFAKAAQAAAi85fLnVjrW5e57Didl92d+2a1nWjZQUpa6WE0QhFJkkowuIwReRiMVxTzJ47OSZs43OaIMksxZoyAbT06lQUgoBAAgABAAQAgID02CgoAAAAAICLiXy50Nm5fWeiidpr2Z165rWd7OliUurmmq0mi2QzLAQkuVyYJGFwczmYjgnGzjZ5rOKZsic7BLMIoZKU7WdbNIoASFIAEABAACAEBD02UoBQACAAAAi4l8mdDUdF9Z0s9hqa7537M61NbOtiWls0aRW7NJCLmXIIZlyuCEjC4MJzXCcjinns81zzImKxc8klLBCFNJ2s66gQApEABAACAAEAID02UFAAAAABAAZXyY1FsbXvZ7D0rnOvXnXtmtTWk6LoFNWaRVNWUhmIsMSjC4IokYskczBxjhZxPPc87BwsynKznZtOVUhTZ21noigAAgQAEABAACAEPVYKCggAAAAABF8+dcs0aX0Wepdy95fdnfpl1NaOhuwtIaS1U2ktRkhCElwuSAxLEyc1wcY4Jys43MMnnueNmbOdnQ89mSmjodrndloASFIVIAAgABACAEPXYKAAAAQAAAEXEvjxrRTuvc9K+ia9udeiXcu10bsKKlKaspAQyoySXJkiwkmFiYXBwjjZyTjcwynns42YswlrhZClNnVO2s0UhSIKQBAAQAEABAD1WUApAAAAAAAReUvlzqFO0vsr0S95fbnXea6y7XRqyS2qlBqylFZjCyJUlhmWWSIsMmDnHCziYueRlOVnns5pg5azTjYANGz1axaCFASAAIACAAgBAD12UAAAAAgAAAXhm+aahqOi+49C9pe+deya7S9CrbEtqoNFsqi3JecsMklGSKSGZcGTCec5pzrknNOVnns5pg46yMWZKCmz16xqhItSA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222223C+ktqPfk8IJZdysiDFykUH9gfRAGkMMkvstuk/n336a2//AP8A77anYWy0aRCfRr2Z4sz04kngYNSp4Dbz82zf/T3Teb77p7/bbf8A/wDuUu7biBXL/wBF3Ml7jovpcS4J1opjWz8k/S2SfTe677ffb/8A222/5AasDHVi0TKoccVpVibvzNFUWLJBGABr+3s3u2+33+2+22//AP8Ab2g6XZGyORDpbCyLRjSYMk64PAAk/AbYf7f/AG/+32+++3/+223/AN136kbrd7IO6A9F42BV8spkhqMCQFy2kt7t/t/tvt999v8A/wD2222I+rEldkQJp3Ef6jSc3Jtuk+SpIQ+CT6x/2/232/332+223/8A/wD8n73UWe9EvTWzgilAeoGCufNdkFP7PD9bf7f7f7fb7/f/AP8A9tttok3QFhpXbv1qc+7a9JRUUe04aASB2+U/9vtv9v8Af77/AP8A/tv/AP8A/uC98WG9cDVQqMblzTtmnN7SrgBJODz+3+/2/wBv9vt9ttt//tttrCtb53kiU6jlv4rPRXRYnRH4MQCdyM+t/t/t/v8Ab/f/AP8A/ttv/wC6MHye4bp4QK9gABs483xOUwWpkkCpvpfb/f8A2+3+32/222//APttvYM0Zh5T/wD3gkHcEMXGN63q2xGA/pZvb7f7/b/b7b7bb/8A+223v8QSggH83F9aTx0Xm44dkagxERg2TaSaXa+3+32/23//AP8A7b//AO/8j6eLOVACcKYjA1T2yaE2XQjZA2QTbT+f3+/3+/2W2223/wDtttvKIjdm+PlJf3Xm+zGjHra51R0SNW0v/v8Af7/fb7f7/wC//wD9tv8A/wD0N1700K+b7TMim9UB8Wj0xw24B0Sb3+3++32+/wB/ltvttt//APf/AFfrU9dmoi92Jg2Vp1mIl1gCsQAHaW+32+/3+/32ee/2/wD/APbbbbcMVzGKRHn9SHgtIkWe46+3MNEAZNrfb/ff77ff7t//AP8A9ttv/wD/APtvrepEmiTeed4ex3TxNBROWTyje32/32++332eTX/222//AP8A77a7QeBTiBg29D5oU0/GNY7ONeKrb/7/AH+++33+6bSW22//AP8AbbbbS3HusLP91+1Wf/ioAQB+dQRe0Df/AH++/wB99vKG0yj/AP8A2222/wD/AP24bsAhE4/Oc3rlW7N1wwRpUKtzbf7/AH3+++9jBQYU223+3/8A/v77Dkqh0u5ZR8gdFhPaogH5JMr0N/t9/rv95ZRwCiT/AL7/AP8A/tttpLXYIB8oikWAsurHPfmEmVdM6O/t/b5ZZ57iCCCQT/8A/wD/APttt/8A+3X3G8jL3NrlH23rSkAxOxuoW7W7WySy6wyggkEETf77bbb/ANv9s5J613nzaQaBbEeUya+TMymZO8lskllllBhBBBIG222323vt/ts9rL6cJYA9KDD6eJN+frI5otlstllsslspBBAIIP8At/8A/wD/APNJJJJCY/dCgEEc3y5c82HTtwF7ULdbLJLLLLCCCCCQRv8A/wD+22kkkktiq5A2sC29ER8aUBO5QBMVwsstlstlBhhBBJBBBG2222209tttsJKObjLWunUsKoJM2QzVv1xlkstlkIoIIIJBBBIO22220lttttMIPwhwQMLRye0RPfG7JRstxlllkMlBBBAIIIIIIP230skttttsFB5LI+4dvzOADpDajsOJa36sssJgIIIIDBBBIIJv/t9ttttskAALkCGs1LbVmItoJ5CEciInBFssoIJBBIaabBBRF220tttskgAAADadEsa/Wo30USs+WEna8uPllFBBAILTTSaaTT1220kkskkkAIJBdaSdwQvlenabcguev8+u4MIIoIBDaaTTSaae8/8ArJJJJLSSSWQ0ij/Gq6KN4xZX7CyCujcBYQQQQCCE2mmk2mvvt/bbbLbbSSQEk2kmHwMv96Sg2kfIQtAroOCCCCCQwWk02mk09vtJLbbbbQAAEgk0qjsenV9ssT5ZWfXjTcTmCQQQQCE0mk02m999/bJJJJJIAEk2223Y4KdtSG/7L1PLtEjRwQQSCGCU2m0mm03vt9/TZJBJIAEk222201mrToC4iFJ788XFQJKiCCCQU2k2m02mVvvvsBbaTy6222220ksrmRDbr9bn1X7bB/8AwuFEEFAhtNpNJtN62ayzgAAk0tpJJJJJZNWe6OZmulyRmvH8u+pxEFNJpNNpNpNJzWyWWwkggJJJJJJJJC2mm8k9+La5GvqU3vzPqJophptJpJpNhOSySyEEAttttttttum2222QgWGoi+mScTLVetZNNtNNJpNtPoO62S2SgEpJJttttttuSSySzIQygC/C69OZgXphNppppptNpJuWyWyWy2Ak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";
Polymer({
	is: 'appl-portrait',
	properties:{portrait:{value:portrait}}
});

	</script>
</dom-module>
<dom-module id="appl-facts" assetpath="src/">
	<template strip-whitespace="">
		<style include="shared-styles">
			:host {
			}
			:host > div {
				position: relative;
			}
			:host > div > section > div {
				white-space: nowrap;
				max-width: 100%;
			}
			:host > div > section:first-child > div {
				display: inline-block;
			}
			:host > div > section > div > label {
				vertical-align: top;
				display: inline-block;
				width: 8em;
			}
			:host > div > section > div > label + span {
				display: inline-block;
				white-space: normal;
				max-width: calc(100% - 8em);
			}

			:host > div > section > appl-portrait {
				width: 17em;
				float: right;
				transition: 0.5s;
			}
			:host > div > section > appl-portrait.zoom {
				width: 100%;
			}

			@media screen and (min-width: 400px) {
				:host > div > section.signature {
					margin: 3em 0 0 8em;
				}
			}
			@media screen and (max-width: 400px) {
				:host > div > section.signature {
					margin: 3em 0 0 1em;
				}
			}

			:host > div > section.signature {margin-top: 3em;}
			:host > div > section.signature > appl-signature {
				width: 15em;
				display: block;
			}
		</style>
		<div class="card">
			<section>
				<appl-portrait id="portrait" on-tap="_zoomPortrait"></appl-portrait>
				<h1>Personal Details</h1>
				<div>
					<label>Address</label>
					<span>
						<div>Street ##</div>
						<div>ZIP City</div>
					</span>
				</div><br>
				<div>
					<label>Family Status</label>
					<span>married, two kids (foo and bar years)</span>
				</div><br>
				<div>
					<label>Born</label>
					<span>1972/10/02</span>
				</div><br>
				<div>
					<label>Place of Birth</label>
					<span>City</span>
				</div>
			</section>
			<section>
				<h1>School</h1>
				<div><label>1979 - 1983</label><span>Hellingskampschule, Bielefeld</span></div>
				<div><label>1983 - 1984</label><span>Martin NiemÃ¶ller Gesamtschule, Bielefeld</span></div>
				<div><label>1984 - 1992</label><span>Max Planck Gymnasium, Bielefeld; Graduation: Abitur</span></div>
			</section>
			<section>
				<h1>Studies</h1>
				<div><label>1992 - 1998</label><span>Studies of Biology at Bielefeld University</span></div>
				<div><label>1998 - 1999</label><span>External diploma thesis at University of ZÃ¼rich Irchel; Final grade: sehr gut (magna cum laude)</span></div>
				<div><label>1999 - 2006</label><span>PhD graduation at Bielefeld University; Final grade: sehr gut (magna cum laude)</span></div>
			</section>
			<section>
				<h1>Profession</h1>
				<div><label>1999 - 2006</label><span>Scientific assistant at Bielefeld University</span></div>
				<div><label>2006 - 2013</label><span>Web-Developer at Echelon EDC</span></div>
				<div><label>2013 - 2017</label><span>CTO, co-founder and partner at ARIGO Software</span></div>
				<div><label>2017 - today</label><span>Lead developer at QiO technologies</span></div>
			</section>
			<section>
				<h1>Languages</h1>
				<div><label>Deutsch</label><span>mother tongue</span></div>
				<div><label>English</label><span>fluent in spoken and written</span></div>
				<div><label>EspaÃ±ol</label><span>basic knowledge</span></div>
			</section>
			<section>
				<h1>Honorary Office</h1>
				<div><label>2004 - 2010 </label><span>CEO of two kindergartens, initiative and supervision of the fusion of these</span></div>
				<div><label>2012 - today</label><span>CEO of a citizen's initiative</span></div>
			</section>
			<section>
				<h1>Interests</h1>
				<div><label>Music</label><span>Composition, arrangement, vocals, saxophone, rhythm, mixing</span></div>
				<div><label>Writing</label><span>Prose, political, and utopian texts</span></div>
				<div><label>Reading</label><span>Science fiction, philosophy</span></div>
			</section>
			<section class="signature">
				City, the nth of Month YYYY
				<appl-signature></appl-signature>
			</section>
		</div>
	</template>

	<script>
Polymer({
	is: 'appl-facts',
	_zoomPortrait: function() {applToggleClass(this.$.portrait, "zoom");}
});
	</script>
</dom-module>
<dom-module id="appl-life" assetpath="src/">
	<template>
		<style include="shared-styles">
			:host {
			}
			:host > div {
				position: relative;
			}
			:host > div > div {
				white-space: nowrap;
				max-width: 100%;
				position: relative;
			}
			:host > div > div.hint {
				white-space: normal;
				margin-right: 2rem;
			}
			:host > div > div ~ div {
				margin-top: 1em;
			}
			:host > div > div > label {
				vertical-align: top;
				display: inline-block;
				width: 5em;
				font-weight: bold;
			}

			:host > div > div > label + span {
				display: inline-block;
				white-space: normal;
				max-width: calc(100% - 5em);
			}
			:host > div > div > span > div {margin-bottom: 0.5em;}
			:host > div > div > span span.emphasis {font-style: italic;}


			@media screen and (max-width: 640px) {
				:host > div > div > label {
					display: block;
				}
				:host > div > div > label + span {
					max-width: 100%;
				}
			}

			:host > div          > div.hint    {display: none;}
			:host > div.filtered > div.hint    {display: block;}
			:host > div.filtered > div         {display: flex;}
			:host > div.filtered > div > label {flex: 0 0 5em;}
			:host > div.filtered > div.empty   {display: none;}
			:host > div.filtered > div > span  {font-size: 0;}
			:host > div.filtered > div .context{font-size: initial;}
			:host > div.filtered > div > span span.emphasis {
				font-size: initial;
				font-style: normal;
				cursor: pointer;
			}
			:host > div.filtered > div > span span.emphasis.toggled {
				font-weight: bold;
			}
			:host > div.filtered > div > span span.emphasis:after {
				content: ", ";
				font-size: initial;
			}
			:host > div.filtered > div .context span.emphasis:after {
				content: "";
			}
			:host > div.filtered > div > span span.emphasis.join:after {
				content: " ";
				font-size: initial;
			}
			:host > div.filtered > div > span span.emphasis:last-of-type:after {
				content: "";
			}


			:host > div > span {
				display: inline-block;
				position: absolute;
				top: 5px;
				right: 5px;
				z-index: 1;
			}

			@media print {:host > div > span {display: none;}}
			:host(.print) > div > span,
			:host(.print) > div.filtered > .hint {
				display: none;
			}
			:host(.print) > div.filtered > div.empty   {display: block;}
			:host(.print) > div.filtered > div         {display: block;}
			:host(.print) > div.filtered > div > label {flex: 0 0 5em;}
			:host(.print) > div.filtered > div > span  {font-size: initial;}
			:host(.print) > div.filtered > div > span span.emphasis {
				cursor: text;
			}
			:host(.print) > div.filtered > div > span span.emphasis:after {content: "";}
			:host(.print) > div.filtered > div > span span.emphasis.join:after {
				content: "";
			}


			:host > div > span > paper-icon-button {
				color: var(--app-secondary-color);
				background-color: var(--app-primary-color);
				border-radius: 50%;
				box-shadow: var(--appl-z1-shadow);
			}
			:host > div > span > paper-icon-button:hover {
				box-shadow: var(--appl-z2-shadow);
			}
		</style>
		<div id="card" class="card">
			<span on-tap="_filter">
				<paper-icon-button icon="appl-icons:filter"></paper-icon-button>
			</span>
			<div class="hint">
				Click/tap qualification to toggle context. Click filter button to
				toggle full text.
			</div>
			<div class="empty">
				<label>1972</label>
				<span>Hello world!</span>
			</div>
			<div class="empty">
				<label>1977</label>
				<span>
					Little me, aged five, wanted to be a wildlife cameraman.
					In spite of my apparent stubbornness I slightly corrected
					that career aspiration to behavioral biologist a few years
					later.
				</span>
			</div>
			<div>
				<label>1992 ...</label>
				<span>
					When I finally grew up to that goal I found that the great
					names of that field had grown, too, i.e. tired of waiting for
					me; and died - and left their field somewhat deserted. What
					ultimately drove me was a keen desire to understand what makes
					us act the way we do. And finding no fulfillment in sticking
					electrodes into life stock brains I chose a then somewhat
					obscure path in that endeavor: simulating behavioral models.
					Which taught me programming
					<span class="emphasis" on-tap="_context">C and C++</span>
					besides other things.
				</span>
			</div>
			<div>
				<label>1999 ...</label>
				<span>
					Many lines of code and a couple of books later I
					<span class="emphasis" on-tap="_context">taught C++</span>
					to other biologists. I discovered my enthusiasm for
					<span class="emphasis" on-tap="_context">agile methodologies</span>,
					then in its incarnation of Extreme Programming.
					However, I had to escape the lone ranger mentality of academia
					first, and then the waterfall world of traditional software
					development before I could start living by that ideal. Instead
					I did lots of coding on my own, learning to
					<span class="emphasis join" on-tap="_context">administer Linux</span>
					as desktop, server and <span class="emphasis" on-tap="_context">cluster</span>,
					honed my skills of <span class="emphasis" on-tap="_context">presenting</span>
					complex subject matters, deep
					<span class="emphasis" on-tap="_context">analytical thinking</span> and
					<span class="emphasis" on-tap="_context">tutoring</span>. On the
					academic branch I researched
					<span class="emphasis" on-tap="_context">neural networks</span>.
				</span>
			</div>
			<div class="empty">
				<label>2006</label>
				<span>
					I never really wanted to make home in ivory tower. Having
					satisfied my hunger for that particular kind of knowledge as
					thoroughly as the field afforded at that time I decided to
					move on.
				</span>
			</div>
			<div>
				<label>2006 ...</label>
				<span>
					Echelon, my first employer in business, called their chips
					"Neurons". I doubt they did it to attract biologists, but they
					got me anyway. I was lucky to work for a progressive boss
					who did <span class="emphasis" on-tap="_context">AJAX</span>
					before it got that name. My occupation introduced me to all the
					long since forgotten buzzwords of the day -
					<span class="emphasis" on-tap="_context">JavaScript</span>,
					<span class="emphasis" on-tap="_context">XML</span>
					and all its derivatives in
					<span class="emphasis" on-tap="_context">web technology</span>,
					<span class="emphasis" on-tap="_context">service oriented
					architecture</span>
					and all that is dear to it. I learned a lot about making pieces
					of software talk via
					<span class="emphasis" on-tap="_context">HTTP</span>,
					<span class="emphasis join" on-tap="_context">designing</span>
					their
					<span class="emphasis" on-tap="_context">language</span> and
					<span class="emphasis" on-tap="_context">communication patterns</span>
					- to the point where I became a
					<span class="emphasis join" on-tap="_context">member of</span>
					some
					<span class="emphasis" on-tap="_context">OASIS technical
					committee</span> - building
					<span class="emphasis" on-tap="_context">user interfaces</span>,
					ample
					<span class="emphasis" on-tap="_context">jQuery</span>, and
					<span class="emphasis join" on-tap="_context">managed</span>
					my first
					<span class="emphasis" on-tap="_context">projects</span>.
				</span>
			</div>
			<div>
				<label>2013 ...</label>
				<span>
					<div>
					Echelon closed many offices around the world, mine among those.
					My boss, five core developers, and I decided to build a new
					company, Arigo, upon what we had learned. I created what would
					become the kernel of Arigo's software from scratch, developing
					<span class="emphasis" on-tap="_context">full stack</span>. I
					initiated, chaired, and guided the creation of Arigo's
					<span class="emphasis" on-tap="_context">test driven</span>
					<span class="emphasis" on-tap="_context">agile development</span>
					process and trained our developers in the new technologies we
					were to
					employ: <span class="emphasis" on-tap="_context">Nodejs</span>,
					<span class="emphasis" on-tap="_context">JSON</span>,
					<span class="emphasis" on-tap="_context">REST</span>,
					<span class="emphasis" on-tap="_context">web-sockets</span>,
					<span class="emphasis" on-tap="_context">mocha</span>,
					<span class="emphasis" on-tap="_context">selenium</span> - the
					stack of the modern web.
					</div>
					<div>
					Much of Arigo's success relies on bringing that stack down into
					the embedded hardware world. Our business niche was mostly in the
					middle layer between specific embedded devices and their
					plethora of obscure protocols on the one hand and the cloud on
					the other. We build web application from our platform mostly
					for Raspberry Pi league devices but some of our trustiest
					customers run enterprise systems in the cloud where we connect
					the embedded world to
					<span class="emphasis" on-tap="_context">SQL</span>
					data bases of a couple of dozen gigabytes and do
					<span class="emphasis" on-tap="_context">load balancing</span>
					for handling concurrent data queries.
					</div>
					<div>
					The first version of Arigo's UI framework was built upon
					<span class="emphasis" on-tap="_context">jQuery</span>.
					I did some work on
					<span class="emphasis" on-tap="_context">server side UI</span>
					using Node.js'
					<span class="emphasis" on-tap="_context">Express</span>,
					and some of its template engines but found that approach
					inappropriate for Arigo's needs, which are much better covered
					by <span class="emphasis" on-tap="_context">client side UI</span>.
					For the evaluation of the next version I experimented with
					<span class="emphasis" on-tap="_context">Angular</span>,
					<span class="emphasis" on-tap="_context">Angular 2</span>, and
					<span class="emphasis" on-tap="_context">TypeScript</span>,
					but ultimately decided to use
					<span class="emphasis" on-tap="_context">web components</span>,
					powered by Google's
					<span class="emphasis" on-tap="_context">Polymer</span> and
					implemented in
					<span class="emphasis" on-tap="_context">object orientated JavaScript</span>,
					i.e.
					<span class="emphasis" on-tap="_context">EcmaScript 6/2015</span>.
					This was a huge relief after I had used my own object orientated
					JavaScript idiom at Echelon and jQuery UI's class system at
					Arigo - both are terribly clumsy compared to the built in
					elegance of EcmaScript 2015.
					</div>
					<div>
					As Arigo's CTO I managed the ongoing development, the people and
					the broad software architecture, worked with customers to
					understand their needs, discuss with our developers to figure
					out how to translate these needs into technology, estimate costs
					and keep one eye on the business side of our technology, the
					other on the future of our platform.
					</div>
					<div>
					My management style is decidedly non authoritarian. I work
					with grown up professionals and management is a service
					profession that facilitates developers getting their job done.
					My self perception is that of a mountain guide rather than a
					general, and I firmly believe this is the only way it can work
					with a distributed work force. People need to be aware
					of the consequences of their actions, but an iron fist a couple
					of hundred kilometers away would only weigh down him who raises
					it.
					</div>
					<div>
					Doubling as Arigo's single UI developer which took some 80% of
					my time, taught me to be very efficient in my communication. The
					specific combination of personalities in our company forced me
					to become a deescalation specialist or face the number one
					nemesis of start-ups: failure of communication. The former it
					was.
					</div>
			</span></div>
			<div class="empty">
				<label>2017</label>
				<span>
					Arigo is now a profitable endeavor with faithful customers.
					The really interesting stuff in IoT happens in scalable cloud
					deployments, not on the Pi - or rather the Pi-device-class may
					be the magic wand, but the magician enacts his tricks from high
					up in the cloud. So I moved to the cloud myself ...
				</span>
			</div>
			<div>
				<label>2017 - ?</label>
				<span>
					<div>
					... working remotely for QiO, an utterly distributed company,
					developing <span class="emphasis" on-tap="_context">enterprise
					grade scalable cloud IoT solutions</span> for big business
					customers. I hit the ground running, meeting the customer on my
					first day after induction training and started planning the
					project with my new distributed team.
					</div>
					<div>
					We employed
					<span class="emphasis" on-tap="_context">Docker</span>,
					<span class="emphasis" on-tap="_context">Kubernetes</span>, and
					<span class="emphasis" on-tap="_context">Mongo DB</span>,
					utilizing
					<span class="emphasis" on-tap="_context">GitLab</span>,
					<span class="emphasis" on-tap="_context">Artifactory</span> and
					<span class="emphasis" on-tap="_context">Jenkins</span> to
					power our
					<span class="emphasis" on-tap="_context">continuous integration
					pipeline</span>. Over a couple of months of
					<span class="emphasis" on-tap="_context">test driven</span>
					<span class="emphasis" on-tap="_context">Scrum</span>
					development we delivered a system that is now entering
					production with the next major version being planned by me and a
					new team as of now. While developing the UI mostly by myself,
					again using Google's Polymer
					<span class="emphasis" on-tap="_context">web-component</span>
					framework, I laid the foundations for a themable, localizable
					UI framework to be reused in productization of the project.
					</div>
				</span>
			</div>
		</div>
	</template>

	<script>
Polymer({
	is: 'appl-life',
	ready:function() {
		this._filter();
	},
	_filter:function() {
		this._filtered = !this.filtered;
		applToggleClass(this.$.card, "filtered");
	},
	_context:function(evt) {
		if(!this._filtered || /print/.test(this.className)) return;
		var revert = evt.target.className.match(/toggled/);
		applToggleClass(this.$$(".context"), "context");
		applToggleClass(this.$$(".toggled"), "toggled");
		if(revert) return;
		applToggleClass(evt.target, "toggled");
		applToggleClass(evt.target.parentElement, "context");
	}
});
	</script>
</dom-module>
<dom-module id="iron-pages" assetpath="bower_components/iron-pages/">

  <template>
    <style>
      :host {
        display: block;
      }

      :host > ::content > :not(.iron-selected) {
        display: none !important;
      }
    </style>

    <content></content>
  </template>

  <script>
    Polymer({

      is: 'iron-pages',

      behaviors: [
        Polymer.IronResizableBehavior,
        Polymer.IronSelectableBehavior
      ],

      properties: {

        // as the selected page is the only one visible, activateEvent
        // is both non-sensical and problematic; e.g. in cases where a user
        // handler attempts to change the page and the activateEvent
        // handler immediately changes it back
        activateEvent: {
          type: String,
          value: null
        }

      },

      observers: [
        '_selectedPageChanged(selected)'
      ],

      _selectedPageChanged: function(selected, old) {
        this.async(this.notifyResize);
      }
    });

  </script>
</dom-module>
<dom-module id="appl-abi1" assetpath="src/">
	<template>
		<style>
			:host {
				display: block;
				width: inherit;
			}
			:host > img {
				width: inherit;
				height: inherit;
			}
		</style>
		<img src="[[abi1]]" alt="">
	</template>

	<script>
var abi1 = "data:image/jpg;base64,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";
Polymer({
	is: 'appl-abi1',
	properties:{abi1:{value:abi1}}
});

	</script>
</dom-module>
<dom-module id="appl-abi2" assetpath="src/">
	<template>
		<style>
			:host {
				display: block;
				width: inherit;
			}
			:host > img {
				width: inherit;
				height: inherit;
			}
		</style>
		<img src="[[abi2]]" alt="">
	</template>

	<script>
var abi2 = "data:image/jpg;base64,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";
Polymer({
	is: 'appl-abi2',
	properties:{abi2:{value:abi2}}
});

	</script>
</dom-module>
<dom-module id="appl-abi3" assetpath="src/">
	<template>
		<style>
			:host {
				display: block;
				width: inherit;
			}
			:host > img {
				width: inherit;
				height: inherit;
			}
		</style>
		<img src="[[abi3]]" alt="">
	</template>

	<script>
var abi3 = "data:image/jpg;base64,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";
Polymer({
	is: 'appl-abi3',
	properties:{abi3:{value:abi3}}
});

	</script>
</dom-module>
<dom-module id="appl-abi4" assetpath="src/">
	<template>
		<style>
			:host {
				display: block;
				width: inherit;
			}
			:host > img {
				width: inherit;
				height: inherit;
			}
		</style>
		<img src="[[abi4]]" alt="">
	</template>

	<script>
var abi4 = "data:image/jpg;base64,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";
Polymer({
	is: 'appl-abi4',
	properties:{abi4:{value:abi4}}
});

	</script>
</dom-module>
<dom-module id="appl-diplom1" assetpath="src/">
	<template>
		<style>
			:host {
				display: block;
				width: inherit;
			}
			:host > img {
				width: inherit;
				height: inherit;
			}
		</style>
		<img src="[[diplom1]]" alt="">
	</template>

	<script>
var diplom1 = "data:image/jpg;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAM6BAMAAACvAyAKAAAAMFBMVEUMDAwcHBwmJiY2NjZHR0dYWFhoaGh4eHiHh4eWlpanp6e3t7fIyMjY2Njq6ur///+aIhzVAAAAAWJLR0QAiAUdSAAAAAlwSFlzAABcRgAAXEYBFJRDQQAAAAd0SU1FB+EEBgYeG5uOERoAACAASURBVHja7Z37cxzXdeed/AEbdYMvKTbHfQcv0jLuYkBKVGzjFkG98lh1ERRIKpWwiyAFyptYXQQfkJ1dTQGUSKlc1qwp25JTG03FdmznhzUr2vVm88uyLCeV/LJhWY7z2F9YGkiUknW53ff2YwYE+uy53TPA4EUCEkiCg3MkTj+nMfcz33PuuXe67/0YkK3YPkYICBbBIlgEi2ARLEJAsAgWwSJYBItgEQKCRbAIFsEiWASLEBAsgkWwCBbBIliEgGARLIK1xvZG8i/fv5SuxaXZnWMAHi6SxrZiRc9Ld7UGrIIAsMrZOlviuOyAKQHDdqEIUblpP0Pj2Rmfntt5FR4H1SXxgEi380Uphu2WgdXLITHq2rCWgtUJpp3BYqVmWBZjIjuDz+0EuQNUp+L1nawIF/mA0zrKwlKZpRueUocCbJ6yZvUi72+G1a2XHsgeXEwbdZf0WgSWhbCMkuz6Fvogiy1ImAMGrhf25FE9OXRDyVhRMgt+xMymQjMnc0ahRcSEzGk+rIa+WTMYj1IfHWQsyIPCCxVYq8BCN5SmLh0Dy9XqMNhWKFimz0wL3VDDQqfjFxlbqCzJTDydT+qXFFqVWdw3TBYy/SUMm6bCQwiLdbRKzEJl+Sbs344xq5cHJvT2/MxAWA/v52DomMVEbMJPcOPq/ABvwgRP2FW500xJ+RxM8LtgIBcaegOgyiCDZW1pJTf028DfhrDeySEcjPcGEoOjWj0pLAw9Azlg3oLaUCcHVtk38IBWVg4sz9cx6yhCy+FyhmkfxP87eEvB2pLBkpsucrBMwywWclAxjDzILWAJqGi3ml8b6pgVo/ciLMuBSk7zMnWAV7gzUxZkymJpftIysCCDZULNtGxgh8bGruqUIjAMR24GQ4RM+DyxLi2ENdiOVaRkw6mskI+lU4feHZGZpQ5TqbKkOVuf3u2w9uYgTGHJbQgNLPxnuuDqlKJWRE6oLHxpg3dQWVcWBngmpjFmfdxHIvfCUV1DyJ2IMTQzZSWpsnzWlGfc3bB8Y7eFZdsKlRRWAf8NdGK8R8UVusBwtbJyo8Z3MYaxPQuVVegaZiXZU0VY1qm0OpWGY21G4jKPYpoyIWZtrM1rFWVdYzocoX78+3QGP9EOGKCMbq0sZenEYCvGsOcN0+oC01ycOuSZXeFYiWKgmkhhMS6tLRYmZiitaZ27sX2tE7Ngat+i5kj4eLaMD2bLQxBpNPEfLnrzd2fX4vpyhnodqIuGYBEsgkVGsDYurJX22nnJhoDFLEt38XXWt7KFZJ1NmeeSfVHMZEZutktZNncrTA+0KizLYNjcaQBpwDLtm8JCyGxpWDXmtSosDsFcr179J4uJHNwUlq27Exom+YZww6yLJnyq3meq+4K9sHeTSHq3pkQq7cvAciAy0j4+K+v7Q42ioAbzks8gxF5WbE1YytAN6UGT2TMG/NJgXYFh8EnGcggrZoaxeRlYytTdWIOMtenlsGHg0mQmTxAiM9tbMmYZ1nYd4I3y0Rwqay8PjJnxTwHrqbSBZVcYWEvCMjWWtMOPB2bZ/3i6LMptYOVmLBjkVbM1YRlaWSHKog1hWW5iXXpHYwPDY/Y4Atm8TIBHJfmIFhKD+x8PEI7B926Hv9gOJhh2/beylnPDquH6W5Rh3GOiAyG6X3H/IjdjIEVU1gAHuXsZNwyMop/TUd7i/if0spAr6A7mBGEx0xKtGeCtnL9VpgpDPkjJ8Xt0cdEDbXRNuXmZ2hAMkcFiXP56Bg0rCYz5hme1Dw25LQirJ4MVpDEGceky/iSXJhGeYV9c1g3RyyyBboipWS9CCw1dnx7lMK7fa4nkUitm8JsP7tduiJR+tBmLWdgeG/AmFjhXMVE+KJilAzz6WZaUWtt/aaRL7uPSHDZ0vDvZpVgLwtIB3tSpAzNNrQmp4zbqSTJrJ8Kq4vGl8yzGrA6dMvyFaW3T9zn80jS6ATMNP4eRD6/S0YKw+vr6HgCYfAiSjq1e8nCalEKIAWkvSmOoCLJLJ6yLbeTsCXTY2IXkGLYj4yIkP05voEkwZn3fg+AB6qK5mVW21X+Lpv6sm5u0TEawVmgxRjIgWLfTCBbBIlgEi2ARLDKCRbAIFsEiWASLjGARLIJFsAgWwSIjWASLYBEsgkWwyAgWwSJYBItgESwygkWwCBbBIlgEi4xgESyCRbAIFsEiI1gEi2ARLIJFsMgIFsEiWASLYBEsMoJFsAhWa8CKRsbGnkvXqt8kWDcxySyLsR16LT8330jAOMFabL5loumpRgjWzWEZpmFa5iaEVXAI1k3c0MjpIaqM+XsJ1jJuiLBgryFm95Q8ANVLsJZ0Qzt91cMXChhlwFgXKsvUsArp9IuhySXTUwWx0oZ3w1RZPsKpILaTbBhrRwGBHpf1KLNM5kBo5LG+5GyVsy+2JCwzhYWRy0dXPMmMLovdn8asmmEYlnEvRAbSMrAeWIvR5O52ZWmHU8bWDBZCu261Iawchv4eLzTuQWWZHljopwW24WHp2hBfM1hHkQn0MnTDHIwbmEr03lMMDcwrDBNgOF+mmDULy8YwVQSUV1Hh3l49yv+PLB4a9wGYqKoJttFh+akbSmN7CuukgTx+YhYD1BszM+FFxg5IN8YZKStTFk/dcNRCZX3LcAODJw1YoXZUHdxJWXVYejoEVNao6aKCjFKg47mZJWBhOrw7uuHoR5lwo3VgJQyDuUwDvEinBQ0woTipp6/ff4+IdNBnacwqbXhYiKKiswOJyehJjc5oS5PSik7fsRYMG7BGyQ0x9cSknUM9Zhn2KNsBIdPTp1qdltkBqRsyqg3ToKQTdaus4xbCwjxdNwjTXoeCZejxsjNYeXLDVFkmY3qSCd2QHjdeZJpLmLagmcm6vGw9hZXf6AF+vp1kpejxuc0Dv4EvCSRw99stgDV6V3fD3GZYEwSLlHWLlFUmWCu1V/s8gkVGsAgWwSJYBItgkREsgkWwCBbBIlhkBItgESyCRbAIFhnBIlgEi2ARLIJFRrAIFsEiWASLYJERLIJFsAgWwSJYZASLYBEsgkWwCBYZwSJYBItgESyCRUawCBbBIlgEi2CRESyCRbAIFsEiWGQEi2ARLIJFsAgWGcEiWASLYBEsgkVGsAgWwSJYBItgkRGs2w2LA/x187bKsz7e37xnwdwoB/p23WiA/ZG51YdbEda5+Xu6Aex5+OYfHmDsRjNo5mfXKgWv1WAJgIt1/XizsHqaz5ALYEHCvJXAknYrKustGGY8KvT0ZQXdAdDOOCpIqOGegmWzzXqmsHOFvgYsGLwMA4UyBOyUQP0M4xZqjU3g2wvdLJv9ie23GWs5WOhUbDrnHYsE7Mr23K/lsasmYKfiMZ/hEh3xXTFRrCts4OBxBmFePgSj3ciUHTcvq/wgrnThbuukCZPtA+m0myZrRWVNqHxfIRbw0KwbcjilXDimnFpeu+Gpl/6YT0ClnB4uGCYHiXDwP8lrm6C3JEWstwcu424TRovVDmCXwW89N9QxK8j39aGyPgMNN+TwgirCOeXARSakjun8HKhs/qK90Ct0PMpgxVth8IrU83EjLPA5tAHG9TxYAG+3HiwHa8MIUwWEJWaVlUNl2fCk0pPTdUk45iUwOgdLtYMvUlg+n+qAQqkisH4wYaBc0coa0G6MLqhaMsCfg83QF/EGLK7/PzbDgSs37oc9EuSlkJ+CMIPVC5rS/VEbDNgF7X1GSeZStxwEuTPAY2KSa2WplnTDb4MsiJDDb2R7MHT1w2kYzZfQDQ9gndhR07VhQ1kFgGEOv2oI8C1cGWaDlzCWO9oNPTDyDKrMKuqzWjB1+EjmazEONGVdtTRlu0ptw0W2t7tggznG4G6wOw1L6bRz3NpBsKjXgWCRESyCRbAIFsEiWGthwQ2OPQxw/JJecSHW3RBQ1P9P40pc/4f2cvP80/HVjQpLnuFS6E5U5SSb9uEy4nBgsMxYu9q1q/FzRpzvE2mvxGm91Y5rVSftv2gtWOqZUrIbZFBMrjlQPDJlw8/fK+P+8wAzXpwAHNSdNIgkaLerdoTSauegu3MSEcz98FPlsDtdOaUb0hpSbLcerJn7B93ha1x+dhdsGwZWHHiVqwe7UE9Dn1KbN7XldB/OmVQ/ceSERd2jc1mj4qC89IcfOcUKeFBAV1gaLXinwOz0zbjQEx85x1oNlipJl8N5CVIVY/45rZlURx4MyctS/2Qq4AVIe5xDO7iUdhBqVBy+jWuoJnldhA7EjDlBSYA4JaECvOLJ2ObVVoMlIXAslkdYqBLOsdDdKtUR69DQRtL+ePip7scLEUcKC2OWJeCzAD9FGnJaxI5WVkdwnjF+3GeszI8yq+qIlnPDoKwcXWTPl6Vpwae4djmE9SQ8ggA1rMfhUFbqECMWcslCUdpj357StnFnVcDbwQU8eKqCqswdAHgfYdktBqvGL7q7oF+6pyJeQYf8DIhJDWsPNJR1EY+WU1gO9KgriYYlMHzbIF30VlXVbhgJGA5K6J3HfHxX7qInI4fXRKvVhvK4G7KyPGXDRR24ZQFjDnqkavcrmbIC5p7KMyQUOTCQ9x7RsC4WAOvFt3A3yGrqhuiBQWmQFY9NszxsD6ytVWc033oBXpU/0gWSRXvqXfJe0nJJ6UzvJmrurNw8gkVGsAgWwSJYBItgkREsgkWwCBbBIlhkBItgESyCRbAIFtntgvV+Y6VUXnQsIVjzrQCS6V+bwWSfXHgsP+8833KqLAe9+Q0BK7yiX/9q3r6jZuPByg79FOZCkLMmGbDap2X/J8MeWUz3RInbyrCi9J6+sXn72ntBnkjXNoPiFYtLlgfGoy7zLQa97NegsAmYhdwYmNDhly4qXn9cLmptZUXd/ZXv84c96B6OugrHynX1XLS6UmwQ8QJ0Qtjti7643e+WDnPzYc/FIutLz+tNTCl63+3xUwHKDnAHelrYDYuoBvE6rqnI/S64dVhx5m4dCIuVTXjHlqU3v8cV9x0LjkpREemjYBa8Y7QFlgGWKfS2kFByKy0MC6JKOy8BsEIEL9dh9cI3vIFMWYobZ0cSBnL38X/OBVzaDCZkWy9njfjVlo4L4WewIjjLWAu7oRf9ZcK/DHFRRuVvTmewBmD4B3l9K1Y7nOwvwGaM8tIZjnOKoxtCQW5XpbT6wwgGO/z+Qpjz0wCfC+HEpVauDctRpU2oEhgsvPJa4tRhKYY+h37G2r13WG7CMAPWGfEUltmRYLzPZ8p6xxQBuxdMM33f0AS42yYog1/SMEH9e4Dq7M3w2qaouUPNHYJFRrAIFsEiWASLYJERLIJFsAgWwSJYZASLYBEsgkWwCBYZwSJYBItgESyCRUaw1gcsxvKXQWV3jqpPL3NSkg6Yv8TeecvWh2UxZoG8P4P1qSVPGbjeqe9BWrhbdc8BN1njVt3mO3bfFC0GqwAJa5RJ7VzylO/B50HmFu2On2+sGUNPGk7gLIL1D3aLwTIAfK7EVJ/s1FqZYTZERy72h136ZkABcenR2lWY9iqz99UigPfnbuAu1q+xP2X0d6CpJv8XV6/XT3illWCZWgySV5lhcHkvFCzLkYZhGqZQmwzzsm+YWPxRYZmcQbwJDIY0GRsUqRsy0+jPYOG7OAxapobViwswTFYcF1VrvQwpuVbKkt0Iyyz7ObmtyhJElwfT9rk0vZPcN8/JHoSFDBBWGxhH3s4pBtpzVRcY9qh2PsO4x9T+Z8CvcJmrMdwv22LD/Sril1taqTZEWFvlJ2IGaov8dbVNb20DC/yc2oIvfk5rZVz4DVjZvkE9kOI2MLMQZaBpfW7Fc2Wucp8+B9E54/ykDWYr1YYA72DRqiYEm+UnEIzajC8ISztlA9ZJninL1HiQB/xIK+vxWViYWeA19LlbpX6Lf+8Eh150w72GwVoswGPxq4amtE1+AmSnr6dn0k45Bytzw6gN8eizYZSnMasO61cgPVOfuy2DlRvn8O/dk7x308MHWskNy9cwwnw8Ni8hhXujFAZPvU2adVhbwdJuaF2SbXoytZzsAlOPbdoNbFZZ43im2pS+obJFazUHhjvOjwp4sJXc0LLyejY5xrA2vB/MfFqv6TnTsFI0HCx0YBiWVlZvm5FPtZQYppkpqw7LwjOFRvyg9QQeZgctB99koLJ842RHC8E68dwXEojcah71EjpQM5GODX2ezKmP792uYcwM3D+qUUjzQj7DU9k5KpphmczY4ukzrE7N0re2YeK1vReVhRlEsfUa0tXFcRhj1pJNQVC/BaM3a8iEJa+31Kq9DtXFz6LOtf0WWGA9zG72iI4yzhgt20VT7VvM5KHl+iAK5s0DETM7qT+LOv8IFhnBIlgEa75NEyxSFsEiWGQEi2ARLIJFsAgWGcEiWASLYBEsgkVGsAgWwSJYS1tCsGYt+hZ0psNmimy7ffDXAmgeKFLfeguXnGjRr/pq3lbB+4VevGM6YbotxOJTg2whC/0SZkdkdpa42DqDdWYqGYJXficqwQPA9Sd9noMLUx7w5M8A/q0BywPcwROUV9D8bm9x+Xpmogx5f3YmX4JrfRHqmeLnDdypJ/Fev7CCZzsl8AOyhx+vCfFF/LBR7oVJlyMskBJ3x/JFMXBxG09hFX7XUd/ut2XQ3hMc6O/Lh3lxkudZ1MYliEJBj+NdNX+YCNTgbpTicTgs85z/mIERMX7O8hiDvICk0Kc3OXJ/TgYsF0vmnGTwRL4DYF8eOnbI/PqEpeDCiy/ZTlC8ADXBX9TfNufQo9mAVBK+EV0ALpT2EZZ3xHRJBeDIAB4/AYJ7Ep45kxQrYfm8Av6ZCPQo1DzEI3hhdvln+LYXIcdz4PRI+P0RcG2p54qPvVeV9+XzekB5Lv3kZT1gMVfeYRcFJ1SIf3edKkvCa2OQ2GHpwtEjnF/vgX8E3nWhnMGSEsLoWXAQllvIYewRcVEhAam8p2wQb7UH8OJYXJYhjCEsEcXaicSZFBbAjkDBU4eB5wxL2NLaMgaHi1IyEwWlJOv6zzp0TVYUBLGDgS2YfkSPYe0oxZhcr7Ce70IPsgPvOVHlvNwDutRgCw2rS0rvmei7uCPQykICYsZFWFofh54BjkWHw2PVIsI6ixfhMbg+nvY30J+yfixU8MQICjUHYKNYngG36Ms0VL2Fm1/UsCTu+LvoJTxJzTylI7yQwVVYr8qCwfNT7JIdwhdlJxesBBETvgXpINQlKQ0eKbM8BwvYvgBYu/SewmBktYXt4hl0Tw3L1LC0Nrjfq5U13pvzX2M7ZG9OfJV5QuX574KDMY11AfT9qjK3fwlgAt1QMRFhzHrT/D9OAUPVAIPCrnWrrF/YN4xoy5qXiCV2fuhiJsFdkGclBffDwZLWEjvz3R/2cxTydwEsau6QESyCRbAIFsEiWKuwWintRyrO7pjtL2nq67tMsFKL3ITPw1FV8J6L6bQc6YrqaalClB/MdgpucFgvtUOXo5JC+V/73zwSSltyJUBCJYJzXgAjcPrqD70PwCVYURHEqcgRXElPvAX931EKhAp+APL1nSq2fzuQyROnJ4s8VpJghUXgfwA2t8/LvgdeSgpXFLaFR7UbwgEpR4aD4KwTq5fOvuaSG0LVAf6fwOF/KxDQaxDnlUzaVQpLykrpuvrhhVIkz/7H1x2CBcDfFZ9HZUmhvD1xTUgpI/fHgYewfCkvKWRnRxLOvh5WOcFSXfADhBUUoc/9JxjmKhJs4N8wwFtCAcup2LJjYPwDtYuURUkpGcEiWASLYBEsgkVGsAgWwSJYBItgkREsgkWwCBbBIlhk6xyW17yRNO3xCFbGhLE8BJZ+ZQATXDHGcvpAhTGejiTMYsuyGMFCk8YBsxgYZgZrlCvLyMgw0zLrsNg6GRF+zWCFTro407yrTdzgDVF2j9I4h6MiaNOrhoYlt6YzF4B+UMlw9YQqlh4pvtXckC+ElYeJhUSzG+ZDPby0yt4g78WXWVjjOT1fhb493sejJa2spLVg1WI7ejap6pv9nz0L0SWAH2jVhAKCBdIKs0cxgmwsbpG54ScdPVy8ycGwTCMn28aO6SkrjmZHc9l0IrxlYAWbB7vag9PoN7K3o9rRB/nB4YIH6qrWD+PS4j7rDPeyQpfcrOCFcF+hc5LppwvTd1uG2YCFllP48nHcvV+AnpjmvswNWweWciSowMUCDSW7Jfoaj4RCF4JwyOmBF6V+hPDNQPhXZOAoOBccCYqPw3FVh+UFRs+sG57kctNJQ2cNRzli5P72TFmt44ZBUYJMYQl42mcW53EGKz7OLYPpJ3RGzcDFk0JXwURwKSwxZtZh/aUeYT/YNAtLbQFLo/lRTgd//75Wc0OlYSkN6zdgRD/TxatClUE6kHBdyrjznTIeR/mFziQqqxSU+GyALwiQ94UNWOMcA7zUOpObtLrkZoiN1nLDTFk9AG9Ch7TlEe2GGLC6YbLnAXhYwgunoYDK8lSADtuHsIq74Vw9ZklrxOCBqeega8CqpnMSmV3jBo+Mp4bbvZZyQzeNWRNlqLIh2N8NItbKgoDdhwFehDrGI0zfk7V2WTgVXK1uVmZPI8BjxukFpmEaOr0az6nNuIun1aSF4howDNFSyrpFVk0TjL/01s8nol4HgkWwCBbBIlhkBItgESyCRbAIFtnadP411uYGKJIEa2lTS8BSHsFaGtZwO0izLJnDeqRlTxZ6gBVAsWSEPUGwFrohl0UO4jRwCRz4296j0jkKPVP8GOQI1kJluXF/vq9Lz2usySn9g46MHjybG4E9BGtRzKrev+P1V6CAyip05SbhjA8y7HjSGYHfIlgLYQn1LIfHD3l7Ujd8VcPyqxzcE3CYYC2ExXpheED4eS7t9n382/B02MWgb4IjrIBgzbfEy/IEr7EEuA71gXwSgkUZPBnBIlgEi2ARLIJFRrAIFsEiWASLYJERLIJFsAgWwSJYZASLYBEsgkWwCBYZwSJYBItgESyCRUawCBbBIlgEi2CRESyCRbAIFsFaYGF3ujhmg2cVdjQdUOlLVcw7W5p60NYEYCq/8ELpiT0AXDXtbBporPEkUNVu7Jms/6FyffvnjDWegIncdQlLZmX7LOhx/prLKWdf5u/E8gc/c+XlJa/GF7yHL4CPVrMXvEeV6iujEDTOj+11Cutq4AQvMDsrZB8XwEeYgMJFPdD0j6tCMQiYB6YTXnRTWGfaD4M9uOcIuIF6AiYigD8GB4rO1d9MBBbWlcGVOC6GVwCu2jw5DfAeSudUSUEM7zoQjdnwCMTB88HVGM5dhvcc+bc2RE94qTZ5HMCpL8C7J9YnrD0RD92g+NsA5/Tm5/RTh8Nwv/QGtUYKsXgI+GSNK+9h/bVrWBP/71F46FvP7gEuc33xzl69t7Pq8ANfHJzAU7jc2iW72I5tSGicqx1ttY4yyMPtCu4LugvQOWB/66yQ3W2Pcam6u2tdTG0ZhPYJG2qpLB+Uog+6B9cnLD6dQ1glhHUaJNPPSwM/C4eV5vICyCqK5eBbAIf12Jt6/EjLG4VH9fEHQUiQvj5PzgxI4PuAJzkNC8al58NxLRX+U1BTaTSbUMMeeDJ0ArziCz5M4NullmqoXImuySHmwLq0vH2U+rqEFbHe+4IMltJPTAutrEN1WE+DjAVjW2L26b3M0iNR67Kcg8dgj4I9GlZFps9Wf+cnPvAh/dYU1im997SOWPyoYdYQVpUxZQIULHW1ZluGKTG6Czltco26JANmpbBgt4SayZQXifUICz+sCm2VwnJAalgJfxoOpRAUTMQ6DP0rPDikR+nMYJ1CZd2vlcVRVul5tYIaBf7ofFjHU1ij6bze+J5h9b+3S1RWKXZSd35Bs04mfC9AWKGtnwrtB3hMAl5UFdensvQ36+Xz7kO4zg7ksXxsPx9BWN2YI8hHWSz6/onLP+Gy+HA4C2u02qNgsMr1g/q8gLvM6mbgj8CmKIN1TmXKKsQ56b2jc4VhQLn0SdiPh+190CnhH1I3rKgeKcsq4eiryeSVcJsElRQSXlmXylo8OMgvsp0/1y9THiY+z3jJiAd/BjVPj5oP8LcQ97sBeo0doPaU5teBkMUQBFt1haZHFcYDCCvqEGD1Y1UJQXuk91nVotzpRIWyxLSrXyV7OYzmsDoGtUv/6YEHIIRqPoDw0fUZ4D+iKa9CzZ2VWtzWRbCobUiwyAgWwSJYBItgESwygkWwCBbBIlgEi4xgESyCRbAIFsEiI1gEi2ARLIJFsMgIFsEiWASLYBGs220Hx0bwNSpmW9XiohMSj2A1jDGLuSB3ZlsX+eITTMPMgawfGM5taFhtBZYHJbKticWwDG0g65CObmhYlgDFZrd+tAQsB5Qxu7WxYRmoKVasdIMhLQ5fzUFgWpehwNl230jJGTbEBvi/BlXTSGEpFBpEbAezYZT1bCw3FFo8shtMjE0wngPLMDrAMrXzbarDGm/z/Jz2x60aFi7/Hew3TFNEzDQ3mhuiut5BZfHEKP0pv2ZAZHkWMhHSbMQsF2HV7oHAQFjok74BqEJD+NvTt28sZVnC3wFGGZfjXBMySppFOTTnAryfU+mB/Tl/My7xP312Dsb5hoJlp254L1hYfP6nGQtHw8Lohe7ooBui5Pycv0m75NEcygmhpbD2Ika+0ZRllvx7wfAQ1njGxM1gobd90sHaECH5OdmmD6CytuHSM7Tz7t/2v/64tMFgSabTKEMkhjuuva1m6FCUKisL8DWj6OciA67rmCUNCNENncQUf5qDvvKGgoW1IAcfA3zbUdPDKGR0703jt1mHZdVjFhg9oybCmjJ4bxv03mMZQpl/ZTkbCpahq39s7lgnTa5TB99ALSEs/eB5A1ZOw/qlXu7HmK5PCIydqD5m5Ddmr4OhpyjVjebp5c6I6/Epuqzb12nWcCLZoLBW1buga4DSHfy0dxgWW9XZvZ80TNi4sAqrOrtmMb6BYd1dRrAIFsEiWASLYJERLIJFsAgWwSJYZASLYBEsgkWwCBYZwSJYBItgESyCRUawOcM/aQAADyFJREFUCBbBIlgEi2CRESyCRbAIFsEiWGRrCosfwpdqP8FaESz9Ms0J1g1Mz+q1X8DDXDwDA871h7phZheEk08QrCVMwquyJKEH3VCWX/35p+WzB4BLcYxgLWFBcaeEwOXADwcgE66n6PuuXDQXK8FKrYf7fX2OhjXal/9zoSd/7CNYy1iX8NPwnjskIZniVc4hIVjL2OBVtWMwnVtU8gFAZQ3q6RyVnpSQYC20CIO8jWicZ2DYBXvKrjFPQZDNoU2wKIMnI1gEi2ARrHVllwnWii0hZZEbEiyCRbDICBbBIlgEi2ARLDKCRbAIFsEiWASLjGARLIJFsAgWwSIjWASLYBEsgkWwyAjWnYc1dbYEl3CBq4lLsG5swZcm9ISzAa7Kkn6UB17Ru6OrjRNykM7fOMHmPV2X2I21b8NEB1i81ntpA8CCoOwoEXjSnXSlK+HMy5rVmcthqRbi2n4OKZeXoAJx0/sasII8iLD6vFKze1oZ1qFjIIQMYnFegnhXBu5DuPexCvDTSmhJ8UhPOwdj8G7StTvcZ+8+Vt3Mjnn5vvgB8VVHP4NnR/8IUsIzrQ9LlSTs2T3wrho6poKRUVTI5zWh4K/HZPZICo+9MFWWUp4E6dnVC6XzUBRKwnvfSaX5WfmGGJ70ujaAskqx2ONAIK+ACp4rIayXcG9/FIyNKdARn2vxAOpGqb4+jGB59r3LF6BoK8nyP0thTT4GE5Owy9kAyipLx+YyCFylqraU6uoe3Cvkn9h+XVnKu4aLC/DToBxKD3JxfAmVxX2Z1L6rLwBc1oqT0hMbQFmsM7ErewKvwCUMCwUDz6GQ/PbywEOZsgQwPALDBVzpmGDimFVFN3QL3bUC/xtdh8L+3VDoD60NoKwlLKQ8izJ4MoJFsAgWwSJYBIuMYBEsgkWwCBbBIiNYBItgESyCRbDICBbBurtgzRAsMoJFsAgWwSJYBGsFlhCqFcOq3nCTYJERLIJFsO5CWDPEaNXKmr41fz5pZTdMSFkfwjyCdSMrU8xaHtZ1ytnXyA1LBItsrWC9cuc+5Epqk+QuUVbQzvRCrPVnG7bqk3AKiIvZmormDqts8ZX6ZkGf7TnVTctdzlkfsErAvSOe8OCbkFxZO1gHoZKtTKYz2iVNhJJkdrVRS/N0ltPkvTdmhVZKqyUPihCBV4SnXNyM7eR/6HNVcU1hTa34GmEJxH/33f4e/yzfN7x2sA4hD5P7exDV5HSey8+xTlnpMjtkwbUKwPJxO4cq65GFJ/oKGkDPqC2kzHH5QWenfJifm6jm+hTYr1Yi25aTf9jziAT7rAzc/snQES/eIWVpWD3A8/h9CicqriUsCQGKKrr0mxK+rpCHVJDw10CIML4iJSpHwn/4MgitKcZyR0DI8DKXVSfAk4dQVXgB+zRE/WDDdRvfYB/wAu59ZppvgTsHi3cOuV2On+d2vHawDoOUBtPexrnUnP7LZqknyz1qchEHUJGsA7X3lf0ml/n0QWwXbBWVEJarQrBjllj7JDg1y/M/JWDG1bCg4Cn+OfzM5p2C9fz7vB9cLl5CZcVrl4I9o0cvSMNVl42e+C5clQirB05jyI9jT6k0hv3eBfBcWYfFZahhOcr/BXeqg3gBj9vVhyF4BfY4eDUuagfge0eSz4nKnYJldXjKLAtZYfjJ1k5Zg/s4dD2gkbwN1XYeAOuTYR/bJPtQWcDMwMQKmO2RhujtrcMyWVzqZeiGVZO/Y3zAChETPgOWk2wKVYcbeWBcWTCQu1NJqTeX66x1A9vz5v+RZGFalcz7BE1nr3km07oZvDQdgrWemzsJ/bhKyiJYdwLWTHnNuwRaX1nXr6zXDx2fHRoaKa4XWDfHlNwpQSVnR4bGyvjXTzvrSVnr0UaeHlnD/qmWhjXyZNNglddcgrW8jT29oE+CYC0b1Ieenbd9xiNYy9nZE/O3P1g2v3nGW9ew6jeNTP/5rcs1ziwIUNHlZU58//xYeT3DuvU/VicjVxf45HJD5UblecPG3jZY0x8lN4/H1jJnPL/w6stVhLrnsQjr2g2XSBydtRwiMVrAJl4uw5r5Q7iVwro1sM7oEq7d5RayWjaEj3iw7O8l06X1CWsoLdJSRz7UB16APTlxoxOX+QszI0+FpfUI6+xSRbxxrLmhvbLAxZeNk0eW1XN8woM1GBJ87WHV8+z3lzh04kNdcH4q8PXl+m4TdP5lnDBKg9zz6w/Wi/WAUv/Y1bmGL7x2eVVXWtJtlhdn9OxyPDJWaxD6l4K1ytzy317+yhyFa43vOStUVPzHuc98YVWXfW0hluISwX6+9y/9B+I1G5J/GWXJQsleKmLcJGWA2TsdsuBxrdxUOndVEav60oId30huWMdifnFhydy99vlbnTp8H7znR+Br7nvFVTUe5jKgYj2fnkvvo1UlE8nIArTX0kuPLO/+8I0l/dYbueV5lnLggtdvcxGtBlbypVld6MhVLTW59AfF1aTWycJENM3dbtTh54RLC/f4bUhKZ4pfK3zWc1j7atxwLoS+XFfXnLDc1Qnr4JKBvT7hykuL3xCOLM0qdG49rEMgDkKx2N//z19ZBSu3uY2WoK6SWTVdW3pGnjPLRSBnQc35w+bk7X8ufsOTS6ecM79/G5o7YR6EBUdtyVfuhlPPzkuoas3xOCpd81bQkpm10wu7MpyFme78dOvskeUbXnW7/tKtzbMcseJqcDZzb0hMl3b2Xi2U1VIRq/p3y11QLDj92sLuh6nnmiV9cJlgNlfhRAdvdUN6VX00Td964zucldozS2eEry0n2/eWFlZTE6C51yY8BIlzo9ZEdeQPbpkbpjq5vMoLzbjzMuZyWps3vmAPnluqtl82Sz2xIAI16uRZvTXDeVGf/N6SwUTnilMjT5dubcxavb3RlGp7830ANfd+XaRxkvUK6pfwxLLKfWrB9rNNAku/FB0Bs6px7IvpkXfdJS9TfXro0Prrz4r/vjmBSB9/bSRdNReSP6q3rg8V08KmGA8u+4WHCyJWVJpTStaj7GYRsToy0rjI153FzYmhoSfX9MfFNYJVmyteI0eoNtV4DTc6fgLGGnXUe8s3Fb+zYLsRoKLfq783Tq83dagZdzh0MAtpH7xy4bk/iocOPtn3e2t8d9kawbowr2TaJasN13nZg6QescJH4TpSjVL3O3xluc6w2oIuqym3qUnsQnM0XBDPR4aeHjlY1EEX5R1/Ya17VBbDSsqrv8oHc6uB06gA5wRWTyHiPZ7uRMmS6p+59VwsrXP/JdvIevaKKdvXZ8X6s6aKIq1zk+JN62+EdfrqrYf1YWzuw19/Fqb0Jw7LTc5Yb8vu87SokuwLP9iITa/pKI00z36hnnN8M52yrinZmE04h+oJyrUVdFp48RFYl7BGmjObtJCNT5o2qOuNYlWGqts4OW2+aAXpzk3d/nwlrqdF2qMPlmFmtiMvakSezy/Ium7cTH0P1iWs9DmB5GqWYk1pSSX1bHCqOMcy7E8Dzmupp4RaPM+VtYce/l7RG3ku8coZhLHmpnhq5UUrK/lM4N5OWF9eaUU43wnd+c2MOWE9qpWURHaWeYVZ7jsXIONMMXXnS772UVOZNXyGaC2V9d7LTU6YhfIv1S43d8ulgd/V0SlJ4/77iGtkZF63Z5pwfP3gbAk/aldw9RZ44RrAqs55R/xGaXGHSTUVVm1Pyib0mlrcQXM7xPXWtMsuctclrKZIcmapT/j1rL58JP3pVYeqs95N2uEo1o9c1KB4u2GtpNfhZtV4Jqx4toPgwpdWcNHf/cjlCmAdKiu52U+X0Xz5Td+ekiaP3W5YK+nZuOnNMu6qO8aW65xaVSA9cZthraSE0zcLLmlEX+XtbmtQkYXX1qEb/rdmQXjLiWSVwXYN2inno/UH66aSSX/wqa7OC9fgNrjEjdcfrDSqJTeIbbr36foqb7f86BELG5x3QFnXb9ZaXUnesMoeuLW4vzK8NRNZfxRlzXYrVSFmndmn1NPc57O2ivKquh+mJhYwuMlQJE1PTlx5OutoSPCqwb5iPa1Im+ppF8TbZjkbcSAbaWXUnctX1l3MiucacrEd2I1PrdKhGACkF+uRPDzeVJ46NnWTKNdIt0SUm7vq26k7y/QWiuxXsWvwWWi6OFdz+cq6i1luPb3AKi92QPTZ+8qDPP3kYpfQxcLGM2ahPN4BqkeC44TJkyi0MCjdIOSHzbmpSHLPOxcvfdVJx8IQh8QcLN3vcx7OV+I8+FwOloOOwAznwl51vcHy5hJurax+6R3ONABCu57sy6cq4Y/FNpfKByErSe4xFTriBp0KTXnDH+iRi7pj99hkdlXeo6+6r29WWRMWVwr/mB4K5IkpwWtOcya8LrtoNKwq6wIuIR3xRA91ol1Pht9wNVCeg24XJPe4nNwGPAm9seVhRU2aE2CawIN0kJUUFk+XWU/VWNr5c1DKLryY1Mf6eWPgi9i7NWPR3gTWisaFUlmk0bBkM6zzoVvFSJvB8qU+IeICHe0C8OXqjD9r2khHxMJA5Df0yrOYpWG5WlnfQI5JlBMprITPwopukbbWQlky+8VeqOJDmbJkCkM6sVvGMJ+5oQxK/VKB/Zvhu/Dcssqad2OSowvPo+LXMmXhlZLZmJWCOw+P4tfDc7IC4njg8gaidQjr52mn3iWM4XMphP5tq/YywKVMC18u6Ug8hWpyYiiqGA5A9f4qJLUb91HMundRl/pVL4bLUB3TQ6x5aeQu6fYjrqS/I/1Rvae/OFfJRrB+Y9aymXiy6j6Yf/5IPTWNN1x3Q+/ugvWhcug18h4nXL/KmiktWe7aqi9UW6NSnXXuHKwPc38F1o/lD98m+KjmrT9l3QjihQ8TZtf5KMQfu0XlSNyZ4uo/TblFYK3SIvgFtJx9bBURIPmvr8+LBW/c+mrt7lXWKuJ81XU3OKzVJFkbXlmN+j1ZueeSsjasrQxWrUSkSFm3EFYxvUH2whWCtdpk4QOPYJERLIJFsFoC1ksEa5XKqhIsslsGa4pgrdgR/4SURXZrYb1BsMgI1u2E1TypVTm7SYZg3cDiL5KyyLkIFsEiWASLYBEsQkCwCBbBIlgEi2ARAoJFsAgWwSJYBIsQECyCRbAIFsEiWISAYBEsgkWwCBbBIgQEi2ARLIJFsAgWISBYBItgESyCRbAIAcEiWASLYBEsgkUICBbButP2/wEk+ukLKypIagAAAABJRU5ErkJggg==";
Polymer({
	is: 'appl-diplom1',
	properties:{diplom1:{value:diplom1}}
});

	</script>
</dom-module>
<dom-module id="appl-diplom2" assetpath="src/">
	<template>
		<style>
			:host {
				display: block;
				width: inherit;
			}
			:host > img {
				width: inherit;
				height: inherit;
			}
		</style>
		<img src="[[diplom2]]" alt="">
	</template>

	<script>
var diplom2 = "data:image/jpg;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAM6BAMAAACvAyAKAAAAMFBMVEUMDAwcHBwnJyc2NjZHR0dYWFhoaGh4eHiHh4eWlpanp6e3t7fIyMjY2Njq6ur///98SJrdAAAAAWJLR0QAiAUdSAAAAAlwSFlzAABcRgAAXEYBFJRDQQAAAAd0SU1FB+EEBgYfLtQm5HgAACAASURBVHja7b1rkBzZdaAnMcIO//CDmY3H0F6imDf7heFM3ehqYADSZN/oBuZBSkIajdeQtiYDhQEww7CnjMIMADosVqDBAYYK75SnSQ6l9S4rOJIo/XCoQ8PdjbV/CDYlbcj7B+EhJe4fC4sC5kFxNbl1b2ZWVQOdx+fcrOqubnQ3GkA3UFO4F42qfFfeL88595yb9/FrYNKa068ZBAaWgWVgGVgGloFlEBhYBpaBZWAZWAaWQWBgGVgGloFlYBlYBoGBZWAZWAaWgWVgGQQGloFlYBlYBpaBZRAYWAaWgbVCqnKAnEiX29+dKRqlz+C27Yf27t3r6aXw4MJGf8nJOa+nYE0hLMbTZbZM1iIGcQakkBxC3rF9grHWacqd38gE5AHseBPAXlqfZFziv56BdR6zMtLKzsXK7fvjwzDJQWc5twhW/94dKVvJ5jfmhMIVFrkg+zW81pk9I1kZAIeyU+rYWG59X9af+9uCtwjW/Ip0l8DSGzevJKqfaMnSsEL7qMVRixxB8sP6toHcbRWY46IaKsfiVeZkpO0UlsBKLMsJEFYue10LU044rB+YRf+HAGrMLjNoMJjaage9Aovx0NrsbAJLHOVgF2r2fhuk5Uj7x6wQEqws63MGaxbrsN/jT77xHdRAh/myT9kkXrIPaTNrU81ybLCsz2tYJQZ1C85brCck6xTC+lwmtCivDq8NNy04moXPFWpWs/YfJwMQMlLD8ZLcNG/aUo2zHOeK2o6gpY2I8WwNS+KFMonj19pqaEHDgik77BkD72RQNvDPEcrF3KIJc8S1x0BZTglCW9usOgqe0wlr3GI2lgc/tbm0rBKRqvXRBWzc95bl1zbRQajVKFmO/pFecR0crqwUFli1x8CxLIvXUOJ+HTFEGtY1y+pbDCu1WQ6zec2yM1DTaugIaUMDz/fT0tAmWChZxUxvwKptJQFAWFLDclClNJQafeStDErWeCaxRG2JZGmdlHZAmnd+C6CW6iPwKn/WB1ZLDR0vlaxTokdgkVEpIJIU1rjlw2QWrAJ6R2obmv/QDsZ53Q6ukdx02iyeiiWqoX2DkYEnWCRZ+5GtXxto2SxWRntY7BE1DLH0Rx1sSxayw5Vxi8Ig6VyyOBr4yc1PWgMWGvgtS10HyU5hocCwGFXsKXuTFtFXT/UdtX3plFqSNTRi9wwsyDFUL5IsRrDIQCc5awu8y+GWbVnpHu7YAzZMdboOuVQNWXEb2iqEYds5Fy8QW5vQ4E+gLzKcSta4M9RDsDpSsMzS6qlJH4n+uELfAXwE0KDvRtK6TslU0Zj6LAPLwDKwTDKwDKxHE1aRMWczVcRoZymX+uh1J13PkzMZPbW8L2tbfL6WVI527pvwexTWtOM41pUWLHDSbCp2qAPWshV3E8xx2DysjpcW5Lj3Kiyq/LPmI+RWxbHclK5Orgwrtw1iaz5WlOzRUMOMrqLBzDquhjXNSuA4PMljlHiUo5C9vzws5Gh54dOQVFmgJUyyq7jSHx2Cpwt4WtCDsE5nUUICSWGylQGrEDmfZgGz/ivJcptJDZm1fP15LgPXLXpZUbOZVkdpo1retG3mohrGDmO9qIaWbVENMjgeVXX6tWGwyqiGk7xhQT4jLXiLrWDgnYyuHc3ElqD690yDCVTHkX661GBil3oQlm1ZVqBssOCWBZY/TjWltc1k6p3y0UxtAGRuJVgWSZR1BfZz2Udw9vPaNr3JP5qBY7wHYaHNGskou4HMULxKI/iVkQjLsSxvktc+A2r50pDDrIWQ6hZVmNb6UA6hlnlXw3K8cYsq5nvPwHMChrA+vWfHHnB9Z9PoDg8li7mjrn+U17a2fbBlDPw4wWIES/Y1bKq3/7OMfsnjIXLGexPWeAZtlhUkWL4V9pNAyAGqEYYgz2X/Eh+qE1aOk80qa2jpd+2z6Ruxo/x+7ql7YTmWo9/uWNmaDXZB2nNWAdXw1JaYwWQmdGB8eVjuaA4NO+ocj20sG5KRTIPeV3zDoZc76E4ser3RM+GObek3rNcsDF/6fLRdLjXrUJa1mZxS5rgrlIYO02/ta3h+gOGOtChGsuwRghU5Vl/Qe7CoqvzjFNsugL/HuLB/DpIZgLAf4KMyfLhz7o3lzjtz4sz/gAe/DFDdAxC/RK1prgLc9FEjXythqVAwtQ53SGorpK9XTRXNnVPo9DvcwFpjYsz2Daw1pwAMrAeZDCwDy8AysAysT0rxZiTLwDKwDCwDyyQDy8AysAwsA8vAMsnAMrAMLAPLwDKwTDKwDCwDy8AysAwskwwsA8vAMrAMLAPLJAPLwDKwDCwDy8AyycAysAwsA8vAMrBMMrAMLAPLwDKwDCyTDCwDy8AysAwsA8skA8vAMrB6B5ZkzLE7BhxvDU9x0H7cwFoOls2cTHvVFTFNTals9sR6XP0v3KCnYFkOw3S5tcp4nWC9xxhfj6v/1OkpyapZ/MoFZvN5WBHByq/TWOxTrLfUkAYfrC2Vo8muyWRXwVIWcgoR1o6vVln56cN64uIPx+1zQfP3cXdFHzT9RTI9jacCXQA0Dgetybx0Ki973aAXYWnJIlhsiLEC6yeTXy5aFvOLjJYF5AamGHuSplJgTDJI3tNTY9MaYzNUQOBxdRJN5gJcx325QRqVm7EBgCqj/wyv0iMGnhOTDFDedX4lK52yLFvMw7JtDWQafQz6ZlQiQOgwi7FSwhiNpR23YTnMdpxBkPYpZlkVeMeGhLaw3pGsyLKy4DgZlcKyyrDfTo28RAg5xJljV4HZM4ooIT/JaKRjmlxBWv9R3XHnYYWO/R3H2oybrRfoom9ZuInDiFPuEVgoLpZNQ6eimWF9BKsE+y2EZdPMjDRsdBm/CzHbhlJCeDyIvpUWpEO4NkO6FjsprGsItmptwc3b8H8GzlsBXU4NBj0BC6UKFSoLMEITEGvJskswbtPY22j+aSJih5CWFBmePEoKswfTU62WCCLJiJTZ6SNJgsTaSg4J1DUsZHYfM090nQdvMT3Mes7tgKUli6UWLadhFUgjtd+EcqiH75UW2Sj70MH9thdrWC4cJeJasnxopLBiiwY47xVYLReLLcAqaFjFNiymtyk68Bq6+tNo/bEYTGjeVXAsmwqDeVjWAqxUsgI9hbTVu7DKMIkScspJbZaG5fipZFH4Qo6FgMghKXJs23ZYC5YNp4iKsxnVcF6yUMERlugtWLk+goUA3kGLTLDyTipZLIUVUkg0kfoAI3jSW3rc8fFUZjQsqw9+1JKsmlWAZhsWzTDQa7BIskiKHLRZFO5MsQr+T2FVUTVR6m7hsmJlCiHBsqmEe4vmqdpUqWtYLh6XloadknUafX6L9yCsPBucRFdTw5LWIPoVIpUshrDsvk/Z6DqwLALjNVI/xiUeYBNh8in6IERgToeBR7WkH4h6CVbShiXRPZ9E0dGw0APrIw++BauKpqeYevBo4KWNn0wkzHLsAe25WwgrNfiLSsM6+7SVsws9KFkoRlnZkqwkxxi56zk3hYWGmk9jbEjR4HBaw4p7q4gJ99Uc+3F9oG3vI1h4fANVcgpt3yRKYH9vlIZ3l97Ts+advNqxKd5BFYfJsS/Pb0HHflG6kBuCRwzWHM1VeKdKQflUBWF9Zunm5FGDhRrqzzL3Tko9BNcpeOrNyr+7gOU4d6yZj6j+xvINLIUW/Y4va3I2c1wwsAAufv3OxxzogpKvS0rDT24ysAwsA8vAMrAMLJMMLAPLwDKwDCwDyyQDy8AysAwsA8vAMsnAMrAMLAPLwDKwTDKwDCwDy8AysAwskwwsA8vAMrAMLAPLJAPLwDKwDCwDy8AyycAysAwsA8vAMrBMMrAMLAPLwDKwDCyTDCwDy8AysAwsA8skA8vAMrAMLAPLwDLJwDKwDCwDy8AysExaF1hc/y0kmgjsWQNrbbAaU/+k/Fy6WKeP2Ft8PMJccdaAaP5KdVbqWVj1ywtz7EmA3Z0AxOLj+0HxO8NSvGclK84xYLsmRtuwnqI5URw4zqoOl26TDcJgrp37AUKiHA+aTHpwKjsAMQsgr7YATBzkMMvKoI57DutJWMxmXELkDcGBllAA7ICD1726OAanYXcsJMhgEMSCGgpwExum+Ke8unthEHKvD8LksA1qJxLNHXZBMm+EBb0qWRKBcTjcoYan8ZO/Cu9mUQ2nvnPB5zDWOt52+km8JiEH0pPZ+iD0AYPJSrFcFZKjlk6CFCB7Vw2n9fcz87C2w+kabnkRNWsoEpN793p8XrI2Nxg0Pg/FiobFYRBohshJmLoiCyFvPAbTZVTPHoaFalgQiyTrmKwQrItwLBIX9FFfnrdZkxUkNBnkAoLVHMQtgLCKV6SHZn0rnCpLv5dhxcwFkTw9b7O+AMcS16m8CHLnYLRLDk0EnbBkFtheBtJlXtPJDQA7QVo5NaMen8Jy4QraLB+UeIQ8+H8I6gX4a4A9AeyF0/vAg7a79RTccuEG+Vo2QsmPbQHF9pFkzYC9g+tJXEmyHiVYa0iTfrWsPjM7bGLDNaQqzcFjM25grSElepqmNwMDywTSBpZJBpaBZWAZWAaWgWWSgWVgGVgGloG1cpq7+9nWg0cWVtNbYUfkcKWrrJ4Hqd9uCchxyVhiZwHO6ENyTITpHtAVpPUZqF/pUVhRAz6s1L0yJFchgUaQziYetL4lnFFwEUBtRxhIIi8iX+JqNCPbF/giTOlvQnoS/8dXIC71JqzZIQZDow13ItmUA3df/454lAHUSKByDr29UAFcApj5GsJAHJ5QEGowCOvM9QNfpldBMoRaFkTkAivkveiyOny5N2FJkAjkX/HopB8WuESZKSCGWchIEMjpfXrZQzLzcgoLRFiW0EDJ+S7AcUnvGkdHMyEICfzxpjiiKu9EZV692rOwpG2/5M09Xar7Aq3RBwgDGg4C4ChCEcnWTCcscFySKkCb9ZqE1wF2/e9uGO04UBKDxzPPyxPH4j8uh5XehKVQsi5DXZBklUQISVRSZLoJlqLd/6JJllvDEqkZlyRtedCwXgN4HKoqRJ48A/CsvArR38xEPQoLCzPon2i4B2DnJIj68DEN61jIW7AqPLXkLyTPhT7Biv1pRKQJppK1G6phQ0QljqL3LApq/LtCzvSq66Ag/lOYLUBcgDIov341Qu3LnovQPBHLkmSjSO0VkC75CgKY0H6E25asETYU4geId9zyEWBboj9nm3rUzwrF6F0dn6zqoiY97pReKMAjkUxsaGAZWAaWgWVgmWRgGVgGloFlYBlYJhlYBpaBZWAZWAaWSQbWA4Y1u2htoWlMsmwrmeTRhhWW6TNtRaOglG4bzWXpbWHdX3Qo9+P+Fa8T5fRXvf36o8o4PKuvuQT2O/7tJ4sl6z9rt8JRg+1N/uJ2Pu2LxA8UVoT31YC066VKAi06YQkeJylrLG2IpFZolBWFUEx0jmfbsKZAVuhbLn40il773xEWh9/SNJLtEW/RFjPLwgofLKyh/sbQhH6C/azpjU8EWtqUjPZvavjTNrC+IpcTXOYUnJ3gPPEGGD5wyp47BcwLf7LPCUIWPNskEZW7Cupx2Cs0JP470TR+FyuxKu2FwrNQ8kvJvxqKIK6HFXitAYcCOAyB3/TEzBmYgdKVIwAFvEx96Ff4qP4fXPDA+2m5lAQ3fXEVXgaU/Bfg6jdhzhegn0pdwfvB2sRrXdSwJBOQN1GGonL1ptCtP1QZpIy4/NDPRiJb9b8vPSnLEs7KgIM3GHucGq2pwK0GTysvd4vvaPDDWoR4tfCEDIZw6V1ceU56WRXyQSVcWWBK5IJs4+SghD+QYkDt7pc/4NUX+VR5/xTPnRYe8AOvineL9Pv9Cl6S1GUbn+F+jydiIi+4Os2nCkenPDw2n+f5It5yOOBGg9sXdHWjYakZCZZNNkuCmv0tRs38VAlhhaXwHD5AvMlKqNslESxESaMWCFJbBX8hXabgEG6M+RGJ9i7x4sLgiyKTqh/CCn4iqZkOPANiLKHGEA1q1nQB/6oovPtgH3ivU/OcLHAB/Cv6k3ROwTkN/0MaoIPjM2wIpOm9RsfiIVz/6Vumhi0PTA1VWcpAknVSFYVoqEBEWE/LqHD9Fz5mAo1GpDMsKQOcDhG6EaCCf05tAOEE8JFBfgT2ovErNL6x+2yF8jsNkHkWcyJrdO5zILI6g41SCuu7P0MLaXMPvnYpBZBBBh4dIlqwCEETYEiCaAoC5LAvnQHGWqTSpwqqZtsPENZlqTbl5j6PiwOs4blFNJ3qmWJGhttPx/6QrCCsUIrTeF8J3vhYjSTrHyltlVzETLAEr/NnXyBR4KrA5wTXBv6Gt/savIikrkksF8WQzqMiWHs1r2MyESeBI6xmCxb+jbUlazchqAt4TkKmPsbrgo8lpYsk2QSuidfCG63BdyUVGg/MKQ0gQV/rn5Ctx5W6j5JVP1EAdT2/r1m6/jh4eDtySkiInZcUvMfxZkV1iMpJdgxISw6DyLn82RwNjZQbKORsnd9pi8Gz0uKq6WQ0LOaWeeL0Iyz7oITvRY6Le6WTvQTnHcJ0lJFkSd3aF4/RsOZy42gemSsmcoIaAl+CoxNoGvjpHM/nEFbo2mH/rgcIa3UHLE1yyb4MuVMSjt/pOXSel+1we9FBaQbf1wsLzkiQJJCU225EsOCaBfqEpLOpTnD3nvLGwqqsCCvRAz4p+46jFMhFvtPiXX3Lnj1RFI9qbHj30VFQNoF0r8SGDvPOLGhMXLgtBJGpCv1g4ZxGaSEA2FnSoUehfQruKq9VvoJPHCxfo0jkivEawQqW5JvcLV0IyUsTOvqmo2tl6Bxv8Xvz3smiL8ZE4nUecXaFePjkckUNwNu3xYcPMDYsAL/Y6BuTYGfBZXFhytU56+MRg3p/C9alkTd/72XwZ/vhzd2hl/xgEE6/OU2QfgrqYwgKCOt3oUow0attYf52ewSWlNLHqs252qb+vflS8GJ7U9Aph61qIixqlhVOb+5uxHOd1BAuyuCgDD15o4B+O9ctuJ+e3fYqRnptySom/IxKeLHB8zA0VT++Wb48NEVQ3sGs8wN5X6g9PMfZKPC89pTQXzr1aV5z6E9FOV7v68vzFiyVeBOsBUsx/6Rknn2ioOrMBXc0oLEa9d5z0tXYc24l57a2Xe8rXZQ2n2K8yiqecsfwXJXjDwwWStbr6J6jp63eARmfYJbQWcLw4vHvt2BtOwv8DDrcA8f5cXAxqsHbO6gl5T3Lot4CXHw1OCLrJdzDW2rIT8FTzwL/DfiC0tFSUbYlS1U8HS8RLIwyMeIsvR4XZF3go5If+LHPI1/DoobjEPvyDa+Oz5DMIjr4FyWcAVmiGAkjof8JPLVopNCNhvXkGYrhJFzHTNUP+60sYa7hr9qSdRLExeh0eeh46QQo5yO8dbYptVmox9x2MHKzBmRoWX4LVuhkXoVXCbm1uSqZXZ2PdznIjz3HyqSKypzMyaoDlwiWT72IrttMCF3MnFW6jx5u+x5u47qnmcMI1lnYCXgF8XOMHaytPwfxwGB95edjF6U/VIsz/2uUnYz9bfoRHmtmjiZCG1NZCQVJFuTgS4DRXCb8YwrwdujMfxdpZzNQ4E9BRVJ++DZ9789CpghP7QY+DFCVBPX0PCwFHk9aVo1T15eAn4kKNYQVluTPC2j3YnpiL+m+e2je5bdxm4gKafFxCRkqT9vGEPg+SKIHBysafQp+H3KFGqBNKZ6OS9WdmmF/Bs3JRX2I7cBLBKsfLZF/GNin66W+GhsNdQjoYCg4yXyuXATojIMYz9O95/dnpvZmZI6/d5xLNdQf9rvKf4WuNrh/+JbP3iE5mTrzrekfZ07W/oSfbmRH6hiFbs3B8HTAtWS1YAGfKj8uf8g1rMk6J1iT50oTsRB/A0L+PQ8fHKzFtcbX7z4MXxTxLaxcBvgV5TR5Az8/0LWBhYVS7pZW9vpHFXgOD38O4nIYYxQPjSqgvQqaV+kyMfyDfm4/gNhLSrrow6j9z+vwDz84U2o+l5R+iS7doeB2x+7BePDrPSYdCkLbWdPVp3cU833VDXuJ1P2x4bPzXtDBNZ0wNfbowuq52NAeaBmsRWbyiIG1rJ9FdkVV4cKirZ7SdeArhF+dXFOPoCZam4NFe+llqYrLlR6BpUow9vFvlqF0/BbMwWyZYto6vU39c6peWAGWt3w1nwdLJy7Q3OIy7xnJSnj+soAxdrCsov4c7ByJN/N8ZmLEnx75iPVRUMZ2jmNklpGVI8+BeHr31KCoMtiZA8DwEWMZJqgcLW4HTw7vwzB8tx2EfeAlmd2uDXZJxqfX+AKm+yUrx2aO0wAX58KKDAsYcdTUPtKtZpbDR1xGZRSM0KMRz5XgXwFxCB1s9MDHvognyVBIqa5oDx19Uo9LD4WIod+e0DuIHZCpwiF07DO9ooYFqlHCnF1SJRmV9PtBBzMuMRxDNZTSwliNxnKAk8+PCYT1PAW/zNJv+JQ8/qKsWTbCisr1sicSIUgNs4xl0lentVGGsHpHDSk6G/tYnFVlzLGUb8oowGgu20Acw55U5dbAFyD5zsJXgT+XvmjVo63EU4rLmrZZUYVgzXl6DwXhX9LvAd/BXb1js1LJ2u/ys82+kbCsAmbHW3dIGCzy/LU3fJUM/V9JCqvG98OxCGF9XoovNNO30q7kUtIQI3KOX0M1vO59CaA/4duB75rjIslQ7UzvqGFHdXHSLtgwDAuaacX6HFWllhs0BU+9cANi7v93cF144Q56NwwwrAQa+G3kQIz/J+DVhrwJgCEGyobqQEZAX+JwdB1Y2EuwOtRS7Ln3k/kH3duVf0PCnQ/uJ3C24dGCZWJDkwwsA8vAMrAMLAPLJAPLwDKwDCwDy8BaU7pzG7rkEYdV8yDtVgmtkVinFvWnrLqdB8di/TNRX6YKrAQftnZ2Fyw9QW+KLWjB6pwC+p3Li2BtQGX6kum5b+HzqPrtBxiJroJV50ggNwQuq54fgiKDomRc9gf5Gm1O2OPArsa7eXUogANXYn4kiOEX8GYMcClZn5bZMrP04YGEavuB8a6CBQOSS77/KtvxHmew+Ue8GNoeK4r8wOdUv1Oynyz2DUeMeqxVna0xY94U5Km1YsiYf5+/zBgofDDMuZrPXQbl5hLe4BOo93tgZD/JHOMw0F2wclVPimsegx+VpgB+yovAQh5m8pBTfQDnwYWJ6LMJLuaD34644gTLvTkkS/I+YdWz1zKTV12ZqfE8MskBa/A6J8lyaaplvQVGuwvW9CmQtitc+L+RjOPw88CUZSGs/Yljlc/DIExFGZiwPLz/iIe4/yhuG56+Iu9bsvrBOcGuZSSn8dJdyDUyKax+DSsZxM+J7oIlHZDbar4LbwWnQl4lyYoy0svDiBIS0eQgF3EQ72eOwngqWfsJlizfN6wkl3H+6e+TFZhswUL7uQALf2Wibei7BZYaggZaDxeqM1N1ZiMshzNb5GFCMRst1FFrMORgjaBx6SfJkpsdglXrZ/f52kuNRZlxyGmTSUo3y24NqbYa7oewTDfFutQpDdof+L+iV+JC0AjgRZgtQfQUPu1yLKJ99f48DCbDmMv7fUeYYwXJthGso7h23c2BtYUrB0j3JkEWqizbbQb+nv2zanldn1MBVa7ljFzT9r9EAUOmJ2BFjK3vBfPOvBRpmQ3X2Qt+qIH0uncWfDrpCHegK8MdU+twN7aHscGOyPl7Cz6jNkmVXqhwWDdY6B8M/nRBpYoLO0SnzQg3rD3akkCaGjhj+DzV2lnpMj9L36yunvl4HlbSMkr17IY/8SWw5Bj+vzrH2mF+d8FCmZmGEcc7b087tl90+9DxETkMcEWNYazWsBlU+92QK7belVnhMCR70Af5Irx9A2B27LW5V275U1gmHqWZkzAdD2gcry6TrHcbWYz5uKQorZxr8pq/qcFrYgTYRxjlXnuFzbqKF0vuClHLvdc6eOh3Sub4k8hmitkUSBOmURijmHDanq9r6yJY5//GxgD6isLQDONnGMDw0PYlxtZv1TMYZvNB6As5O5dbX8Gqb9IVCzrcqVCDcFbn9QyFO5vS2NCluLTrYBXjjB53TsOaAKpSmtwqBYNiCmsLoGQ5T+9dZzXMOQWH2STPFBv2Q65OtQ5oswZSWMOQ70JY0+B8lyOsTRLD6EmoPQHs5gAaLmCNjMxWfRa6KlOcc9cZVkllXIqbJB/HNRslKxPqQLoFC/F1W30WSRZV454nlyvIUwibQQOSlTQGEyqG5YJ0UbLkevfcbLhFPu1uaUvWuMPm7Eku0UrtoFhaFsYPDoLbXbAWjHS7EL8mlphun+xssu4BjtwECfuhElKQHDWxQJl6Rsym1aR5UIUm04P+dWe4I1NI0cjtdSkb726RgW8vtsfeQH+i2wPp212B4MgDGGKnQ83D+S56qtDlsEwgbdK6BNIi0bZiaumOgvRHDaylnkP6SngeVtAuGhtXcw8iE4s7suvX9zJ9ff8Hbkl1GywWKB5lp97hIAehWJVf7Ie4D/L9N0oMTjwAWBygo95V8QBLQ/36HiOhmt9l9VkMGlyK88MM3KLIM+lOeJMTfNKWXu76hvaqxF+uMlHDr0kUJOnq94YUSGPooIVaZcLuch2UkyvAYK1w/rJ8lYc8X8LHKfphUGZqXo5tJKs6BglHf3dQDr8n9tvos1/Sr+/fGqIIuqL78eWCLqvP0q81c6eCKagds1kGgx0hObNsDNn8jYXVZJ8N0BOtoVjv13UMGBvGejzwAUhf25/n0G2wGozm0z5f+rM/5DHGhghrrF/Ht35OehvqhlqcMXwqNT6hw2YWZ+JMK5CeIOd47olmt8EC5sttcN7qB4d5B4iSmLCyiqEaNjYyzJGo9RNAFbMaFtVxPC7bbR0m4Cb0R7zeheGOysIv6yX4wIe/hXo5LlDNiBsWRmHPRkpWjqw7ylUKq8pYwhwuGSQ5QicLecaj7oM1m/PhoafL5Fulcem0fldSXojtu0qy+h8+K5hw++YFXWtpALcPTvkh/gAAIABJREFUF25iw5YnMbowzN28oJ81sD65sSFzKhSe5ZMvLN6RoM34pYG1NNwZpPAsH2xZohY0YUrpAeVEwnstU36yu6toIKf0qNxLqrs3ojfFCqAADtZtlraNq3czLHQCmeqzvSIM3WQYcrgY/LgwwYbr/UzI0nW2YUP/Q71ylb5OlWhMGx3nJKWlNTZdBouxzysMMqZgqxSKuzczMiPHxi9PxJsxECkN3Ni4iocRa4g8dotDg6fN/T5n71O8m2FtfgYI1ikYqhVCPuL4sqR4Ds7H2ZDLlwbObFjEkzzeIFjiPECYAegD/Uo84t2thvqlcBEGpSd5cmFzjWAFRbzvTPXc4JkNG7eonoFh+uUpfRM1fR/wZNzNsPTcTBrWkBrKi9z7gzKb93OC0UOWJVttWMXD3JP1x6jKoUjR/JwdUJ+nerarYVFdpOKKH4DBZM8AVB2RsCHITWDAHwpZ/pG7YZKV5Jxhucni09sh5sqyOau7EzzkN4KuhbV8eiDvdaLCVshJIZ+k+a4YEy5Uh1DKFXzCYB14ELB2LqicHoNeTwKhrsInDdaDSMnEQsNLckyTCi0dAwOrN2JDA8skA8vAMrAMLAPLwDLJwDKwDCwDy8AysEwysAwsA8vAMrAMLJMMLAPLwDKwDCwD675SYGCtlKTtltN2KxfYDvhvoTUy4Xwq6U8vAuor0rErbjM9dOhQ/MjAmh8Z+9ugx7QN5CLZEukX8XxCdPQOidoL53ackY8MrAAuSsiNESzgL0jGFVjZcIrnKjVWOTE4zED2g2ACeZ2VUyU4AO+/CHDjexB7ENKAbk+BjCFpADSpn1K5l2GhyPxMyQCZaVi14Bkpy0r5+Y/5LuAHwG1ks5HguF/BOSkGZXm7OolSNgFb8snwDrzCMyAHM2pnRu1wczMjE4XehnVaShqh9VWEtU+Ckgrw7yLw5A/4y6ij3GacmuMRLFDvnb2AWhfRIALX6yJIYcHhGwFu3g0+JKK3bdYuKUmBCNbXEYeiGXrhEvD9Pv9tmgfZpwm3W7DkqcMHJBUCITAHjlLfu+fwGsfzzJUwBn6N9TSsN97lUu0jAYOpGV8G25X0L2jJ4lHm67A9ydC80Iqw7pbBdyWEuFz3Vb0s4xmV2iz4Gs0XDbvA481ehqXc7Sgzk1giFh0OvmKeghyXBKvYz38D3D44zwIhOUjneenwkGWp8Btlicsq/TT8wi7EdELu2i7hy4k3cID3MKzbTdi9Oacf6TOC+pXk0YEV9qj/bmJDA8vAMrAMLAPLJAPLwOpmWBMYunQOjyP9dISxuLMHa8PA0qlagoFFsLy0Y+aijt3FTnDLBX/zQ7iVOq61MIj0csNSJjA0pX9Pn7t46KCnlhy7u1tqHXiYadB8SjoDpSWwgjTSy98JVjst6uG8MBTlmduPxOu3YO1dDJbS0JKDt3dLrQOvcikYzVkhxbTFpe8Cs1NYNIdmn1WosYlbQ6zIcN2Tk7vwhCqD6evDMJTbB86Y9Ghog+IhMdtX/ume6x6MVMCjrrB76z6BiJ+A41A4AMkkzBZ8aJYOAxyEn29tFBrQqNe8CsRl6IvxwAoG4jo2pcFLaFbWOpQC+HsaRr9lCEr4/MoPDxYMywLCClB/al5/sr3mjUouPQ0rD1tUtsbHA3bLlcNS7FRcumefdIApXuQMWJiVv8UiXi2xWfcozx8bkn01XtzhNhjV+bDQHqEv5o/ctBwu7f6YcQhdJooOLzrXuOQjdm2fO8sccNj20PkcMGtYS9Z7nqThS2yaDs/pg88r5iY7pr+VZ0Ky0YcIK0cDSI47oob/HKe/5rNrKGepGo7T0PYZBuPNz9AY98F5XvPqjNefaHAaZX8QPkPm6rP5AOnRQBZbaIBDBhP1x2iiB2LJoZkJt7G5rVHmFOQiRBHhITFsDTM0xudIUvNoFguanq/GawUW6AnDBmj6iqmPB2ioy6N/Wry6TRbegfE+tGzb73lCt3WBlWc0WFy8BdXQQ1tR890qcaIhDCa+oOcBYLC/wfG+x2iCmVKd9ddZLpvXc0Ju/w+WDS6jwWqjTM3ZSrBseKvBCZYdZhRKkm1lRpJtjcyIxWgrzbxQc4bDDMIRDDQsmpShr4bS10+TfQBYLoyCfIV+lOOzLD055bCSzKCoDUhfPkRY8r9EI8++vVU+NuI572WxdLr+j97yIBx6482RxpZ0Xks2m6GRdR4LCVZmHIYjUURYQ/D4UZSs8SHUy0wtY4GG5aAgZuopLMwgAXKa2+rZ8dQQ4jWyVvIYSdY1PoKw+mQmLLuwueZRobhZF64000e1xGncl0mo/vAz714JYL9Nhl89XFicRgxxxKxdFNccn/wsNBcQOfbWaeYSrCqbaGhYTEsWLjhodlANh2D4LcemkVEYOFbGcTbH1hT/fy2rkaFiEQnSINfWiHBuZhq8trmvBYvb+x+LNv9oiyNyCMuNtuz/lgub5NaRy5tgM50yJPn0rpFmNkThmxx2ksflNjtxJwtsatvDhZWmhQrSJGm5QascGlxpnZG0Pn4PZiP+kXcpeRFLNiz4CnMFSA7GXoTScn0Q9oBoCGAejckVcyqAXbAvsyrCotJ3amvgwgCMZFAJB2iYo634HJi4RZOa8vy0gCeBZUklFQNVUA8d1v2muE/ydXpqYvGGySUPsxdiw3Ubh3np0GyTvRhId/sEiKbW4UGHO2LJkEb9BtbKnoNI6wSS2+sKDKzlYEXDLHSByvNJHrinfMWV+OdYhFf3+QbWbbD6q0PjpdELrhqaCJydAzRS29QAAx0HG1hLYKG/J0uDGMt6Uowm6HkjrMtHN3Box08orBrC0rFtYRhjWZsGkxunkOw8HA3XcwqJ3pAsDi7BkgUXMBKsg66tonFLT9UzsYG1ODGm56us+UXmxg5G0c722LJQsvbjooG1JP1Qf95MyGsIfTgXBnAs9P8Kvg3RmwbWStHd6JJxuxPXGPgVfXk2dltwXDCweiU2NoG0gWVgGVgGlkkG1sOEteCBpj1W2x1U/27todPtrscvoHkVvxpB3FuwRIeDqmPs1srRoE67vLuFlWzWT2CalvML/YRXTl9bWKRWMw1fNLoLlgg9FYIfjsbbRUL17yezqlKvlgAiCR9U6M1UnscCrhLLFb3U5CDAh68AQ/G5WpqXSReXZkJbRwewhuqejnjhYnpzXTax2knJzyAsGRyP+GmgRi/VCldqBuqCNTPFOg/g5I66l58qsw92rvgyY8rpTywGzO6PGIfYYXw/jEibk3SSlCYKlr48Xe5e3FLE4H3w3md2Kc8bXtYpgUi47Id9rBtg3VBChPCCwrzwp04IaAgJY0r3xZQKVAOzeOLaB4InXMhgxekl8oUCNYZwgEVbqI6shrBy1CKGYLUmKnzmjveyH/B5jX0f8BZORmPVus/PkIzxvZHY+0veBbDk2ye5hsVBCFSzm14LFvVn3bvnX6JqHIZBwalLsLPi4606m6Vlc4KVoWZLkiSLWsRUF+zfi3e8l+fhFYdtex1NA1ySo+ySx1ENZeRxyHrQDbBIIFSSVfAbCf8K+NDExypkKlkyaNZ9mhhuHO+Xi1VGJJgFh1p1oSLq5pWCYDkESy7Mg3lwDQb+pSzN+6FhXYVGCqtK/bRFV8CqZ2RJuR5qHOPS9fAOEZaipmw2NV6so2QdgapXzFd2hEMrtlCccu1ZZ6TCqIoaqP0aP/WUBXahBYu67sOX7ngvLwI/DGPXAUX9XOirusfPYZnIyGx1B6zb62OSVpOVtKVy0PorYbkYrVj6z7kCzm9FyRrVE7BPoNXqGwGHQ41g1QsdY22skg4xv8r2SSYikK+4/Qiris9qC6gcdBmsdUySX5sv+rR3ht4E3PLv6tEF6ZMK1q1yrVthNS3rdk9XPeSb+kTFhomBZWodDCwDyyQDy8AysAwsA8vAMumBwopOlFoLFLPOzscmiYG1TA1B8J43H/GqwxNpTcjJdKiCyHXWfCHVUcvQ3NxZofJHPQMrpIomEiqernxZrxwBqiKFn8EN7+5gyRfoM5e+//LTPX/48Ksc1g1WzF1/c/6Gm2b428rVsLRkkbS5nDe83AB86surXcb1FTDE/IQWKQ6NgoAvs2BSQLF04WgwWlIC3i590mHVbBuQRuSLFNbPdE37JHP8FqzdtFtIdeX6amIVZJXUhxOs2NcLYkh5uWhs59QPMxcq/5mE7Vc/8TYL/2ejctPj6cqrWmOOpBkW+j+vv8CEzOVWu0ywVaZjhWhYhZgJelsE8C5e8nsJl/WX3i7xXrBZSMOLvZZkpe9wXkphHQfKMY/9YHJ1qyPtYQmTbcmiUXA5x786s4g/cBnabuGTD0vqDI5OBByxyWcmuaI39s8jrEC/ACwLyEp/rKZEtMpVDsGwknrIGE3ki/gtGjwrYUrCtQsIq/HCXEX0iFM6VwYagDu5VEZUMcD/Bs0StTzYw9EXqA37UxwmVsursnepyBHadRBkCFkwkeMj0mE3Gf82iqs34oDXI7CMB2+SgWVgfUJKQzaQLkyXaKU1BtqLB3Wo8q9PXAbyRZvwg7u8bLDC8ifddQjTYm5Mr7S6Nj0P8jKQh1QMaEM9unNJph2xJKfRS6efCLXGQXm9Z2JDarHR/1nJZS5d+Ur9EFDjn4g8hzOgznF4A13XwqJ2Bys5bFAv6K9BuH4V5l/dv9pDsJSPzraEVrjzlzq3Xwv012twrT4kz3Alv5ifEhP+yldxnpSKeS1ms1yT2u2A8xmwM6cd7ojxzTDhfeJhORgpx4WGDqSpNZUWgqNMq+NRewD4C8lZFZZ5wsdWvsofwmdVyvvPKIQqpYF0VgbTteDA+YCrW54CHvSAGgKPSo12IH1SpTZLW3oaD5Ln3AEZlXOM71v5KsnIdqWo6cwcXSYqoDdPsSF8wCRNjoGx4a9bBQ96AtYsV+UWLK5hPUvtGluwjuD2kHavEu/8CDCQbnJqQ5tWPdxEUoLLXdOSlJlree0RWFDcCYIa3TIbbXGoA2mqYNGwqg5HNczvEavAysePqRrV+QldDDggxXYpeA1sWd57HCVr7j+XQa8E0rep1W0eUrLqeGjR4AkFdgCKUYtGmGNZUE/w/XWrllje60CDQg6iZBV6Eta90l3TVhPumNjQwDKwTDKwDCwDy8AysAwskwwsA8vAMrAMLAPLJAPLwDKwDCwDy8AyycAysAwsA8vAMrBMMrAMLAPLwDKwNjb9y/L8eAfzqdErsBQA/8riTe0ep3rsbj1Mcml+X+kOjfmk5ZRrFqPhSqU45TiPAXW4ZnpO4YJjpy3GPbhBCL0H2iR3vWAt2SQ6BUJ14gN2bMnBPswfJE7ixwjUMjW8QJhBWOcBLIBZBte4zECtBHl9dAR6SsUdUoSLWsZ3Dho727WwCmBdUf1vj1fqrJKMgtgJ8OdQasYQBh9UAYICb3XDUVdpwIagNXlyELTBSt16lNo2j/t6rjaIEI44Re2WSahm6aNWaMFS8F1a4Alf3EtFLr6tLoQlR5n4mgIur14IuML7/2UmJwXIJpcyGgp3jUJyIc//xwN8YkKPlIzC0n/TEWFOKHsnqzMFSjEmTjEQJ7QaboaaZW0NLcsSp/pH+vSkgJCgZMm2ZB0G+Ekqwk0P8GQJKpnIyuJPIROx8h/nylGuZIvulKyE+8f27pXwOopJQKMZc1xQ6oSSYUGmaprBg7IBHRweCqnHShDCcQVP1EuCBvcOJPCbL3BSQzhqiZptPx5+2vp1cUqPV4raxrbWOmChJusxIuRMgovJDvwRWZHSq8ngMPBiIPBy1a5Vw9988ezLEi6CqDr8BT2SA6hp9ZIMyyod55crxqv9pCj1okRzzbxkchCz1CgTLAlyzrGEhhWAzNAk9mGqhjSUhuS3XiNYaLMm27Deo++dejHmND74obyEWhbRZfA2/gg82bWwvvozOCThEi4A/z6MkWTNslpGRmUJP9Ow8K8S+dRHRWprckDSGaJRQFhVIop8OKmhA/F/Og/rKNBE9uF2gK0qA6euLEjWFAlWWS9e0OODp0OqB8VBFG3xuu7u0aWwvo6CowDvcopxSV2U0GBsllxGJTXIAPJFPnCe76Q554cCq8Gvq8IxCU9pyRpTlRxmNuCxryVrwnV4zbJZS7Ko1wVYT7HPJOx4X3u2cbz6u/iV1dzqKMXJtNTySV1gCNb3CVbShbAWpfQGO7thztHWAnw0Azd1X5JduqNmsdQcCq+jgZ45Dw6asFBc69c9opBOH6CisjAL0isGkMOzQtYXQNHm0JKs10icZIMxHhXQwDt1VgR6WhKeO+UiLI6SJYXodljrkYK1CHPL45UPsAfiJzQ2nJ1pe7w/NoH02pTdBNKm1sHAMrBMMrAMLAPLwDKwDCyTDCwDy8AysAwsA8skA8vAMrAMLAPLwDLJwDKwDCwDy8AysEwysAwsA8vAMrAMLJMMrFa6YmAZyTKwDCwDyyQDy8AysAwsA8vAMsnAMrAMLAPLwDKwTDKwDCwDy8AysAwskwwsA8vAMrAMLAPLJAPLwDKwDCwDy8AyycAysAwsA8vAMrBMMrAMLAOrR2EV2aCeaYhmalI8XRB6j5g/5k24sZdmKTrgFhafvGgSsLn0K+hhWH8BtaCNRs/fwiFJp7ian8gr5PBbesD7IzSfU2damMMkFDC4B/pHgx0TPQzrBiLiyglEmCsxPjkAQg4SrCjnzbJA7UFkz/DWZGHPQcNrfgmOnIEIRawQgYwBzsHHFYBNXJVVVFFROexhWO+wx0DwhIuTwKuNMTUzNhaTlP0EEQKXAddSx9xUsoDvDP3fnwb+Xdie/00ud3N5kcszADTvV/iXEP0Ewkrvwvo2yMucMc5z7DEZ2sznQquhB+LA3meuwwsaVkEDfB70dEWwNYL6v98nUQjh29+EM6n2Nv+L6v/Ja78U8krvwvoeRD4SAI40JM1DxFOlGwPxX5NR+u2WPUthJXxgr5BlNTr6j309o5caYW5rVr+jB2HqxaB4uKcNvLwq+BwXxxKhbmbCAh9rEKzXgE/Ds0pPYChQblJYqpSBkhuElbk6wsoqOHi8Pbth42q1CfLmFdnDsN51BaqTC17MZiS8M4CmaqdAu63YmGKegoKGNZkjcZtg/VB0KowVmDPrK8hWbS77eEuy+jfBzh0w4D5qTuk9TaJab/8ZD9548AaWSQaWgWVgGVgGloFl0jrAumlgmWRgGVgGloFlYBlYJq0rrIYBde+S9cYVA8skA8vA6kZYiUF015JlmK0Z1lJUgYF1F9RuGVirpsBo4VphGRfeuA7rA2v1cCb5/wws4zoYNTSwPlmwAgNrzemqkSyTNgpWYGDdQzqV66Mvb51v7dbeZ1pLIUDU1nuv04uJWt/tnmbxcT9dUCvfTGPmocI6AWFpA2A1dr+aaXl5Hsz3IyipjkPay6L1Lc9OcfyUsHvly8alhwrrOQAuWcWTlQkGjK0bLB/egb8NmjF1J7gANwCXvgFQhCtvwN/iyp/CBwpiDZCjbM0WdAc+Dt8qwcfDTZiFD96k3T+mzkUfQhPO0vOc9eIThbnLMbwGyS6AL0HkP1hYeBciC9x/DLgqcVVYL1ge1MLdm9QQwC74Qji0RQ5cm/KyuTOjObV7WA7uCAfcaGgLwFQ+M5339p4CqCEst8RvPsMkKDm0KdrFwsGx2jNfkhCqV7Onp2Z25OMt+bggw2EhX+V5JXa9tV6w3liTyJ7BW2SMT3KIWUnU1xNWDWpSqxuXpF3Ig1+HOb0SSL1JCxP1rBrCAkc6NvUSaniCYIGs4RF0OycQVq0MewLIoCjVEBYateqbkEn4wLqp4doKvNfhlkBT8dXjMKRKIl5HWLJmWQSLskfYQoaSC9cQipWSkhbTsCwrU7O0ZNFavQ0L/xI7Ezqb8dSGnfl37GMOUUlGeDXGY8uzGa869wPr8l3n6lWY/rvdCReyIaoFvm6SVfdgTy0FUC8GGtY/SzhKVQbFaS5F8R8AWpIFrzSFPhYlK/J5iyXIEK5fh8M1eDUG4UGWN3eWJEkWqD+iPn+oCd59wLq7Cgaqy5liAq7nZkQyxoY8vn6S1TeRCbf06XKQQbR1dw2unUBY19w914f7UXTCQVttHQXIX8icP833FAstWDuO+UINuUiqscNWQ8PyxU1ywJV7M8U8Hz+KkpUMWtHmp+Qefn4ys+e/Ce5LDe+xWnRDqnEa87agGeAPVDpuMYBftXqQVSBA47pgX5NA76ZPiYcmlfbdldNd8DGtJnRAECT3abN65n2E3LfDxIZrTq+bQNrUOhhYBpaBZdIDgTXTY/7GPcBqnFvjFR5qhem5s4ePn6gYNbxjOnnmePpAjxtYdxCp489+3I7jCwbWKtURxw99Y8FcvHY5MLBWSh8cOtFB542rXVEadmfp9vqhUsfaS9/4+CGWhl3eWubMyU77VL9YMk7pSileJFVwxu8SP+vm7671Aslfv/GdB3OrZ59frJCrUD158RMiWZcORxtyp4t9z+TEKnbtSme1aTfDOjOzMa11jyyW55XlKiEfdfnxypL7DDfWGdaHNHJkvAGs/v0SV2tlySFWyRvL7Zk9ceSHXQSrqeOPjYC1xEv/oxUP1K/jG8u93qqfxVsrdw2sZqortwW2b1+cWWd2K+a5qYvI15ZRwdhfBvrDg3Xr5eVVpL6a1qyLoC2kf6FFe5l6iPV4nbkSrD9ZqylcaO506xttNvrm5kdmnS3d0/iQjVU0pr7SPmpKA40Xbt/xy/VwytZPspKXWgtaiuqFeWH61r1ZsbPLSmNTC8hHK530Pt3IkWV2nAy6CVbySmvhVzranZlrP/x6QG+Al69nWeVyv1geSCqvK8In+VnOIX2xu/yss522N6osRJlvtvKwTP3BKpFo9Ds/XOVX4lRO5pZqIxnx5VR0nRqrrBeseMGa48oVaFztWF/eZK3WXrFxZFnPNip0msXb4368i/iVDWO1DKx7Gqy30c54o5De2/zjpYLpw+VVZhUz8ury5V270GiucNrJ5bmcCKCLJGtB9BHabLlD0ChbybJaeHCVHCTesoL1l3fys/xouScQrZeXtwKsvFB3c5VXOrWxFHRs0De7rEO0Wln+h8vSaMyfcnOF7D/9teVOW7c6+uVh1RcaUK9Fgs92mqFX0JC8vdiDXOYa9bHVLry8YC1UNKwQqkfLNuI7tNG1DoNQ/9lpNRW9upZrvN1JrdEqlDqysIw/DadXu2BU+NYq1n1Fu/q+768ULG6szRqKR1k5VmwNDS4XAom4lY2T0FlafXPNMjDvFdVXs+6div3RAokAzfjZZU57eX7p6sbAagRx7CX/JlzD/AjlBZNAAjVzm8vYFrOr8Cfl+dJ+ddXwl3MqotIysPz5ULR5YlnrmNxoyeI3yxsmWX1jH8j+kDXu3F3i1snyQsCf0PIHpWWioOTi/1GO552rv7qinfQVHK3468sVkJ3a1D7xo/mY+tXy8g9Bi3184uSGuw6NtZSI85KfHGyV6GcWu+mFtILkoJ+U2hFOXb9wP5uGypdvu+SycxRFS8PlNjR8BI0z7bh09pDGktw8k37DjfjMiacLG2yzKM3c2TQm/3a+UPugkhqsJaqQZiM+OAN/Da1mCfUS5eT3gm+2Yacu7aVWgVeP7lQpc3FRoXh88UufSydOHC7pePTi8UNP73xpHSuGfu0eKtgW+RjtpQ8LaV1AvcPkzlv/2eO+JnmjkMoDukOzMEfR32tYVMY682cKkPzrGfL/my9A0vjOpcVS3rnyw1ZB8q3Vbu21QwdfWtbibwSsylpYzd9u/aWWG39iaQCiP/dp0fiAQDaR7/GT/4t27pOLeM53tDa9hAH3cVz4t0T4CIJuLBpbIlii+Xes9NGN3xv+A4E1u6Zw6mx5AUqiwUXBosoXjQe+/+PKgkqW20+iAc0y/PfNK8TxnN5SgMabq/v9JFJpPXpwp9fn9AS+HzwgyVpDWniHcibQJqcdWny4yMmJyr/z7UqrYqW+ILDvH16qZvEzHVu+vgKsE2sz11ScrLNg3ReshYzHheQcwUpSG5G0tTMqp7b5kN/yWX9vRad9VVdh0Y413l1pReFcV1hrvJ0F446lWVqv2erJ3Ag6A+x5Fzo6vLJFvu0316NvxAsbD6vZzuodGh39Tnrcv6GetR93+gmY8zTvukLz3t4i3rrvjNbvpzf0eqvhgu9568Q3FztDrarAhDJ86948wvsXrCYcD7oF1oeVZXRo8aP8BX3cWxOb+jp05U/Wva3pvcKi6tsPV5E28j7IRDf+7p4u/+I6CMWJoFtgvRzc0ct/ba1hwO3pg/UYI2L959+8R1iL3s0tX8cbe8E9d4o9uB5ZK3QJrGjxMHeey7al26njaJ5l8fPj54GDHiegPdqHXFCL+pVVfaBW5Wazfq5lBG9UqIVOa+XDdihGjkjjB+WW9M6mhupv2rL8fqM7YC3xjBVhSdIloGlX5dWEKiF4C5NsH7YgdeWVXrx21kpdlDsmUn0cpNP7c177OgtTesu9uUB0Xn64/RTixgO1WSv+2JJ83oAsSJWvuGKS66wmvH8Qc8JbFWISqmMghYTfLkGhPoxFXfy2D2N3EizIIuWMLmt5inx7q494C5bQK5EHyRwkidKVgc3511KFm90gWcnpBY9Vy/wbyXAyKj0JT7UkC/ggVVyx0ZxWV3lTXACel9fFuYQfkNAv46E9cPJOggUeYXH4SE6xlNFpad8GK1Dl7H6WjIwo9in8RdnXqsZGx6FrSsNFJgvc0bKEEJSGhdEwH6A73tlWQwnqDyogH0MPn09QVmM8fMVq2Pb85HiQ1XeF02gpLcma0teTn7Iy+gC91baBb0dwiSrQkCs32/PG1++1JN5gWF+n+1PwPo1oAtRUdpYP0UJGw0oCqSC8gPnKwzeAR6wiIJqRcH0lwW23GAr16ZwmOudtyWoVFBkgYUvVcFbwf2fXBd5ArYYfogUr2oAWy2uANXcHJ7x+kkwtikpySGfmOZBoCHAOAAACQUlEQVSv0Q03WwaeX4s8GflSxuIcjWgieP3EVQXfW+Fy78+3VSqnsPjNtmR9XsKCGtZasG7yTKH+ZREd0KOp1Nuw3tgA3+EuJGvFUXH/MpWsBkMbjtgm2VCBg7gZECzMkD0Io/0wMijhy9LhRbcymYtwz9fuIFipzcJLj54KOMoJFo14/TiFRV8H9dZDkyWeu+APnlcgG9tHm6Jls0oPR7IovbnaTrVsFLzyraZDnPAVnPcFeci04s7KbZU4+gIdnUC+Bb8qtOuG5HyJXeoCmxXcyZXQbtgdWy5dXiVIagV39+YwB+17qjxEWM3yGsvi42sJ+VeoYWx6d10JuaIv+HBdh0VtyFbsrBC9ACs3N7tjCL1eOSy021J2meuwjGDN3aOPk/jrdRcxdENseKcertpi3as/uH4ZnD3sPXxY/3gtdW73rAHr+QY5eTiwSndnLO4j0ChBN6d1t1kR3GODZ7ifE7sOVsttuUM10Qtpa4aeTOstWdQ65N6dwUpvwkpW1sL6Pfs3Nx8xySrArQqAUcM1Fmf/MxhYa0xvn4RHHtatDm/xDXhU011JVvIdeKSTGSDRwOoKWI03zhlYJhlY3QLrTw0sk+4b1nzfelip5ZqB1Zl+GbTqEgIDyyQDy8AysAwsA8vAMsnAMrAMLAPLwDKwTDKwDCwDy8AysAwskwwsA8vAMrAMLAPLJAPLwDKwDCwDy8AyycAysAwsA8vAMrBMMrAMLAPLwDKwDCyTDCwDy8AysAwsA8skA8vAenjp/wf4JD0v47Vi9AAAAABJRU5ErkJggg==";
Polymer({
	is: 'appl-diplom2',
	properties:{diplom2:{value:diplom2}}
});

	</script>
</dom-module>
<dom-module id="appl-promotion" assetpath="src/">
	<template>
		<style>
			:host {
				display: block;
				width: inherit;
			}
			:host > img {
				width: inherit;
				height: inherit;
			}
		</style>
		<img src="[[promotion]]" alt="">
	</template>

	<script>
var promotion = "data:image/jpg;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAM6BAMAAACvAyAKAAAAMFBMVEUMDAwZGRkoKCg3NzdHR0dXV1dnZ2d4eHiHh4eXl5enp6e4uLjIyMjY2Njo6Oj///9YHPLoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4QQGBiEQVILirgAAIABJREFUeNrtnQmAFNW1sLtHTf5sTlcPuCBMTfcgoMiU0wNqolLCgDEv0Q5bjMmL/UQRk7zYcQVNtJ87RkNHfSqu/TSauEQ7oFlcYkc0iXHrgCYaFYqZQVyZ6rrV+1LnP+dW9UzPMMCAOAxwD0x37X3rq3POPffWXVwgZNDiEggELAFLwBKwBCwBSyAQsAQsAUvAErAELIFAwBKwBCwBS8ASsAQCAUvAErAELAFLwBIIBCwBS8ASsAQsAUsgELAELAFLwBKwBCyBQMASsAQsAUvAErAEAgFLwBKwBCwBS8ASCASs3RtWOg6PC1iDFM/+OZ8iYA0S1gjmkQWswck99SCpApZw8ALWoCTQPDngj0Pb5HZ18pS5QQBr5sK52pSFt15zQXbh7YuviQKcddut5dsefuiJZUueegisp37zzpNPvOycPc3fAjpUurs3btSt7m5d7+7GdS7q7qhZN0j8JCkIJUlq4IshAJ8Hty6XpASuW756sDyuUddc7pN0Wtpnnk+aSEeuOgg6R6AfX+VCb36Z1NDqcrU1uSL8urZ790g+n1vySR6+9qzkdkvSSFxaLbm9euUXbncd7m+Ayj1uX8MaOqSy0uORJL8kAbwueb1+Hy79yud2e3GjAjfjpQ5I0nFXSJLX5/3yEMMyfBJ9deDfOW5PDL9aCYO0NwBz813gQ2XxufHuLVr30JLHpTir0+oBUi6EcVoIDI8XoClO55if5ac2hXFnA5TshFkuPK3JVU8ppc+sx4MH34P0ip6ezNNNezqIriTh0mu41EGpyVIs0uEkCeC3njHQ6dlvaGGl3PSkgdGiy/1F/FpB7KTPExcPj5VG4N/h/BYN3VkyXF/CDzeFn7jGPLg0i7biN4vxZ+AG59SUC+80Zf+Y5FLB4KosuQiOyx13ru9xFBL3cGz0xPz0WGAdXWwfSqJMj3ZE9SFLY1BV3fLQapbUA8vwuOi5reT3SrCa6NECELHDOTdGsNy4xOhIw+XYG5MQzcV0gTqADL/r/5Jizk7DvRd+OOlDWJbPnazC8nBYN/GlcPUeJNpDJxznqbdTZngIVoUu5tm7mm7PQfikehRtiDSLJ4QnzjA8BIJrlns0GaP3QPzMhrlmyWBCkcOSHQs13JqN0nThD0cczQJOycNhECyuWbkqLMXRV27HiIxgmbTHU4VFuzP84R3OsVXoh/CB6vRLhm0H/CF/gS7gDg2pZrnG9WgWtBKDZ2mx6Qv86XkcjhwWs3NAd9XwUpLXvgZz2T+c8rmdq1ZcrjE9P7BXb2CPmmVzcdmahfp3NyfpcVVhNaE+mYTINnjKVZmExpegRcNTNUPmpcfZ5JWHFJan1wyhw+UJclgdnlF0y263bmsaN8MqLNIsl5fuwXUg32S63A6XKixjXc8iOfie9KE+FThZt+2zPFFodLxZDyx39bEch3peUbn2j4Bygl9M6oElHUR5EhnjUPqsfXphZdxSI/dZnTwp6GwVJwg4HJ93E9hLuGGdB+8xjT5ujA3L5cCqJsBgvdxce/f8mBufRcp9UI+Dp9zQVo06qcfBIyw/X2pFzWK2Zo0Eg0cMRlMvrNE8IxoxtJr1mSqsdeQm3LCKFrlHgMuQSYXniMd5Gu+xnek09CSW5KIH3eSyXRPr0ayqv53IffkmsFxudbXnC9CjWZIU7+CaZUmoYz2w0rZ5H9ck2yVMyoR8Wl/NSnkm8ozIuxNyQ3JMKW5ISgdPxCj7Rr08XMCn7PmMHZChg/dKLtto8h6Pizxs1WcZ7qo61WP2Vl+FVWuGezW5PtcLC09322bocVc1y+dye+xfavVIHgeW5HFpNU6DbzuQ/6I0lLBYb+jQwV1ug61ZnwdHZexcn5ytz9Ysl/xnV519cofH7d6XkuyBKlv7oiFY5/qMc1c9GRghUjHc36sa2mJpILFKdnxWj2a5ZGZfZppHLruCHMyIiqTVPFq+NJprWsNO0izG2XHFNppGOSmPtdiw0Pg6bOPw1DM3vwfbpbtrzdCBZZAOuDfNDV10noscIY/gLY8n4fgsV01QqlR9Fv6mQT/EMFI3bDPssWkbliF5h1az9u6Js/CvJHHFNtwHOUGPbN9MwNMTOqABNZF/50XmDooumOOrWNUMzwU97XK8UG8c6URXh3v2dSIuHpQqjqfqgSUp0Ok4eBly3MG7R0AuYavpPj2wKIUdrv2GElbKNpfOakB1nFTHGXAzhOVut33LPswNGY8fKeJKcVVaa99/0o66uNN1YGHx1+uEpf0cPKL5LamaE2e5YhTMRnoi+I/JZ1H4S8EXaRaPswwXuvWkXTizHbzuBKU3SEMbZ9n5y5FVWMxbx7d+vm/kxPNALPAiTTSgMi+TdNr5k46hg8cJTm1fVlI43iqsfXo1iyxwHXn8qmYlnDjfY0fwsu3NENYrCIvyiGA1vIlDmh4H1yTcb/gP4k9FGUpYpq+uWv4zHK3gT9D2WcWm/R1YvCBNEeQ0KrE1UUGaw2J15FO8jhk633pNHJGq1SyKJ46j4MGG5XJR2YgCzxpYtkYq9ICUPtGH0fNoacnLwzXb7w8VLMtFUXpedkwR73QvboZfcOJpJ728+Axp2TZD1CeqOeEl3rre0KHq6FfZK9ImZthEsJokrj8Kzw2pbEiBp50bmgoVd+iyZdkxw5oM1U8XG8sfnePgs56RQ1ut/E3PaP7rdrUIPmfSjhuanODAF6ze5r60JtPN7MsLQgqWtglrfa8SVY3Waz8FWzFSNXEjmRijekW7QgNDUZU+E2DZcddp3CCrS03VOi5D2os7CFJT+iXL68RZHbx2cghhVdAb89ta0TSS63QA4EN3k7S0GgTYeabk9vnIU3X4XF6NAka31tHq1XOU+Gdddr3SN91Uywqd3BPlJTufbeop+KCGuPZ6ziUFKdN1NZL5ej675nnKFRDzXhu7ye5Kbo+3u9Tq5tUTjg+4zCNFYSVVj1zWJIWh7ENYv5AkfbX3k7yb3L4XFh8/3Gc1U7uS7n+wXruYo2SDpevWRtze3a13b0SQL7/zIuJ4em33W2hkD72y8eU/2sfnfvDSy0/c9ihddfGdTz0wM/v965+8ZuGiJYshc8rtD119xvEXLgqbx//stgvbZ8xbECrNWPTA+e103owZV18wo6198knQNnfm3On+5rY2CEyZN7dtggZDDku83REiYAlYApaAJWAJWEIELAFLwBKwBCwBS4iAJWAJWFVZsuTbDwhYgxHrCI2+MgcnBKytidnDqFMVsLYs6UTFz5tKdAIUVQFrS8Luhh8Cg6wMU2NdWjEmYG3BX1GrZvtd2iT6SgtYm5dTrR5YMnwXP/8mYG3WCKnVTelb/DXoa8DbpioC1mZEgUIQIGRb5EcIL8gbvAtYAwg1bm/srNlw4lswvFRrGMFSdAAjWrNB/ZslMwFrwBCLmvP1lefQ12sC1gCy1Lgr2W9TqrFPsxIBq0eC4O/fmbXaIFrA2iRuAOPegTZHBKxNhDp1ablbn3rypUdeXnPnxo1robtbg/QXIC5gbSKq06C30++R6twz3f+zbOEVYRjb0/FQwKoRPRTltjjNJ0kKa/uPhxLUoj0MkBWwNvFNacr3GKT9/tbxAIHxFy4BQgUVPSlg9ZNSmtrlmnCG3+vFMo+53/cXRYAi1I5hNN7D8Akdig3IKDvD7+WN/CefvOB8XkysB6FZmxaiuTF6PdNHcjhM8vrUMHf5JQGrf2ZoR6Feye9Y3ewADeICHQ2vMgGrf2bIPzv9vrHOBtM7zZeghfcyAla/kDRjD/Pg8VW71EOr5OsNVwWs2iqHbN7SqHsN75Ob452ZpCYYZjJMYLGUfwF9uamXlLXkYto2y9PHRAWsqphAHTkhw3tlvv3gNchMZwTL8n2C/oG7q2Y5oSlFEJWHfn3rJFqzO4nryYiA1V+zesKt8888f6yXAoiPSLNAT8QFrP6w+BtVGReb584O8EGvLnV2JgSs/rCYE5vOmDdv9lje+bP6ZkcTsPrBys2n71d5fdZoX/vYM4fhiInDBVamwS4SwvRWSYqwuUcsieUoZGCagNVfqoVl9p4v4J8E5dYp5/0nt0vL15AVsPpJtZQzarqHIob0dx560u6HrTBTwOonitPIYdSMw7lf/87PnuJjaNyrlYsC1iawgtwUNwSa+Xrx9idlHpIasvBZm3otk7fLMkY4AcNtv+hvoQJWT3bIDD6klFUdCqxwe3VXTMDqD6voDPLYUt0yjMxv2JlhVX94+4ZgdZQWBYZTe7ZhA4sqsiK2Rln+cY6GMWfUQAGrr+QRDfftnbDa5w8avPRsrOgeTm3/hg2sApRtd2WNWnLWnDanXBgyK0KzBhC12pzUWPTABT1jiXYXBKwBpBv/nuJL3rnHRXsyREXAGkDKROYUWqp4HCM8mbsyAWsA0SAjG32DrwQ8ImANKGnoKBzYu0o1NC2WJmBtxsWz2l5zjGohhlNb5eEFKw03OiqVsHvuQFrA2qyw6mfj46hih00cbrXww6tzJofThaGWhSo1GT4UBemt0NKnAmQepIa3naLWYcuiQKFBBbUhA/A8CFhbFuvbzkLlMBCwtirFtp8kP3xwHICAtUuLgCVgCVgCloAlYAkRsAQsAUvAErAELCECloAlYAlYAhbA5c3N/uYILpT8PdvOm/GtQPPB7fZKelFNw9rCw07Pr0RtR51ZI3gnxB5Z291tUfMR+J6zobvfj76yq2rWZZKS8ynV6e5tmeYJWfdW2/JVZ9fj4sxLaHjN3omLO2R3yKP4eg+zPE03ezw0X6jz7tXgU9j1CPPquygsw6PiXxJYTU9UoynszPvYy8chV88bj6YkRrP12c2M3ARLbqo5bJoEFc++kPI6g92lPcE+P+kN7bKwFCi7RgN8p3dbiuY5ZpuD1QxQCcF/Aw2Ayw9Q6IVrusZap7lpTlEoVy073Vezil7YZWEhmH5zNhuuCOiZgcyQZgbumVv0z3xP2bNJO7ZWN03t27ueloa2Q8GnB4umG5Xc8K3FuDLfnoE9JUX4G/qutiTn86d3Eq92w5q1Oq20etFfv/81VC/JgVVfc7mEY4bQ5MyqWdYIFv5Ghfe9+2PVXVm7JCyag/5/XPEU+qyVSgfXEsMdJn/UEU7VcTNMKZBy64ZLBane9LgD0BG5oQGzgTrqv+NzubXD3bAK/ZSrfpq3Cst3AF46Cav2/T8ZMu4gGF9cgWx90Rt8kwwpDuYoX3LXg5UiM1wlBQ23jj9ijLEBxmi+X59mIkGaeZ0sE29ZBVc9/BeaoYQ8qwZadsmwzo1+DjfsK3F9avVAB2audEmPZtahgw9BXThdh7kIGJ8D5kqCX/sUe0Z9qrkh/MOjMEmnW+FTAa9zjyUTa5JJJdDKZJoOWU+j23cjrAbkoxgebpMoFYSFKFNubs38ZX6ry0/zoBseDTPNipTM1IXyHt1yxw0PMPzv1bL4UyN3VViuIPPpzP32KpetWeEMArohztBGm+oNjcPK4gqCOWcv1LkEggB7IuAKOvgOhOUhzbKveZybZkgmMyQFdMtpT9jWRCRKsDy03ajbBWHRbNn/hTog6SnPOy9vtGFFeQxVkDDPd+0rcc0CR81Oo9yw5HHpNWaIEAz0Uy7H1U/D1N4jxTHO7eCMCBbtllPcfgmW5Je8uyisJnzc5MF7nD538GUpjWrnqvPsRQqoZ9FnIaz/2ov2GAjLZlNxczOkk6v5Io1OY7hk1L51EuUQGU+IglhJSSPUvdBzJQ3PLhk6MHLwnhEEi3kSDqw6HhdNkzPopjx403EqumQxAEAt+jHCapVrfJbb1qxaWC4CLhsujRQKNUsK2QvQMQmVlmC59V0RloEIingb3MHL9mijhidqh6MEq6m+RLojgem2Hfze6KZiPPOsr5oh2hY5+CqsaT2ahaeV3cG0K4yZh4Vq2kXhFWvSGC5buyAsNK4UzTjv1SiQv9XeFuIeC3WjBUMr2p52xSnWR6q/bQAT93hexRWraoZuDNWAUNoRPKqR302hQ7kJMogZzVrSCxIUuZcz3clC3Wc/xdGYPzVYPk/DNOrC2+lWoFPic9tDk4tnaz73z91fIBPtQL/mkZpRhVwHIYJAWZLucTVCUwPdu4kAMy73Orduub7kXNOtkpZSvNsqpxpxQYHLFAPPdd2yKMmVOeDzKrserD7yEa+u6taBWiFDLgl/1SprNibXrHkb2LGVdx4uPv1kEqbFYUUQWjXI8A74x190BsBpSn7uKc8vmsFrF2acefq8yXilye2TwfL6aYr7drB8fh3zVA9msG2+yZCXpoia0q2IR3J55E/9V3YPWGksqHc0CliDy00w4ygIzRpkULcfujcQsAYn+bajdAFrWImAJWAJWAKWgCVgCRGwBCwBa7jDsgQhoVkCloAlYAlYApYQAUvAErAELAFLwNopsoE+wqaANRj5Kn3EmIA1GHmQfxoARQFrc5L/fTlZPgSi6hOwPgSqkUmuekbA2pzIEA4yZUT8BdA6S4qhyUyMU7pZOT0PI9qVeniQjW2zgga0GMIMNyvMtEe+fZN8uypgbVHMBJIKyfBvmk5NYdCSErC25LRO+6UuwwIY+XhFMWASe0PA2qzoYNk9y/OavSEqYInijoAlRMASsAQsAUvAErCECFgCloAlYAlYApYQAUvAErAELAFLwBIiYAlYApaAtXm5MVI6QMAapLDhNdn98IZlCFjbpFn1oB5y42rfNL93loC1Zc06Y6achg4zkVNANgSsrfosRuPoF4MC1iBgESMG+ZCANQgHX5+RTaZnhGZtTazJwXQbzFbnq+ZX0uPnqwKWiOAFLCECloAlYAlYApaAJUTAGv6wprX5pGZf0D9mK8flWiW//6QtHtI2u2alcvB+ux+so2j2IDOYGgBWpM9aygWWa4vVpYa7ZuU4xbf7wVIh1UQ9Lvfd9N77dv0yamb4GFiYVLMiqbuhGUb53EzRjk1hNcU3gdX0+cHDUnZDWI71GI2XefF2mxvB8CV9yRtaFcMtKRVvPQTaWJ1jhtD0JXRyeFzFP+KWcMW73zId/Aq0zTMbAEx/J17oci9NAGJNuNI9YveERQrR4d7oSoAbfDpIK6XI/qCAKwbLdR+k3N+gudi4ZrlkYLI5Gn4sGweHv6l27K8b0Wl4gfF4hE89TYLMmMyBuL7K2+1p3C1hpbhmjQGPgip0gwySXDLdgNASIEGHiv6fm5RRt4amDfufessLUtj4HHgg9SU6QsELNMkVPtdaB55O010dDW5l99UsdPCSwvaGVTK4QmB5DkRvHit6rFX1qTrgM/sa7i5ULJryyqN7Ykad5aaZoTzQUY923CozggQ+PD3BL+hTd2NYjagLqb3h2TGkUdCEyiTFmWvNO1pqLweWBzz7cViuuCdkfIY064ulpqvPjCKsw2WawdBLsNwqd4Ke3RQW3VuqEc3Q2Af+IYMnCVBw43qCUSqMveyJDVP2bJkeBdxJox7trUNdrhSb6AiEROqF1BGrR+UZgn831qzUvgSrDi5D1UhCHlIjwB0vuWO4u8GGhQ4+h0FpU73lAWu/pQDWlDDaa6gKywXMzTWLz9u324YOLtsMJQVdd5MKTRqUEsUxCIvmESXbdMmOAjaNgJRcdMM6Om85D6caQeHmV3LrNE+mjNfgE4pKu6dmTZOwXOPzVtAb3XDXWEijKVXGMZkm7utwN8A/vPak5R00r6EUrYxO1UPTwQswq/zqhTTDnAQICY9o2k9yRysHIXU+TaZn99SsWumuLjyDkacG8HbtcEb2UOH579Fc0h5XssntQWW7JQHdVnd3N1S+nkFnl/sKwJruJFRefVlU0TiW6/W6lHXNPk9M1GdtVb6IvKZiadLQBaytChaKfBiqW80gYG1VrCsPQZ8248sgYO1yImAJWAKWgCVgbSpXbHbPayH+ZU6klxq29Bb3igCZBA1vV4r12Q5Ub5/lSz8E2j8kg+UOFazNDpRcSQT4fh2Unv4Ccs/eDixrd4E3EJ10LlTfmRk6C0ICeANUgHdNjXc0YHsCrLy96zn6LzvKI9ecZoCRgQpqXrTmUnLvNb9BH4pDbpeHlX2tDeYpbLkMRyj5Q5SuccXRGJAXA3qnqZymVxVkEn3LuYv2h9dUqB8Pma+AyhEYpHSIJYe6FKmUgk7/nhDMpQbgQetQPRfC9Q2duwWsTlAMOMCAAGmJDFEGMqM7VhiM54b3nqNMuCMGciZpQD0LKSzZGCdYLIqw0jZSmamv4dKj92hltUyXUQ04hi5fn4XdA1YH3ZWOKkI6Ihce3chhgSkbcBiHFXJgGTCC969gCcWSx10Qrre1zns4d+drOCyd9ygwFSs4d6bCrLFzIodZI6ZH8Yq7h8/K3q93cnvisLJhBGJShxOFYMm0RHIoQWhWCGQmIUOjbDsmxlWTPFkSOEmDAzzAIhtlBdw4KY9uH6+1e8DK0O2VDOiipy9bcrV3Dn4eQ5oVhphN5esgT8KtSToqJENYdvyZQu/+K9yPO5oFY6zgmdzJQawFr5hQjN3EwRu+/S2/wjQVGr9XbIRZIwr1hgbs6pGdMKKiQMbv1UdhBKGYIUth8UPIpJDjadOqmpXiyuf303jehkZKmmBKWTEORUK+1TASfCtRV5VVu8V07lFyz9svFeevX92NXTNtadWPd6zdQrMm9Va4i+LO1qT4VVE2FAVpIQKWgCVgCVgCloAlZPjAsgQsoVlCBCwBS8ASsAQsAUuIgCVgCVgCloAlYAkRsAQsAUvAErAELCECloAlYAlYApaAJWS4wrqxZ+kwaHOWVvBPQ8DqLz29I5judLgYmi5xuyKsDR1Q1IC6EK7m61pJB6sDnPbvFep7aQlYtuT0m0A7o0NdADCB4DSo8krqjYNKJi8vj3pdzZqKulHAcvwSY0/cwHvfHAIwHRQIGoUomqGxcZ8UTAJ50kZZqQhYXFYB4329EE8zwEqQoavDoB5NvDNZCygKwCxFwHI0yzDAqvaOI1iKwUKkWZDjsFrwIL+AZed7EZZXGIfFFLgX5JLcWZANHYxEJQWNoJBlMgHLlvYCrIg8FFsWBcgEYtkl0Mbgnssxf/TrbcfPXD8j1wAHqwKWiOAFLCECloAlYAlYApaAJWQ7YJWue+q2u/lSru1SgMra7o1gdXdbljMegXVmsvbwS/ZszWLu0L1eKv4eQMOUA/MGAVqDxqgO6UezFDCbYZoC0OG5czoNqd1gtcp0jm9C6ygELe09x98Iy+um+PjEQmnfAVhwHg12tShr8kteqbFL8mtW60Gve7w+SQPmaagE/BMh4/+rJJ0N9zYfmICSv/UluGlyc8DbkvUHAFb7gzCtNYgFopLPq6Sz7YGx6YB/MtjD3KQD7f7myebkGTPb2oNzj5/bPjlkfvW7AHPPGAJYaSnMR9eWIlDxaPbI2Y2YLOZJYHnXo4CF98ing1HAUKBEsHJuhVb5eO8teKS9hNdwa1BMEPkQwoqDVA+T+C6E52mEDjemrx5Mn0ID0jR5ISfT9aYBlrYpDVYLGDSFRSMwFRiuY5rSI/i483yoeLsGP+UDeNaIF71KhebNgIwMN2ASLWUIYGURluG3576RVEyVbtcIMFcCoowmE2iSOcLWz8GfFXsq+yIypNkD6uqpz2HKrUMTVbtAK4Kp0BgyrTYgF67yQeHxLpv2BebMwIPAQIXD9yP4eD2JH+uTachvw70XQBBWxWlQJINmlZlhw+KTPvn5BCK4WmRQlGiEMnrMlGiZzvr0YeWkEP3+KrKy4/an0f/Lim2emOAOQth0IE/rNxvg/w6wh3IiWMwTA289xC2aKACOG0XnKJJkw/J8gY+G5KlHloSGNGtfyLrisA4TKO1LYyG2IqzRNASNm1fJo7olK2D82RXC2z6c4yR+kOY/nuKaZc+2Qk4jA0U3VVyQ2uqQ93mdYbuGQLOYJ9SKTxR+6yHN+k/bPN1oT02UsP+r40/T9yVMsj0zWNmrQJamO5Fp+Ce6GX5fIBsuxUJY6T/bczRx45RsLUPNMtBKUy5UQ4k2HL4P6iQd4OEHe2V6DkYeSarwf2hXUOZsKvzHU5QQkyfSqOOqX+Lzj0kyvfrIG0hOHQpYniCkPYpnf6AZh9AcO+xpzkz0WeAbC1y9jCZ0aOjuXfzuoIRfFSThqUfHxGdOs32WYrn+H2mWwehmHVgexwwbueWWkMCfXfAR16yMi1zUNPdIbmJmgg70SagjhsubBNOZzoI8BJ+xgdlTjEhAb4pKniC/ODn9vCXtPzRm6AmhFime/2fDMjytfOYJTCqm3Uu53DrUN7eP3/izbneo+lQRmGcvicbxc7f5bI1TYbnUjbCeqdjX4FMsVM1wn3NdUe4BWcYVwh3HfYY44a/kPG483dcgJelA5pLxJzxudKMuW1kMT6Dtm4QpyHykfO5ziVyJo/TtRypXxBxZV4fIDNOSyjN/guXSpZEclitJd4BLqzyYbovPRwGzOTMyEFImV302TlnBx7ZiIay01KiTb7Zh8c+mep7nexr/h6fN83kTNVLhZohrri8BdDahbUqywWGBtDfqSF5yKYZkuyHu4OlcpUKJQPXigDy2z1rFYaEWDoXPwseMzy65nBLw430oZYZb58qPmnUD3+olH96KSUYHFSB8ZbSePAJy10OU34jH78BCB4Tuemp30149sCQbVtO+Bjecda4YNKFSwbR9ODvSEnR15Lz5aJP4xGT02TnX51id0gsL/0o6uBs5LPJZZa53Uj2NlFvA63iHRrNCYE8UxN00zZLDlYi54s5kehQ6uHQDzTWMt13naBZDpPwGdeLrijuw8Ei8Y93OvTgsMkOD54auRv4QZPgHGdXhn4EyPiuJxgYO1JNVxznVAp6FlFLNFa/c67Pob8G3j6vjU5SZ3G8GndzDoqGFmXuofNaPMQD0okuWoghDJx/rhA5lj87zKcquUUPuw5R9kcNSacImDsOElKfHwZOq0CC4VC6ownKCUszl/uzm/k6nmYy4GZKGSHyUTh5r+LS5AAAgAElEQVReYkBBYefhHFZmFGWgPbDw1I+gJoqoahZPQYkedHhIInil7EUkqxHJfvQIsUxCeR6T6FF9UwbTDTxU/a0blofBVHhOpPDZ4iipz3Jl+qZUhfVn3WYm2+EAwD+Q6lQ89kuQ5rk9TYdI2w/fGwx8QPsCBlspnWIy6OT4MFRtpXFP7YjqGFurvHzozjxewZmUtMxnYPPjxi4yQ7hxCGAV2toCR/Kl0/zoeLKtreNgtiSFS9N93M8HZviTYLW6D8UC4Zifzb+IO6fVkpuKLDm/z49aeJqEUQHlTWWax4PpaTzRcnvJHVImmfYcdFkCdc/r5Bf/AXbRxOciBJ0Y2irW56Ei1ekrMCjQOfPAQbAcl3zj9XOS6FET0OnWCmRx6LQ6JD7OpElPy8LAr3MC3ETrQ+Hgh0Ce6hlFs7qgVTf8jZZKP8RA3rKosmPjWr45XJnBneDjx+tQXrvxpfLTG99++qkEvLzmnbdeevlJ2nXHKy/G4eGXnrr2tnjh2rvoHFGfJSr/BCwBS8ASImAJWAKWgCVgbZ9UdAFr0KIYCtvim6lyUsByhGkGf8G1ud1AbxsFLFsMYPUgfdzOEtQogMGKUFo9GbfPDR4GmQkgzaj2UxGwaFZtox58UckXwRXJ3600sr2ocoY1+kDuTF4Gw6V32HCA5aPaPV/E4yTICPpNmWuc3AqHdATvoUVNwLKllcywCZmReCGlQppmc4KUgnvWhTishIBly2WkWXXk4qkGn1ZQsyxbsz6bCt4AvCOigOU4eGNfRvkh1bVLUPY+gprWSrB8lr9V/se7viGZNm0XCR16oqgaz1Q7E2YJpghYPUHpDjhij4GV/sQHiIK0KBsKWAKWEAFLwBKwBCwBS8ASImAJWAKWgCVgCVjDXSwBS2iWgCVgCRGwBCwBS8ASsAQsIQKWgCVgCVgC1sCi4p+l9t9q9tm/iWylEeTG3RWW0vMxMKyBmqVZ8uavx76hML3npMuu3OT8xk3PMTuBxh/bNTQL5G08aYvH64yGcnDQUVvTWklvVruV4QtLDQCbDOZ4UPyQWShb7fBBp3Y67lgfLL8ex3t6dSWuZIIQKpVC8Fq8WI5m0PjKp0LhY7hetizerlR7FIpxKL9ELUrLGq5XANYiIQUqYJGxGryvRaVquzrMhQGqTBuHOayji4pigMJANvUgyN0gXwFfSkchB51M1fAm/RVMfRT3G9Ef5mFuKhYg41IyoXO7aKN6FNMYHMRANZJyuqQdBdHVRqI1JBuWYpiqCS2rgwpplp8draisPMq4ZhUohn56UYHQucWGTl1500ikQT39nvOnjtaVE2Dk8vz+jUtZfuRjww6Wgv9W0ABeciEpg3zUosi/QSmpwObNNfnQTS1oa2zsHJAZrGczmlPQSe5LBuU1OJXmQuliCYRt4v5kY4kBMxfOzyO+SUUkCW3GIq8BJ+F12mN5Na2xiFxRDMxH5P+lcw1dzkXlUlHJma+syoTwtyKdtF2BqZ2qnE4ON1h41xtYNzoLpZBAWOiE3gelrFKnmxpYdKABJk3AAF3Ax4aUnyfQDDpY0tZMAzqVYvwdPLag0eQoLYjXWE9nnMp7iBVCTC8qBCurgnI/qiKkVTkfOScEchL3Z2N4QXOFDStEypsYhpolk28JK0WEpXwL4E2Qywq1cbeHm2vBnVnSJQZpA7IMnQ/XLPk5mEA31kmw0IYLMer5dILGNMjjvR+Gt5yiGUHyhgMrH2ThkqogrAKe/UsOKyHnItAMXwvi/kwYFEvp5ODpJ5RsfLjBaikpB9+YPG06WlL4nA9GG0eq52IyMa0Hn0FD5DCYSFne2NUEa3VxzB0GGi3uHWWFViDJMQasLCmtqFb6AU/j7Wcu0a0xLI2GeUiHJRvFfxnKWtsMAXKIAh8LwsIrqvfhD6q4mo1oNGVIUTazEWjJhFcTRAVGQUJJDzvN6hNdapSHOVKu3V1IgN4N3fCG1q11r8Fj8ifCy7p1kvpy8mVtfLr4wlPJox9T2lXr4en6avXNuxcuW2YqLQuZAv7EwosWAnwrBLkL0U7T8zIz5waNeWAunAOz1fTk+046KkjR3D3KL0/KNUeau1478oqTDwZ2cO7IrpZhCusTi6URcLbVoF6UDUlGrKQRII+9ShSkRUFawBIiYAlYexCsfP8aLxhorPakgFUTta50Vjsw5BygOjUoYNUoVXWYC/weUbuT9dQo7uGwCnnVjFq6FwtvN62GrkgxDZCicnTUOhHWa3A1ZD+YBrlwthGicAtYEN+DYRnxFbx+i5RregZmG8dwWCmQKxboOpaPV3QZVGmjlHnlTfC8PRgWoxpjDouqaOa0GbbZpXCjDjKsaKOqLNBTVNdyNdxj7OzJRneuZhEsk2A9Cx32/LWkWaugvuSGc5Rj+Rjf0EV1Lco4qtRie7Rm8fq+d2mp04Aysx38oSDrRhjGrKQRtk3SPYR1Oerezh7saOdqVrIDGo2koQNTAu+M/wGNOLMOViVA6S49A6+mjlVWgmHJ94CyFh2XyvTOPRiWIzSW/SsAxZ4qLKu7fDb8XoNF0K2X4rfm4D2rG2ZAt7ZGE8UdUdwRsAQsIQKWgCVgCVgCloAlRMASsAQsAUvAErCECFgCloC1Z8EKjPPXtAEt+bdytNNTJLt4mZ69sHZPrma5feC2ILnIrg7LkMu1gDYDK2R/sUnVbjUekPiE2D1yQy8J1vuSsE9b3Em9Fw+VR1V/fzxMU+BDWpwOq2MA02TndH04wgK/1rvqG/Cgakc5o6cLkgcOj/Q5tqYd+P/1LtZ2War0ttO2VGuis5jlkzkkaPEcvQO/V3nt5ibFxLCE5VNyAWhWWMI4iqY7CYCp+nX6Q02YlngtOF3vaEa9Wa7AcfvhjU4nI5NgWkSC7Ilwe+IH8HDie/AIvAQRKH5tDcAvEK2lr4W3wNhXp+ZZlm6hmhTGAO9AZgF0KNZoy+kT5gPjs3Zbm8uBYGkelWvWquSwhHWcPM1SUkqa3pr6wF+R2SgmZz5jNKYUlhzN9jcU0ihTNnQ8GFYVxnBYZIayEUkd9qxuNDbBKm15I26kIwy3AtO0dCYUMurh4BT4Jo2Y3cJhjTVU40AJYcnWXshe/hbBipYk0LNRL5wLHcnXQev4AnUHSsz60TCEVQ/T6gmQDKV9mSLB3tBgyqXPZ3GLoXTqkqkY9SlCIKdkgraydADBukNHWI0pFTdHU/I5sE5bpUswIkdTjTe56BmYo9DAyvWG6gevhSpZasw04jVpqhlDtQ4yZEPuANKyoGQCU3xcs8KglaROaMjI92jD1AzxYVvjlCw+fqnyWfCa9dY+2Xq8G+UyDcx6ptDcJ6hfHBZ8ncPCvzoo/DiIG2Mp5RfQoXXoHqhLk3ezJDwjzD/Nhjkqbrb2JlhGvSkTd0gRrPrU3jR1t9EYOm4mzRsPl0HHLxEWtHqhoV3+xTA0Q0y8xG/do1sjyHF/FvZjcmVMjjRL7giidqTqybiYA8uoECw3zzlHG0FDQc2q/zGs0ldr6H5WadQuEtVHSkLqS0zJfI68kpcujYqL1+SwDMX6ImkW9/sSPTBLCcAN0Hl6I8JiDZQpD0fN6lBMGZYfpMBpSOoHeL+HF2Q2ElUCbc+Q2f5vEDNDTkCu3uC5YdP6vYBPaw/e/BfXoTszwgaa4SptlSbB2XTJ7wALIyETDmL1lgfUHljQyOq5ciKsg/C6Y3gn4L3xOeD/VoS1Lu6nrlZefBb6ZcMPVumOZRjbWMfzNh7m1Oy8ULYNTHzMr7eff/zcL4Mv1tU2Z5xFEdL0Rph/GNJVaa57vwoFSfd3Ks82zpJnKx41oPjUuoSnLYiRa+g1gBsh3aKgbZ3mBb/uS+M55gg4jTIDisS8xRG44BllhxeVJBjew5XW5LOhy+WJFKg9K4WNtl2juMO2u0f3byX3nlY2ZPXbe2Y1+obR6p4Ca3379p457XFHKb2i1kFU0QhYQgQsAUvAErAELAFLiIAlYAlYApaAJWAJEbAELAFLwBKwBCwhApaAJWAJWAKWgCVkh8LSBawhlZ6Ri17r3TanfXLvkIk9MlXAGkjKSt+29CHYzDwoAhaHZdQ0nbXCADt7VLadCUuT2ftKJzSDHIBLrkAUnYm29GHT4P1z0vvLUFYho7TBXfL02cqNMMEYwW4Eb1CF8S0Vxb/HwUon4QFoN7VOSBoQNwAiINPMKHqQhWUgWGW5MwexDtifwVnZ8PoKzUqRBZoTJLHHaZYfWqADlGllMDIa8DmdaGRJPcwXKyrkZQYHggmXGbAwF4FOhKUyYBE5E93jYJXkcUTnw/vByAZtWFyz+IwppFmG1gUmattKrlnMUvgUHibCiuxxZghKBzwN9yIZtKwKwGUQ7IJ6pjVCwoY1C5hJpnmiAUdmw0dXuGYlke+ep1lmi1o4KgxFDApmab+lVut+CLw9hinPeguH4VrD7ATMNxNKh66a/mlrvKt/cqAROhha3rVaTFmEDpuBKiL4wYshYA1eAhEBSxSkBSwhAtawg5WGcE3BeXNH0cyqloB1Wc2ADKVNZjdhMf71MaOuwLiQdXrcsf0C/Htpq6LOhoGnUrYP7LNWUXZtWFsevL1oT96hgOrMy+sE5hnVXqqHRHhboiyVf5Z3UVh/WQUx+F9w6unDlbvgbR2eAqtIo1hUtFJcoymO5YrMRxLRod4+NB2EUVV22w7rnV0TFoPpFT5LK024mmNq1MDCc7GijOtW+LQnxe/dA2oLNFr1lnIOvMKgYTVcgnTSCsILTSx/MfOMnPpjo6kwy2vASjZ2NpzagUROmnRZhz8SgKmzILcagkr2d0qARgKaGtDYyqI/uEvC6qTqqtUzDkVYZjBaCLaBGYK2gHwHyDdTka8YQzJ/QJiyRfPyWiCn4wdermARe2XQeOoGXCXK6/lEMgzsiYDRTZndq5hOZ6gGtKQPi6IuyTQ5K9lzOK3/966pWacjLvlaWvpdRQ4Vg2wU+DTUgN/gbR/CyGcZcN9fabpfPh8tECxyXmkV/Iz7rFtkmj/ZhsSnTJZNbpn4qXTxukLqGMxntVXtiawD+vW7JqwVqFnyKpqXnSWOhYKqrwNLaQS4HTF0GAkoxVk58QbCqrf4JMaanI7JNqxZ5KuQkJwiWNZYncPCj7OqsILKSNqE2YF8CtjTd6OKfpDRL9lFfZY6C2+wBZ+5GWOQUxWDbjipfAfqFRPGmPm4YSbm0T3SJMcjCqCkow1WAlgQGhnqEG6sN2hmblQzpp1jz6FNLs2kDTAasR0Ed8DtHaA7sBTZ1H+0a8KC6y3ohguAxmwqQWXN+cHsZLCmWC99+OB5x0Bn8P07zwpPMLOLYrOzJ8wNspb0jH8eY44DmNM2hcZuM8emJ/pnK/6b9mMBH/g7Xx9/her3IxS/skJBWGG4MWZ4S4palCKtH48Dq7l42OXjFENVdklYO0qSkLUXLN0eTkyUDTcvp+lL7YVcSzkpYG1F/tRTZtrJiiVqHQQsAUvAErD6y0MvPUNTFZI8s3aTvW/1LlIxOL/16+m7MywzaO1njycKTA9sHlZJhsG0wyrLfVaV3QtWNkKzhzo1N0b/qpxesar3vZUX0f3xRHYnWOkIFhW7gLXYsKYqmYnwbqc+BwoTwKdlUfMg8VfI3IywLsB4/a/6DXRWEQvhD9Pg1JaV7GODCRkLUo6mkklmIruZZpXkTohQlYG+HMZEFDMYsEaZkKCaqSlUN9WQ1hTTUpglrwII81lYfxFRGByah0M71GMAmi2Z9pcOmmSWZbOijLtTgcJhq55fnpOL4d0MVlFm7PgFAEa3XfUkPw5yKVpPlQpXMj0bUix1NJrh/DbFqCg0OTLtQVj7sjafAY9R3Ux91p7LVgb5+AuVJ3iNX0llIJdju5UZhoGFTVZ1UTLikO+jm1Sg0YCrTN1SZCtoyJai0BE+lapjZMTDqGYGOT2Hm62jwa6nwV142AMES6bJuJXdDFYEOsFIK+hgDOjVrEpUBiUFVxkRKyxbKtxgKZMJFtmmzGv/YAEqmZWC1ZgF/pKpYO8AGZ3f37lmlYlrObo7wTLlLgVx1Z2OKOL04mZCMdkGclZ9DG/fmsMZWIqKDstYqhh5dG6VkxnVI6d+oxmN/zTgXtJHlkRt0xUa57tDV2/hmlUkXSvvVj6rGhn0LsWdhR8BVbtkwla31f1cyOqGI2HNmtO1UsiMJ15++GX2xjfh3OSv775dA1ArAPPZ+0vAnKpU/NaF918I2QWZhTNnzoPxoriDshQKomw4WFl+tCpgiYK0gCVEwBKwBCwBS8ASsIQIWAKWgCVgCVgClhABS8Da42BJAtbgpf/0YEsFrIGkUgZLs2HRa6CX+MZ8o4A1kNQzaOyEullyrhFt0YiO0+pMmX0uIWANIP50VjbAm64v1RUBZoGPJrLlU9kKWJuIp97YZ26yLlNfItP7M7ihLiNnBKwBxXTT7NCoTbxhnxmShWZtXvTlRfTudWZ9lqbcpgYkklFv7itgDSQHzgTfOEsyRrEGgnXw98DnH21JYQFrq2K4XDERlA5S5sFOHNtvh8P6lNuidzzaDkKzREFawBIiYO2SsEqD6cOb7h0cOEudfjL6ngnr+UEdVTN4t4c+jt0zYQ2u1Oftx83YI2FhEVmaJbcqsN9ISHV6jRYpXvERwOmNhnyDwmRviUDVwekjIXB3A2TGSWAeCUZwT4RlICyoKzYaqgTuSr35WUMxSI9M2ZuWDdk4sEP+BWlWBr86Ej6YhYc3pBJM2SNhqeCGBquRqR6os75oyka9obsBUsrvTYJVn5KNOIA/qyzXUwkvovLCRENJ76mwJNi73AgTPNCaUUw5pUCjl2tcut4gXPK6JPmszuWoWRIe3JT9IrfePRAWUxFEQ6XRqPcAWwRmI6s3tFYyQ/yf4rBSWJR2W/WrdCPhx4OlcgPfvQfCMslneUujjElSknq47mvIz37XmwDTv74y6bfcDNfF0MEbjYcnGfo1P+aGHk1leyQskKlzE/5LFMHn8pafevrvheSTuH19An5d+v2SZRctvTYK2UV6C9OL6i3hvHqMnj4aDH2PhPXl3sX7XvYN2nr3zKDUrI1PB81A3jNh1Yh1lyhIi1oHAUuIgCVgCVgCloAlYAkRsAQsAUvAErA+NckJWIOXgwWswcsZ/dbpnRcTsAaW/0U7/KO9WExA4j0ZPoRzBayB5fIPaZS/dpCLoKxjx05VTD5/hYA1oGbB2Nfmjjag3swtOq2ggmIuGWkIWJuDdflU9FKVf1FLmWIQ5PeEz9qsXAAn3AgVq50pLAj5MA0xmReatRk5D2QjrAI1B2lkBQVhqXEDogLWQFL+MsBkgKBFQ6J/9CiMhzZIBw8TsERxR8ASImAJWAKWgCVgCVhCBCwBS8ASsAQsAUuIgCVgCVgCloAlYAnZqbCmt00ERm+4JtBadjrv1Ar2EJv3Vg/KN1TfsJ51rbOJpj7Ev+MBaPyjK/YMWCZ1jyZ5iCPIAFSQwVS+qecN9Eum4gzhwKpjE+h48HQwrRDNnslgT4HlTOr7lKMvHJbSF1YEZGeCYBbvObMARrKFphq9HpQ9BBZDs7tXMzv0h2DqxNyI0LETK2rpKW6Gk1ph8WHpmw6iZbmqWbFAWmVM4WNM8llG50JnDcHdG5Yx3QcsqVryEyW8eTkDHRYqSwvuyRAfw6RpWMEK9cDqpEkzf8f7sNLMoy2HgGEcM3ZP0ayswpIt3fqLRvdGUIw1ayz5UFC53hjmgw+asZRtkLZNsmgnzWXLuOWF8LPlKGBs54xJsxM0C03M1FBPniQaqFTow8ZXYeFaOk4g1OoYPSzOqFEbh2WRdSpXwOvGngSLaYeA+kRWLSAstWLJ83luaOisGLTMGLXPgnLVweusR7MQ1jeoKdKlbOdkh0MP69wjm8FUmQQB8E+CieA5NKsYR3uNMFQOmhXxTzZI2S7zN9KkyAqYnZBacZgBq8lnef0qs6JpkCuquWdH8OrAm3XoO8ynzhWsIoo7orgjYAlYQgQsAUvAErAELAFrN5VKRMAatOSjALcKWIOTa+OQ3yBgDU5+CvBRXsAanBWiCcY+GuTBH+/psN6DYkIb3LEv7emadd0aKEJiUNnm7UNghpY2nGFFIvBxZTBTQJR+MxQ+60/D2gr1CCRLg3icb/58KBx8OTqcYT1RjkGysPXjHowNSW6YH86sIJrT6MV/YcvvsCvLBvOOewfAig1nVjn8V4GNkN1imae0ZFA5gGsHJGc4y23wPpQhCg9syWuVFg2K1SeHVfkUPNZbZ8xuHnvE0u0Z+t2K9l+9DXSEtSXvnVs8VBH8EzualHV6oK1t2QN3XDDXP2HtNp9dCPdX+wjoiOynmz/ljSVDVdwp7mDFss7wH9mjUR8eMW5btSvfN6K6k8MqxMvX09qigRL7xkVDVjb8445ltb7t1L73Pn0bJyV6r092U4hBJUb6lScdveWZH2x6wqJLhqwgXdqxrco6/bV+mM+idv5/b9MVHo71i2rymoVfOdxs3Q1Xb3L8NdtiGZ8Q1gM7lNXqhiSUbzykuspC9Pn8V7apJNjn6V1qZ9Z/hPfj3ELf63/4mds0mfAng5WP7Vgb1GH17BkBolPEvy68wzJA+ohtuMYltT4rl7BD5kvgNlxasolHKy7aNo/7yWA9tCNZZaagqUzHhVY0vwDexo34bR4GsKFlG2BRxFS60175N9jNfCOwLAEWKlGxr0dbtI3P+hPByu9QjxUgFzUZ/27EaJtmfmwDp2X3FZFBRw53IqxCNRYgvVnKw6yrNcjF+xVjy4siMISwrtuRrOZyD9WJn5eH7C0n4F879/gXDDaCKKDlVar6UtB4YUwrJWERwAtkdzV48oMM23cQrHxiB7JaaRPKKgDTHTQL8G+G7XxOGGyScjVpeosKGDHQ81C6hjt7KPfCemPhtpvFJ4GFOn33doaemwTN2ZF2IdM6EaDabPsK9GNHE4EIpKOD1Sytbwk/r1GGWLgISpE+hf5rFm1HYeoTwEK9/uPgnk5pk0L+Jvd+rgbNtueCrurjPz0BG1TyW/sD+AdZqs/2qzrKQwXehPzZYFN0frdy4c+25463HxYWdAoDlrg+WrLk0r620a9AYV39dP9z0lPR+jik6b+c3HNewD+Wnv/8r2KuqA4qUR/UwFprw7LgDshF4A2+zTbS3JmXwtDCug0K3x8ouYvvpH018uDF/Xzbsk3Lx9TRyzyGB6YH99oHa6W80Poh7Z2tDapY37/C6N88cshG4dJeWL/e1pDhE8PKR0tnObfFsx9n+YGf1Wi7veWntbZq3Qq3bPoSJU1KVeGmltfBmtvmn9Le/nXnktkgxRGFQanWn/rDepRHDr/TwU7En9DJn3nW9k77t92wrrMW4+9/SPd/oQaVJfxhFZbwNBVrUnNLnwLIMy++s5Bqj/JLFp+56JGezW388+pggfoOzJronP7vozVb686nr6sGk6pY1QytnkxIw0j0Vijb13wK3rvw59ttTNsLK6ddFbXL+OUL41A5U+daY6ej3Pu6p3DN32q0zLo2AX87uYrzySWLzlx4MZ2YtqsW2GGLQpAN3ByqHn/iZASd+xrFD1NQwbaWpooG0fdq4lGSOM8QF1dfFPzqwrOSMNSwrLv+hZazYSnpVQxKC0kFSg866fg7lJwC9vvfL9QGrtfq8OG3EmSyJbv0hw7ttsW3J27U7Wna206CzH/MHhd3MlCr+ad/iENahb9A7iiAC7f6AM+E6B+ch1RNZ5QXpU+BjXz1zbk//CSx4HbCWrYBHeYG5FW+IAb5hXSrT1QnKawkll17CRrRXdaSu6xr+7IqXmU/8iK83bunMPHVdr6wEKxjYS7nNps8fvCN4HoNNHgNfo+nZbYWA+f/fVbkyb5VkoUkwSqH7ADr4l9fA0MPK3/Nd5HVf2JirorAeyfrpbeve7nqp8oP3a69jVHf0g+WJPpkiz/T8XCnSuS9D2rCUhbLBe27qUxEf/5EW9Xtn02RPerZ+reOp/WtjYZbim049Q6O6Ce9sVYFnoRCqEiqf00C/jX0sKzbFmI6zsIneMFF8MC38Hbeum3Jkose5vuu+Rl8rJeu/dErmO5ba5w7PuT81afACzGwYqXFL9TsaYab9DTP7Bb8L6IbUcW+fh5Vm6KPY82c8cqtJStaPHMGqtKvzur9UV6pVYhSX5/83Z/0VdR2wXrhGg1z4ATkFy+xbu1XJ3TrnbBWe+CO2x+K83JKzZ1A8dF58G/c9MAzixbX7CmqEIgECB7T8ugAG8EJqa6C71KMqwKzC0Dp0NbKX/nkvBlnnFwTA3/AfX0u+iap7R2ftDi7PbAKC6JQuRp91eJl75z54k/67PvLT+Gjtd0JelMAueuroPBxv4k+e0HyFlSRWyO5q2orKFkQTP8ouBwqKlgYO7Sdp8Lb5yOnI7l6zViv51rsaGBrdnh3HsLQ3TfMoqd06138gRbjTglxKGHd/COo3HIxsspf8nftgT4RXu6/oXL7q9VAAT8+vG3ZQ39y8vJbFl+AdnXzpXD/CR+t7Q3Iqb7PNyLTDJ2oXTMBVpx7y8yf6y+2T3kRd7zWdhM47zBmoqMf0IH2lhWK0A9GBJL5ONzhlJrLyU82ZPp2wMp9Faxblmj5xeVFiKFPWab0bUz7sqpBxqyFiy5K9gQ+mW9/+H2ovPPdyku/+sHaygPV8yzSl5yvWS2ORffelYT2o509z0dhQ3N8MdiB5pUzIT1gjXlvq498weoHKwbJHBKqPtDC3T8bWljlMzVY9mas9FNyT1CqjYdLJ9few/cvPKsG5ANXzUzCxT998b0l19u3V72tDHf169vgXT+okAu+xkuO7/KCzqlvWr/eH+B7tEw1W8qWNSu/pB8sSwM9V/uWunLt0MK6PwQPxpdYd4N1cf8y1tU1cD6at7hP/Y21EHUMvX4Jv96ujbGdPC5UGqkSkJu49qRPsYuFcciN4/Nz59tp+4Dv2Yu9z+c3pVi/uiELXq5xSVYAABIcSURBVOB1WtCvGDQ0sPJHQT6Wv36gH91Qw+qDk/tVdWVrvAXt+mOVdPXNV2dXcs6NycKJ9trfHLVLwHdQmRXw85LAgD2jexvXWuF+bwWoguZnO65N1DbDWpAoR+GaOwfY84fap/p+v1qQ4g/71AVaL1afdl4x7UJfsBNhhKqvVKvR4waqOv3LbLjPPjO85arFUE7v584qsJTHDzsFVvYHZcybB2qpWqj1ndbF/fb2NaBysccyMrEujdQ0q7MEdK3X+x//9SQU5jxazSYGKkx318Lqu+tD7hujOwlW8cz4I5vZ9WTtyt/6VdXVvo0tQeGO3jUTJsN8/O6C9DfWT+6ptOppgcB0+H4CTnKqCH8/UGVD75Uvzvbd9Qw+tp0Ha9FFg2oJkl/aryBSW//8pydqjfj71klwFNBIBdaIW5/TegOkqiS6xk+Lv865ztHMLcLK/bufe4rzFjSJnQNrQ3zZoGpkf92/fFSjaMXb+jjhlnzDR0G7ItRyRtHqK5nnusf7v0t2uGAqpLUt5Ya5fG4TWHmtADsFVm6wLVr6VbD1acTVNx8tqXlfK4ZP5hNHJsBM3jT59LEHN583f9bI+Vf+xyPzfvjBdffB2ZZqXYo8c2it5fCWYC0rPNA/HVpuk3dLQwTrmu2svN5C3m0mwJrmPxQ+9J93DDwBV1ndHx4186azrmzXrVcz1FDyY3iFqm8wNLsiCAOOK1LuWbqz2LegWtII1sadAiv3KTQf5U5ofgCmqzAX87orsJDz62Xf/cvp8JtK6da/qlSpkqaXIWm7PnAgQ+01s4j1w346Z8EbEN8ZsKwf7HhWcJMTTbWhHpg6/BOykdvfu/7pMN7mLQuSH2lEM0J1K3oXL0/P2YLeYgD4o36wKnBbWdsZsH6V+BRgOW9Us/NQye6nefuu3fjiT975Lt55t3Xe2Rt1UimK2daE1re1XbUxsWILmlXQ+kUJBOt6S98JsEpnfwqsYJJjjaMw0sI7/Wtu6SsP3DyWv7LQ1zd/9ZbEBp2yhHePUHJz25r9Aw0Fla/x9H2D1o146tIdlxluA6wLPw1WVYf9ymzoPgFzug/mPrPxhZvtmnt148/mWAkkUNHLU3Ve/rESbAuwXoR+1VkJzA6XXr8TYGUjnwYrS7UffGj9926mZtwbDlvb/cRbduRhWusX/0nnhcIruYfnphbdfOiAmWa4f20WLIkOLaxZADfDwt7aJLZ/td3iibhpZfM0x5ld+eWc3RKGv2G+umau49ZI/oFf4e1v8oKzqJr6el5BM93fRVUz33m7pVJ9JXR0/iE9eQtZ5KlO02Wiuyksvbcy49J+sLS+pbAhgNWJafxXTQacjTG9N98vK3Cj43iCJSfd55EOKDXxQRztrSOxaVCaCZoYLlyFvqY8432CdemvWjZUf2pt/tclXqdsBXvey3BYTLPH/LNtshyH/Vcm6E0YVC6kJM25OGAfm7DrEO0VOznnxuh9LazWA58SLExT5ZSaPCWXNELQk1iExWwTTYeq8R/ZTlGpvQDIwIdlhb4vFMzEejgeFld0u9QLmZ88s3Rcz97v/OXBZ+jSte1m6ZeNPlPblmM01KttjhPsn6vw3y4lLRbZ9F7s2bzNTwkWpu3d+0etLMosnnY0672DlI8YLF8EfLDfonIotYBJn43P948zCo0tV1JSFWhWK88r5mw4/BiexNEZrTi7OPbM4xf1pl1/7t+HwKnkuL5BOVnmoY0tYae+ADE8bZ1NVXv51x5565WQ7bJVW6Nr7zUKjVSFWKjGrMx+CYIbij9XNg2CP11YXRg2VFQGsqXwokXmqKn8WdpzYldk/M9rBTISfigGKtFV3AwZrDYgqBb4cZjEkQzUSn2jCb26w7TzpnvnKmRjxxKGzKMJnvtn7DqZ65I6bziSuXtjc7hyXnvbd3hwQCO+WiPN+Ar8KZVgYVpWzL45OQEm6fbuDrNNwWyyrCqw8vLA5NlvKEydtUjh++TynRiBmNmWaeah8HV1eZfC7vvKDjTD/Ks0pK8KCnrothZqdKDSmg1LgZLMX0anT6CH5sOkP291o7qtAIMp0LJGc2Dtb+oH3RFrqfVmBgT8/rHBzPl3rf0yZVtm7HVu7+dv5AFB8UPe9svkzuri5ilzLuSaxYfHlSv4+1NtP+6djxvuBdajWcyS7cFOf4lu0cIHfT/gBz4BY94MfHYKaZbMoiyt4+IbxZCxA83wOo1+UIGLg07FOC6rwAdBJs1i8Rf59hB6+ql03M3pM/SCzO8gKFd9FsimjphaakevxRzQKv51qulv9u9P7iWtc/sr3fyS3fjBzj4z3Fnln0k7OKqwDBo4GFgzPQnDmg8pO2xjlCcpVDm/evGNkIlbQQaPW6oBZ3PuMqTtIXXTSQY5XNxQ1NgOg2W+GVcq+Fsq3SaCSsdsWLJBWVtJBr+dQZtBBKdwWMiwGMZ7qYA8EYJER9aNoKlNgHgLyP3K0TyIsv5NmlXM8pLc19/Rk0/2Zp08OEDTKeKBZJ+Gjvw4LMPWLAxlWL4TjB5YbZRrPgqPYN5DsAz4HeANnGqbYQZ6YBXjmN4NheSOgwVXjIf8dQsXLqCbwkT879cg3wbsl3DvsfgjrzW3JSEAqzEhU0EKNZ970ihqW2w2Q0FFdQwyPyzHazR/cAiwEGtOtAfU7ACw7Oi7xCti0+df+Hdd13po8WZ78ayehiyHhRltiIbBNaAg4xE/J1hGydBJ73QCklMxUtBjeJSlpKNkFc85mkWwDHyiNAixmUTFROLZUmIHwtqBog9QQ2PDsmLVD5j6fvv8pYma8WPe/UH78dGMntYzCR52PuuH7JnvLjwjjFHn+fBipi0GZ4yHg9VsIIbZTaDtWDAngRLLHwq5hk7FbFwdC6SVFfpYasebP8ycMp5FL6+0GMGV6YPHM+0KFhyesPpbuO44Jct+m8gzu5xeePuDV+PcYfHSkJXb2P12qKgV8LCTNlftsEmdiBUr7eDU7mxY3CUpWev0E7REFdb3Nv7k8VNfeFrveRthpaGnQmGztX+bvByoaLsbLE5ESZv/+V5L0NEPs7tbX/PRJWt5sJ/mB5Sc0H1gWHaUsWm5c4cPV72TYdksQmksfi7g0dd1YD2jQ+Gv33g5YW3EUtAfetQr2FvcGUizCgMw1HYzzeKO6pjSc7gYsV291Z2Aj9+N/TVkatYCu6aDl9sdSgM0pOF1NP8eAFZiGMLK3XotV5AbtweW9fdA24TCCrxlfmuZ7mf0blgTBuvE7uKlb2pq1bOtCdsvagd4F8az0E3BfAjJ4ahZCjxGXyu3A1boxpFTZl4KpwPcx6ss9Gt//moY3tP5eAzdG9s5A6qU+IF2Rft1+sBj7COsyk3TIT+jtpoD7q7oPcUE2KwNDzksGbIywPbMK1FQO3n3pq+qlSm8UFM56sOTXu2m0NR6AfQC74gCj371KDhdn3d12+zzrIHuN0I8J9SYKHdykVItus3Z8E6ABY2WP2YW5pQC0MW2ZdwKR1HUmTOidoD60Yev6wWuT490r6rY7QCC1gnzyattPPc/B2x0FKXOj6uh9g3hozWwjOEGa1QR5M40mJZibFOSnArqsyt38TbN6LrOenGNHXhmu9+ybE+Eudrv5gHZejA70Iutl0m5DGp7epSanqPeoazONbe3+ytT1E5TgYsC8HpL4b4gWHMVaE+m23e2z4LRZ15zaQeaQ15m2wTrePvr8R4tq2yEm534MmTZ7/yoKGl+BI+3gxUesM7uPeqnmlOpUqLTUkzAIrySLu33LMw3YufndQOSLK8kqVbGBEUxdzos5ViAzlEYZG4jLHvqvRj54Nfs7G7R1dWq4C6nTXcZ/VQ21DV5BWQi6YEukl/6UzsVXcCsUOloxKJAJnjPy+8w6DKAmQ/fTnltCyjPL/vJ9J2eG7LIvWCtNvSbYRvN0H7DPK6owf1X2rnWm1/psbRL7b54ibtR4YJmyDxpwWbGc1lGpxyp4NVMzAEYr3szKHdmfPYn9PDU1LARlDswTxm3c2GNKh4GbLyyHFpWmId2OhM7Dr68czPcBOr9J2uW1lujzKtmSrb7D75LjbTzYJ5xPHx785fqTFLVeiWUBQ5rgtWpZxisZ5qRU3kUdzAonbiQ2lUjeDSWvN6pm9rF3+op0VAzgRzvGZuL2yFpV9DiccWvwv17UPSt/QZLCWYUpiGs9unHr640K4Z+emX07LB3BrXyZXeNNccrCttlYZUVM2LG0kGzpw6QN6yZ++a71BKNr18Mx4ZzTovjcmTQV15aU4x23lXqOpbNLW2XhQXHWEppkl+loVC+dgDXpHwUMo++dXLQacRgxSqRm6vF6Mzgm8REX97had3psO6Hr2+YPVbHuKF86BS7x8AMuHXjD38wmWryic9jc0/svDvZW6U6SPlJbPeDxWB+WzPqy8/LbZOKk7mJmLPnr/n5nz66meuZFc6ff8v5c516rG3o4vwg7H6wzJjZQLZlZibMtMbygiKc8WTz6z89w+5jyT37P09yRgxRd2padzqsUovjh44KZRqCdv2WdWFs7V+u5WZU4c6qFL8fisdTaLpnw6o2lITbp1rN1Yj+nye2vGH7L+qmBws2wI/g3clq9f1GrXR3bxqO7L6wnCpDPXfj41Np4Bm+dsQ3vsq55CLUTeh9BU6CK18Lwy8H8HnBTeocN5cLrE7u8rAy3NByATidD1FQ4qvWTzmrLlSmS3lN6fiu4MdB+PoAPi+c6tu2b/ON7k1tl4dl19LMOQGLdLw68KLe5tmvUzA/F45EfnN/gg4rO0CTdjNuRIJKbjKkzchj1JH6sVezUDgV8jkonw3v8TqeF3TrUSwdMi3p1AzyRr36rgiL6pcyNBjBsVzRQpXJdpheupmrjDl9GmpE9iRIhweyLxZZDQdSCygG40HNUZMILMpnw/eCHM9awesySWZBJG5C+PR08LGiaoAeTjKInZ+1dkVYLAiWxFuycTX4mpV8Y6y/7fwZj7zL80NzbLgK9ZSBbCsMvLEYbxKlKjCX2nyooPwTZHJmt2c1Vg7CBbwBHC6qrKLCQmBL5pu7pBmWFTjHHreVnJb1l9VReNV/IhpJmdvlitdtgymquYHqq1m0L6yVCKuEsN5A9RoPJ76YQzU6PGpOZDasEIPpcdaCa7mDd0VYMAXOtfOpggxwysxzQ9D15TmoMGWubpNDBafdcxY2C0sGxSR9+go8wHjVn/wvUOJGTn8hp6XKoCQMphOsUtCgprgd9CbSjO6KsMwof006/RvQlYDbu6/QEV9aBSvAXf8xYF1hO/aJA8JS6R3AZaB22m0RVfY+g0mWdh8oQWbGjlijnpuFEFpf47umht7s2SKcrZhFJT3gK8jhD8tuW5xtGzkVbtIWwAqwWiiP/P7xbTwzxAiCu/4tjjZG7o6sFcOyuKUXz4buyto/nAqn5uCUfOmMxJkhWJ94KvZQbE66dHz0jB/BilD6jF3SDKmhPerXBGgPl8648q4pQM6JepRPBwhQbGTxFzLH7/R0DgtYaVKt4ljIjAdr7GPfg4yqwwSwHgi86owh+Tg1cw8LWFz8NJakX+06CbUoMBXYsScFJwEb+3Igbnc9MKdXS40CFqoSZMZtmNPKHfm/JgduPanlcv3DuVjSydu9gQ4Ol1QBy5H5kBsNpjMmsHX/7BnNkwMnVZWOF/hu1AWsqmq1QCD+fI3y8HfRFH3NsEOw7DBQrGEzv+F8Ld/WHnH8PXUOeZfqBSmOsl/ZzgUBq0cK42F9tRrQnIrATkd1I07mf9PAO+tDAlZtrBWkwZ9szSKT84et57hSTc63Q/poELBqpa2nsoqPHtzZ2mxvaZuhWWNBwOoj+eZqftdJmlUI6LzRSKY5Cc+FBaz+hlitMzmXO/oz4hQ1VPwR6DoJBKz+sn4sFW4qMI+XcdjUI6htuwaPTwUBa1NZTZbIxrfxwnNxbIj3cH7sFBCwBqTlvxsVrHn2SKqJaI7kNLBmHwoC1sBSDPAK5j/Rm9JuVLN3Jz8DAtbmxJrd3DuXz7uB5iQIWFuQyoxm/+QrF7Ud0RqYHR5eSRt+sFC73jw/MH1s85H6cEvYcIQ1bEXAErAErE8hMxGwhGYJWAKWgCVEwBKwBCwBS8ASsIQIWAKWgCVgCVgClhABS8ASsAQsAUvAEiJgCVgCloAlYAlYQgQsAUvAErAELAFLiIAlYAlYApaAJWAJEbAELAFLwBKwdl/5/xHolR98rswaAAAAAElFTkSuQmCC";
Polymer({
	is: 'appl-promotion',
	properties:{promotion:{value:promotion}}
});

	</script>
</dom-module>
<dom-module id="appl-echelon1" assetpath="src/">
	<template>
		<style>
			:host {
				display: block;
				width: inherit;
			}
			:host > img {
				width: inherit;
				height: inherit;
			}
		</style>
		<img src="[[echelon1]]" alt="Echelon 1">
	</template>

	<script>
var echelon1 = "data:image/png;base64,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";
Polymer({
	is: 'appl-echelon1',
	properties:{echelon1:{value:echelon1}}
});

	</script>
</dom-module>
<dom-module id="appl-echelon2" assetpath="src/">
	<template>
		<style>
			:host {
				display: block;
				width: inherit;
			}
			:host > img {
				width: inherit;
				height: inherit;
			}
		</style>
		<img src="[[echelon2]]" alt="Echelon 2">
	</template>

	<script>
var echelon2 = "data:image/png;base64,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";
Polymer({
	is: 'appl-echelon2',
	properties:{echelon2:{value:echelon2}}
});

	</script>
</dom-module>
<dom-module id="appl-cert" assetpath="src/">
	<template>
		<style include="shared-styles">
			:host {
			}
			:host > .card {
				position: relative;
				padding-top: 150px;
			}
			:host > .card > iron-selector {
				display: flex;
				flex-wrap: nowrap;
				justify-content: space-between;
				padding: 2px;
				overflow-x: auto;
				position: absolute;
				top: 16px;
				left: 16px;
				right: 16px;
			}
			:host > .card:before {
				content: "\2190";
				left: 1px;
			}
			:host > .card:after {
				content: "\2192";
				right: 1px;
			}
			:host > .card:before,
			:host > .card:after {
				position: absolute;
				top: 75px;
				opacity: 0.5;
			}
			:host > .card > iron-selector > div  {flex-shrink: 0;}
			:host > .card > iron-selector > div > div {white-space: nowrap;}
			:host > .card > iron-selector > div > div + * {
				cursor: pointer;
				padding: 1px;
				width: 4em;
			}
			:host > .card > iron-selector > div.iron-selected {
				outline: 2px solid var(--app-primary-color);
			}
			:host > .card > iron-selector > div > div {text-align: center;}
			:host > .card > iron-pages > * {width: 100%;}
		</style>
		<div class="card">
			<iron-selector selected="{{selected}}" attr-for-selected="name" role="navigation">
				<div name="abi1"><div>Abitur  1</div><appl-abi1></appl-abi1></div>
				<div name="abi2"><div>Abitur  2</div><appl-abi2></appl-abi2></div>
				<div name="abi3"><div>Abitur  3</div><appl-abi3></appl-abi3></div>
				<div name="abi4"><div>Abitur  4</div><appl-abi4></appl-abi4></div>
				<div name="diplom1"><div>Diploma 1</div><appl-diplom1></appl-diplom1></div>
				<div name="diplom2"><div>Diploma 2</div><appl-diplom2></appl-diplom2></div>
				<div name="promotion"><div>PhD      </div><appl-promotion></appl-promotion></div>
				<div name="echelon1"><div>Echelon 1</div><appl-echelon1></appl-echelon1></div>
				<div name="echelon2"><div>Echelon 2</div><appl-echelon2></appl-echelon2></div>
			</iron-selector>
			<div>Select above to display or <a href="http://schrotie.de/applApp/zeugnisse.pdf">download high-res scans</a>.</div>
			<iron-pages selected="{{selected}}" attr-for-selected="name">
				<appl-abi1 name="abi1"></appl-abi1>
				<appl-abi2 name="abi2"></appl-abi2>
				<appl-abi3 name="abi3"></appl-abi3>
				<appl-abi4 name="abi4"></appl-abi4>
				<appl-diplom1 name="diplom1"></appl-diplom1>
				<appl-diplom2 name="diplom2"></appl-diplom2>
				<appl-promotion name="promotion"></appl-promotion>
				<appl-echelon1 name="echelon1"></appl-echelon1>
				<appl-echelon2 name="echelon2"></appl-echelon2>
			</iron-pages>
		</div>
	</template>

	<script>
Polymer({
	is: 'appl-cert',
	_selected:function(a, b) {return a === b;}
});
	</script>
</dom-module>
<dom-module id="appl-samples" assetpath="src/">
	<template>
		<style include="shared-styles">
			:host {
			}
			:host > div > .smallprint,
			:host > div > .smallprint * {
				font-size: 0.8em;
			}
		</style>
		<div class="card">
			<h1>This Application</h1>
			<p>
				This web application was written by Thorsten Roggendorf from
				scratch. It was build from web components making use of the Polymer
				web components framework and some of its components.
				The application was then bundled into a self-contained HTML file
				that can be loaded directly into a compatible web browser without
				requiring a web server. It is designed to be fully responsive
				from smart phone to big screens to traditional print / PDF.
			</p>
			<p>
				It does work from a web server without problems, though, as
				demonstrated <a href="http://schrotie.de/applApp/demo.html">here</a>.<br>
				The app's source code can be reviewed
				<a href="https://github.com/schrotie/job-application">here</a>.
			</p>
			<h1 class="smallprint">Polymer's license</h1>
			<p class="smallprint">
				@license<br>
				Copyright (c) 2016 The Polymer Project Authors. All rights reserved.<br>
				
					This code may only be used under the BSD style license found at
					<a href="http://polymer.github.io/LICENSE.txt">http://polymer.github.io/LICENSE.txt</a>
				<br>
				
					The complete set of authors may be found at
					<a href="http://polymer.github.io/AUTHORS.txt">http://polymer.github.io/AUTHORS.txt</a>
				<br>
				
					The complete set of contributors may be found at
					<a href="http://polymer.github.io/CONTRIBUTORS.txt">http://polymer.github.io/CONTRIBUTORS.txt</a>
				<br>
				
					Code distributed by Google as part of the polymer project is also
					subject to an additional IP rights grant found at
					<a href="http://polymer.github.io/PATENTS.txt">http://polymer.github.io/PATENTS.txt</a>
				<br>
			</p>
			<h1>Hotel</h1>
			<p>
				This set of applications was developed for a hotel where staff
				and guests use it to control lights and climate in the rooms.
				It runs on wall mounted tablets and guest smart phones. The
				navigation menu in the top left is not part of the production
				app. It was developed for demonstration purpose. In production
				the different apps run on different addresses / devices.
				A hallmark of this app are the realistic lighting effects in the
				guest rooms. Not everything works in this demo, since it relies
				on data routed through the specific automation network of the
				hotel. Also it was developed for one specific browser, which runs
				on the tablets.<br>
				Everything is built from web-components, all developed by Thorsten
				Roggendorf. For performance reasons no Polymer components were
				used.<br>
				Please note that Arigo's UI was a one man show at that point. Upon
				my many responsibilities being a designer was one I do not particularly
				pride myself on. All artwork and image processing, layout, color
				choices ... please bear with me.<br>
				You can access the demo
				<a href="http://schrotie.de/applApp/hotel.html">here</a>
			</p>
		</div>
	</template>

	<script>
Polymer({
	is: 'appl-samples'
});
	</script>
</dom-module>
<dom-module id="appl-contact" assetpath="src/">
	<template>
		<style include="shared-styles">
			:host > address > div:nth-child(3) {margin-bottom: 1em;}
		</style>
		<address>
			<div>Thorsten Roggendorf</div>
			<div>Street ##</div>
			<div>ZIP City</div>

			<div>Fon: <a href="tel:+49000">+49 000 000000</a></div>
			<div>Mail: <a href="mailto:spam@spam.de">spam@spam.de</a></div>
		</address>
	</template>

	<script>
Polymer({
	is: 'appl-contact'
});
	</script>
</dom-module>
<dom-module id="appl-contactcard" assetpath="src/">
	<template>
		<style include="shared-styles">
			:host {display: block;}
			/*
			:host > div > appl-contact,
			:host > div > span {display: inline-block;}
			:host > div > span {
				vertical-align: top;
				margin-left: 3em;
			}
			:host > div > span > paper-icon-button {
				color: var(--app-secondary-color);
				background-color: var(--app-primary-color);
				border-radius: 50%;
				box-shadow: var(--appl-z1-shadow);
			}
			:host > div > span > paper-icon-button:hover {
				box-shadow: var(--appl-z2-shadow);
			}
			*/
		</style>
		<div class="card">
			<appl-contact></appl-contact>
			</div>
	</template>

	<script>
Polymer({
	is: 'appl-contactcard'//,
	//ready:function() {alert("Intent" + window.Intent);},
	//_add:function() {console.log("add");}
});
	</script>
</dom-module>
<dom-module id="appl-about" assetpath="src/">
	<template>
		<style include="shared-styles">
			:host {
			}
		</style>
		<div class="card">
			<h1>About</h1>
			<p>
				This web application was written by Thorsten Roggendorf from
				scratch for his application for a job at QIO. It was build from
				web components making use of the Polymer web components framework
				and some of its components.
				The application was then bundled into a self-contained HTML file
				that can be loaded directly into a compatible web browser without
				requiring a web server.
			</p>
			<p>
				</p><div>
					It does work from a web server without problems, though, as
					demonstrated <a href="http://schrotie.de/applApp.html">here</a>.
				</div>
				<div>
					The app's source code can be reviewed
					<a href="http://schrotie.de/applApp.zip">here</a>.
				</div>
			<p></p>
			<h1>Polymer's license</h1>
			<p>
				</p><div>@license</div>
				<div>Copyright (c) 2016 The Polymer Project Authors. All rights reserved.</div>
				<div>
					This code may only be used under the BSD style license found at
					<a href="http://polymer.github.io/LICENSE.txt">http://polymer.github.io/LICENSE.txt</a>
				</div>
				<div>
					The complete set of authors may be found at
					<a href="http://polymer.github.io/AUTHORS.txt">http://polymer.github.io/AUTHORS.txt</a>
				</div>
				<div>
					The complete set of contributors may be found at
					<a href="http://polymer.github.io/CONTRIBUTORS.txt">http://polymer.github.io/CONTRIBUTORS.txt</a>
				</div>
				<div>
					Code distributed by Google as part of the polymer project is also
					subject to an additional IP rights grant found at
					<a href="http://polymer.github.io/PATENTS.txt">http://polymer.github.io/PATENTS.txt</a>
				</div>
			<p></p>
		</div>
	</template>

	<script>
Polymer({
	is: 'appl-about'
});
	</script>
</dom-module>
<dom-module id="appl-abi" assetpath="src/">
	<template>
		<style include="shared-styles">
			:host {
				display: block;
				width: inherit;
			}
		</style>
		<appl-abi1></appl-abi1>
		<appl-abi2></appl-abi2>
		<appl-abi3></appl-abi3>
		<appl-abi4></appl-abi4>
	</template>
	<script>
Polymer({
	is: 'appl-abi'
});
	</script>
</dom-module>
<dom-module id="appl-diplom" assetpath="src/">
	<template>
		<style include="shared-styles">
			:host {
				display: block;
				width: inherit;
			}
		</style>
		<appl-diplom1></appl-diplom1>
		<appl-diplom2></appl-diplom2>
	</template>
	<script>
Polymer({
	is: 'appl-diplom'
});
	</script>
</dom-module>
<dom-module id="appl-print" assetpath="src/">
	<template>
		<style include="shared-styles">
			:host {
				display: block;
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				min-height: 100%;
				background-color: white;

				--appl-print-theme: {
					margin: 0;
					padding: 20mm;
					display: block;
					width: 21cm;
					min-height: 297mm;
					color: #000;
					box-shadow: none;
				};
			}
			:host > appl-hello,
			:host > appl-facts,
			:host > appl-life {
				display: block;
			}

			:host .head {
				position: relative;
				height: 15em;
			}
			:host appl-contact {
				position: absolute;
				top: 0;
				right: 0;
			}
			/* Chrome does not support page breaks, this hack should fix it but doesn't:
				html, body, .main, .tabs, .tabbed-content { float: none; }
			*/
			:host > .pageBreak {
				display: block;
				page-break-inside: avoid;
				page-break-after: always;
				position: relative;
			}
			/*
			@page {
				size: 21cm 29.7cm;
				margin: 20mm 20mm 20mm 20mm;
			}
			*/
		</style>

		
		<appl-hello name="hello">
			<div class="head">
				<appl-contact name="contact"></appl-contact>
			</div>
		</appl-hello>
<appl-facts name="facts"></appl-facts>
<appl-life name="life" class="print"></appl-life>

		<appl-abi></appl-abi>
		<appl-diplom></appl-diplom>
		<appl-promotion></appl-promotion>
		<appl-echelon1></appl-echelon1>
		<appl-echelon2></appl-echelon2>
	</template>
	<script>
Polymer({
	is: 'appl-print'
});
	</script>
</dom-module>
<dom-module id="appl-app" assetpath="src/">
	<template>
		<style include="shared-styles">
			:host {
				--app-primary-color: #e0ff6a;
				--app-secondary-color: #840021;
				--app-drawer-width: 11em;

				display: block;
			}

			:host app-header {
				background-color: var(--app-primary-color);
				color: var(--app-secondary-color);
				font-weight: bold;
				/*@apply(--shadow-elevation-3dp);*/
				box-shadow: var(--appl-z2-shadow);
			}
			:host app-header paper-icon-button {
				--paper-icon-button-ink-color: var(--app-secondary-color);
			}

			:host .drawer-list {
				margin: 0 20px;
			}

			:host .drawer-list a {
				display: block;
				padding: 0 16px;
				text-decoration: none;
				color: #000;
				opacity: 0.5;
				line-height: 40px;
				transition: 0.5s;
			}

			:host .drawer-list a.iron-selected {
				opacity: 1;
				font-weight: bold;
			}

			:host app-header-layout div {position: relative;}
			:host app-header-layout appl-hello,
			:host app-header-layout appl-facts,
			:host app-header-layout appl-life,
			:host app-header-layout appl-cert,
			:host app-header-layout appl-samples,
			:host app-header-layout appl-contactcard,
			:host app-header-layout appl-about {
				/*transition: opacity 0.5s, display 0s 0s;
				display: none;*/
				transition: height 0.5s;
				opacity: 0;
				position: absolute;
				top:0;
				left: 0;
				min-width: 100%;
				height: 0;
				overflow: hidden;
			}
			:host app-header-layout appl-hello[appl-selected],
			:host app-header-layout appl-facts[appl-selected],
			:host app-header-layout appl-life[appl-selected],
			:host app-header-layout appl-cert[appl-selected],
			:host app-header-layout appl-samples[appl-selected],
			:host app-header-layout appl-contactcard[appl-selected],
			:host app-header-layout appl-about[appl-selected] {
				transition: opacity 0.9s, display 0s 0.5s;
				height: initial;
				z-index: 1;
				opacity: 1;
				display: block;
			}

		</style>

		<app-location route="{{route}}" use-hash-as-path=""></app-location>
		<app-route route="{{route}}" pattern=":page" data="{{routeData}}" tail="{{subroute}}"></app-route>

		<template is="dom-if" if="[[!_isPrint(page)]]">
			<app-drawer-layout fullbleed="">
				<app-drawer id="drawer">
					<app-toolbar>Contents</app-toolbar>
					<iron-selector selected="[[page]]" attr-for-selected="name" class="drawer-list" role="navigation">
						<a name="hello" href="#hello">Hello</a>
						<a name="facts" href="#facts">Fact Sheet</a>
						<a name="life" href="#life">Professional</a>
						<a name="cert" href="#cert">Certificates</a>
						<a name="samples" href="#samples">Work Samples</a>
						<a name="contact" href="#contact">Contact</a>
						<a name="print" href="#print">Print</a>
					</iron-selector>
				</app-drawer>

				<app-header-layout>

					<app-header condenses="" reveals="" effects="waterfall">
						<app-toolbar>
							<paper-icon-button icon="appl-icons:menu" drawer-toggle=""></paper-icon-button>
							<div main-title="">Thorsten Roggendorf</div>
						</app-toolbar>
					</app-header>
					<div>
						<appl-hello appl-selected$="[[_eql(page, &quot;hello&quot;  )]]"></appl-hello>
						<appl-facts appl-selected$="[[_eql(page, &quot;facts&quot;  )]]"></appl-facts>
						<appl-life appl-selected$="[[_eql(page, &quot;life&quot;   )]]"></appl-life>
						<appl-cert appl-selected$="[[_eql(page, &quot;cert&quot;   )]]"></appl-cert>
						<appl-samples appl-selected$="[[_eql(page, &quot;samples&quot;)]]"></appl-samples>
						<appl-contactcard appl-selected$="[[_eql(page, &quot;contact&quot;)]]"></appl-contactcard>
					</div>
				</app-header-layout>
			</app-drawer-layout>
		</template>
		<template is="dom-if" if="[[_isPrint(page)]]">
			<appl-print id="print"></appl-print>
		</template>
	</template>

	<script>

(function() {

	var queued;
	function queuePrint() {
		if(queued) return;
		queued = true;
		setTimeout(function() {
			queued = false;
			window.print();
		}, 100);
	}
	Polymer({
		is: 'appl-app',

		properties: {appl: Object},

		observers: ['_routePageChanged(routeData.page)'],

		_routePageChanged: function(page) {
			this.page = page || 'hello';
			try {
				document.body.scrollTop = 0;
				document.body.parentElement.scrollTop = 0;
			} catch(e) {}
			try {
				var drawer = this.$$("app-drawer");
				if(!drawer.persistent) drawer.close();
				else this.$$("app-drawer-layout").notifyResize();
			} catch(e) {}
			if(page == "print") queuePrint();
		},
		_isPrint:function(page) {return page === "print";},
		_eql:function(a, b) {return a === b;}
	});
})();
	</script>
</dom-module>
<style>
      body {
        margin: 0;
        font-family: 'Roboto', 'Noto', sans-serif;
        line-height: 1.5;
        min-height: 100vh;
        background-color: #eeeeee;
      }
    </style></div>
    <appl-app></appl-app>
  

</body></html>